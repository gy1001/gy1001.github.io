import{_ as l,M as h,p as d,q as s,R as e,t,N as i,a1 as r}from"./framework-e8cb8151.js";const n={},p=r(`<h1 id="http-相关面试" tabindex="-1"><a class="header-anchor" href="#http-相关面试" aria-hidden="true">#</a> Http 相关面试</h1><ul><li>前端工程师开发界面</li><li>需要调用后端的接口，提交/获取 数据 ---- http 协议</li><li>要求事先掌握好 Ajax</li></ul><h2 id="_1-状态码" tabindex="-1"><a class="header-anchor" href="#_1-状态码" aria-hidden="true">#</a> 1. 状态码</h2><h3 id="_1-1-状态码分类" tabindex="-1"><a class="header-anchor" href="#_1-1-状态码分类" aria-hidden="true">#</a> 1.1 状态码分类</h3><ul><li>1xx： 服务器收到请求</li><li>2xx: 请求成功，如 200</li><li>3xx：重定向，如 302</li><li>4xx: 客户端错误，如 404</li><li>5xx: 服务端错误，如 500</li></ul><h3 id="_1-2-常见状态码" tabindex="-1"><a class="header-anchor" href="#_1-2-常见状态码" aria-hidden="true">#</a> 1.2 常见状态码</h3><ul><li>200 成功</li><li>301 永久重定向（配合 response header 中的 location，浏览器自动处理）</li><li>302 临时重定向（配合 response header 中的 location, 浏览器自动处理）</li><li>304 资源未被修改（重要）</li><li>404 资源未找到</li><li>403 没有权限</li><li>500 服务器错误</li><li>504 网关超时</li></ul><h3 id="_1-3-关于协议和规范" tabindex="-1"><a class="header-anchor" href="#_1-3-关于协议和规范" aria-hidden="true">#</a> 1.3 关于协议和规范</h3><ul><li>就是一个约定</li><li>要求大家都跟着执行</li><li>不要违反规范，例如：IE 浏览器</li></ul><h2 id="_2-http-methods" tabindex="-1"><a class="header-anchor" href="#_2-http-methods" aria-hidden="true">#</a> 2. Http Methods</h2><h3 id="_2-1-传统的-methods" tabindex="-1"><a class="header-anchor" href="#_2-1-传统的-methods" aria-hidden="true">#</a> 2.1 传统的 methods</h3><ul><li>get 获取服务器的数据</li><li>post 向服务器提交数据</li><li>简单的网页功能，就这两个操作</li></ul><h3 id="_2-2-现在的-methods" tabindex="-1"><a class="header-anchor" href="#_2-2-现在的-methods" aria-hidden="true">#</a> 2.2 现在的 methods</h3><ul><li>get 获取数据</li><li>post 新建数据</li><li>patch/put 更新数据</li><li>delete 删除数据</li></ul><h2 id="_3-restful-api" tabindex="-1"><a class="header-anchor" href="#_3-restful-api" aria-hidden="true">#</a> 3. Restful API</h2><ul><li>一种新的 API 设计方法（早已推广使用）</li><li>传统的 API 设计：把每个 URL 当做一个功能</li><li>Restful API 设计：把每个 URL 当做一个唯一的资源</li></ul><h3 id="_3-1-如何设计成一个资源呢" tabindex="-1"><a class="header-anchor" href="#_3-1-如何设计成一个资源呢" aria-hidden="true">#</a> 3.1 如何设计成一个资源呢？</h3><h4 id="_3-1-1-尽量不用-url-参数" tabindex="-1"><a class="header-anchor" href="#_3-1-1-尽量不用-url-参数" aria-hidden="true">#</a> 3.1.1 尽量不用 url 参数</h4><ul><li>传统的 API 设计：/api/list?pageIndex=2</li><li>Restfule API 设计：/api/list/2</li></ul><h4 id="_3-1-2-用-method-表示操作类型" tabindex="-1"><a class="header-anchor" href="#_3-1-2-用-method-表示操作类型" aria-hidden="true">#</a> 3.1.2 用 method 表示操作类型</h4><p><strong>1. 传统 API 设计</strong></p><ul><li>post 请求 /api/create-blog</li><li>post 请求 /api/update-log?id=100</li><li>get 请求 /api/get-blog?id=100</li></ul><p><strong>2. Restful API 设计</strong></p><ul><li>post 请求 /api/blog</li><li>patch 请求 /api/blog/100</li><li>get 请求 /api/blog/100</li></ul><h2 id="_4-http-headers" tabindex="-1"><a class="header-anchor" href="#_4-http-headers" aria-hidden="true">#</a> 4. http headers</h2><h3 id="_4-1-常见的-request-headers" tabindex="-1"><a class="header-anchor" href="#_4-1-常见的-request-headers" aria-hidden="true">#</a> 4.1 常见的 Request Headers</h3><ul><li>Accept 浏览器可接收的数据格式</li><li>Accept-Encoding 浏览器可接收的压缩算法，如 gzip</li><li>Accept-Languange 浏览器可接收的语言，如 zh-CN</li><li>Connection: keep-alive 一次 TCP 链接重复使用</li><li>cookie</li><li>Host</li><li>User-Agent: 简称 UA，浏览器信息</li><li>Content-type: 发送数据的格式，如 application/json</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/274cbe0e2a6841008eb26fa8caaf0f41~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="_4-2-常见的-response-headers" tabindex="-1"><a class="header-anchor" href="#_4-2-常见的-response-headers" aria-hidden="true">#</a> 4.2 常见的 Response Headers</h3><ul><li>Content-type 返回数据的格式，如 application/json</li><li>Content-length 返回数据的大小，多少字节</li><li>Content-Encoding 返回数据的压缩算法，如 gzip</li><li>Set-Cookie</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ba6082f7427427f814199e4ef3ee04d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="_4-3-自定义-header" tabindex="-1"><a class="header-anchor" href="#_4-3-自定义-header" aria-hidden="true">#</a> 4.3 自定义 header</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// http://axios-js.com/docs/#Request-Config</span>
<span class="token comment">// headers are custom headers to be sent</span>
<span class="token literal-property property">heades</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string-property property">&#39;X-Requested-With&#39;</span><span class="token operator">:</span> <span class="token string">&#39;XMLHttpRequest&#39;</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-缓存相关的-headers" tabindex="-1"><a class="header-anchor" href="#_4-4-缓存相关的-headers" aria-hidden="true">#</a> 4.4 缓存相关的 headers</h3><ul><li>Cache-Control Expires</li><li>Last-Modified If-Modified-Since</li><li>Etag If-None-Match</li></ul><h2 id="_5-http-缓存" tabindex="-1"><a class="header-anchor" href="#_5-http-缓存" aria-hidden="true">#</a> 5. http 缓存</h2><h3 id="_5-1-关于缓存的介绍" tabindex="-1"><a class="header-anchor" href="#_5-1-关于缓存的介绍" aria-hidden="true">#</a> 5.1 关于缓存的介绍</h3><h4 id="_5-1-1-什么是缓存" tabindex="-1"><a class="header-anchor" href="#_5-1-1-什么是缓存" aria-hidden="true">#</a> 5.1.1 什么是缓存</h4><ul><li>缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件</li></ul><h4 id="_5-1-2-为什么需要缓存" tabindex="-1"><a class="header-anchor" href="#_5-1-2-为什么需要缓存" aria-hidden="true">#</a> 5.1.2 为什么需要缓存</h4><ul><li>缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件</li><li>降低服务器的压力，提升网站性能。</li><li>加快客户端加载网页的速度， 提升用户体验。</li></ul><h4 id="_5-1-3-哪些资源是可以被缓存" tabindex="-1"><a class="header-anchor" href="#_5-1-3-哪些资源是可以被缓存" aria-hidden="true">#</a> 5.1.3 哪些资源是可以被缓存？</h4><ul><li>静态资源（js,css,img）</li></ul><h3 id="_5-2-强制缓存" tabindex="-1"><a class="header-anchor" href="#_5-2-强制缓存" aria-hidden="true">#</a> 5.2 强制缓存</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81MjQyMTI1LTA2YWMyNTFlMTUwOTk5NDkucG5n?x-oss-process=image/format,png" alt="img"></p><h4 id="_5-2-1-cache-control" tabindex="-1"><a class="header-anchor" href="#_5-2-1-cache-control" aria-hidden="true">#</a> 5.2.1 Cache-Control</h4><ul><li>在 <code>Response Headers</code> 中，服务端来进行控制</li><li>控制强制缓存的逻辑</li><li>例如 Cache-Control: max-age=31536000 (单位是秒)</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679b625e20c7448296d6f58011d96976~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/686977128949457e8775d57bdcbba03c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="_5-2-2-cache-control-的值" tabindex="-1"><a class="header-anchor" href="#_5-2-2-cache-control-的值" aria-hidden="true">#</a> 5.2.2 cache-control 的值</h4><ul><li>max-age: 设置缓存的最大过期时间</li><li>no-cache: 不用本地缓存，向服务端请求，交给服务端来处理</li><li>no-store: 不让服务端做缓存，完全不缓存</li><li>private: 发起请求的浏览器才能使用返回数据的缓存</li><li>public: 这个 HTTP 请求它返回的内容所经过的任何路径中，包括中间的一些 HTTP 代理服务器以及发出请求的客户端浏览器，都可以进行对返回内容的缓存操作</li></ul>`,51),o={href:"https://juejin.cn/post/6844903751493369870",target:"_blank",rel:"noopener noreferrer"},c={href:"https://zhuanlan.zhihu.com/p/79042406",target:"_blank",rel:"noopener noreferrer"},u=r('<h4 id="_5-2-3-关于-expires" tabindex="-1"><a class="header-anchor" href="#_5-2-3-关于-expires" aria-hidden="true">#</a> 5.2.3 关于 Expires</h4><ul><li>同在 Respinse Headers 中</li><li>同为控制缓存过期</li><li>已被 Cache-Control 代替</li></ul><h3 id="_5-3-协商缓存-对比缓存" tabindex="-1"><a class="header-anchor" href="#_5-3-协商缓存-对比缓存" aria-hidden="true">#</a> 5.3 协商缓存（对比缓存）</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d9460548b8248a0aad44849eb494156~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><ul><li>服务端缓存策略</li><li>服务端来达判断客户端资源，是否和服务端资源一样</li><li>判断一致则返回 304，否则返回 200 和最新的资源</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae7feab903074999947f862ce9083bfb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190da8bab7b54585bbe1bac5722e18f4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="_5-3-1-资源标识" tabindex="-1"><a class="header-anchor" href="#_5-3-1-资源标识" aria-hidden="true">#</a> 5.3.1 资源标识</h4><ul><li>在 <code>Response Headers</code> 中，有两种</li><li><code>Last-Modofied</code> 资源的最后修改时间</li><li><code>Etag</code> 资源的唯一标识（一个字符串，类似人类的指纹）</li><li><code>Last-Modified</code> 是 HTTP 1.0 的字段，而 <code>Etag</code> 是 HTTP 1.1 的字段</li></ul><h4 id="_5-3-2-http-1-0-last-modified" tabindex="-1"><a class="header-anchor" href="#_5-3-2-http-1-0-last-modified" aria-hidden="true">#</a> 5.3.2 http 1.0: last-modified</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/250bdae9421f4a238f8300e8042a7ce7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h4 id="_5-3-3-http-1-1-etag" tabindex="-1"><a class="header-anchor" href="#_5-3-3-http-1-1-etag" aria-hidden="true">#</a> 5.3.3 http 1.1: Etag</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099ff22bbcb141a5b48301a319c516a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h4 id="_5-3-4-last-modified-和-etag-共存时" tabindex="-1"><a class="header-anchor" href="#_5-3-4-last-modified-和-etag-共存时" aria-hidden="true">#</a> 5.3.4 <code>Last-Modified</code> 和 <code>Etag</code> 共存时</h4><ul><li>会优先使用 Etag</li><li>Last-Modified 只能精确到秒级</li><li>如果资源被重复生成，但是内容不变，则 <code>Etag</code> 更精确</li></ul><h3 id="_5-4-http-缓存流程图" tabindex="-1"><a class="header-anchor" href="#_5-4-http-缓存流程图" aria-hidden="true">#</a> 5.4 http 缓存流程图</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81MjQyMTI1LWQ1YTUxYTI0ZjlkNjlkMGQucG5n?x-oss-process=image/format,png" alt=" http缓存流程"><h3 id="_5-5-刷新操作方式-对缓存的影响" tabindex="-1"><a class="header-anchor" href="#_5-5-刷新操作方式-对缓存的影响" aria-hidden="true">#</a> 5.5 刷新操作方式，对缓存的影响</h3><table><thead><tr><th>操作方式</th><th>场景</th><th>强制缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>正常操作</td><td>地址栏输入 url, 跳转链接，前进后退等</td><td>有效</td><td>有效</td></tr><tr><td>手动刷新</td><td>F5，点击刷新按钮，右击菜单刷新</td><td>失效</td><td>有效</td></tr><tr><td>强制刷新</td><td>shift + F5</td><td>失效</td><td>失效</td></tr></tbody></table><h3 id="http-缓存-相关阅读" tabindex="-1"><a class="header-anchor" href="#http-缓存-相关阅读" aria-hidden="true">#</a> http 缓存-相关阅读</h3>',20),f={href:"https://juejin.cn/post/6844903838768431118",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/express_yourself/article/details/107230954",target:"_blank",rel:"noopener noreferrer"},_={href:"https://segmentfault.com/a/1190000021661656",target:"_blank",rel:"noopener noreferrer"},m={href:"https://juejin.cn/post/7051552782486077471",target:"_blank",rel:"noopener noreferrer"},g=r('<h2 id="_6-get-与-post-的区别" tabindex="-1"><a class="header-anchor" href="#_6-get-与-post-的区别" aria-hidden="true">#</a> 6. GET 与 POST 的区别</h2><ul><li><p>GET 用于获取资源,是无副作用的，是幂等的，且可缓存，POST 用于提交资源,有副作用，非幂等，不可缓存</p></li><li><p>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置</p></li><li><p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</p></li><li><p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留</p></li><li><p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制</p></li><li><p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</p></li><li><p>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</p></li><li><p>GET 参数通过 URL 传递，POST 放在 Request body 中</p></li><li><p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包 (注意，此话不准确)</p><ul><li>有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</li></ul><p>作者：小辣椒高效 Office 链接：https://www.zhihu.com/question/48725585/answer/2689830949 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></li><li><p>GET 参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留</p></li><li><p>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</p></li></ul><h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><h3 id="_1-http-常见的状态码有哪些" tabindex="-1"><a class="header-anchor" href="#_1-http-常见的状态码有哪些" aria-hidden="true">#</a> 1. http 常见的状态码有哪些？</h3><p><a href="#_1-%E7%8A%B6%E6%80%81%E7%A0%81">点击跳转 状态码</a></p><h3 id="_2-http-常见的-header-有哪些" tabindex="-1"><a class="header-anchor" href="#_2-http-常见的-header-有哪些" aria-hidden="true">#</a> 2. http 常见的 header 有哪些</h3><p><a href="#_3-http-headers">点击跳转 http headers</a></p><h3 id="_3-什么是-restful-api" tabindex="-1"><a class="header-anchor" href="#_3-什么是-restful-api" aria-hidden="true">#</a> 3. 什么是 Restful API</h3><p><a href="#_2-http-methods">首先说出 Http Methods</a></p><p><a href="#_3-restful-api">然后说出 Restful API</a></p><h3 id="_4-描述一下-http-的缓存机制-重要" tabindex="-1"><a class="header-anchor" href="#_4-描述一下-http-的缓存机制-重要" aria-hidden="true">#</a> 4. 描述一下 http 的缓存机制(重要)</h3><p><a href="#_5-http-%E7%BC%93%E5%AD%98">点击跳转 http 缓存</a></p>',12);function x(k,T){const a=h("ExternalLinkIcon");return d(),s("div",null,[p,e("p",null,[e("a",o,[t("Cache-Control 字段值详解"),i(a)])]),e("p",null,[e("a",c,[t("图文讲解 Cache-Control 浅显易懂"),i(a)])]),u,e("p",null,[e("a",f,[t("http 面试必会的：强制缓存和协商缓存:评论有用"),i(a)])]),e("p",null,[e("a",b,[t("http 缓存详解:多图"),i(a)])]),e("p",null,[e("a",_,[t("浏览器的强缓存和协商缓存"),i(a)])]),e("p",null,[e("a",m,[t("强烈推荐：一文彻底搞懂 http 缓存，图文解说+实战应用"),i(a)])]),g])}const v=l(n,[["render",x],["__file","http-01.html.vue"]]);export{v as default};
