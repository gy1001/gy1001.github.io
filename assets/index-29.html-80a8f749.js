import{_ as e,p as a,q as i,a1 as t}from"./framework-e8cb8151.js";const s="/assets/image-20230729135624327-7fd60d22.png",d="/assets/image-20230729135630220-658d7899.png",n="/assets/image-20230729135636123-9d9d4a49.png",p="/assets/image-20230729135643350-04de199a.png",c="/assets/image-20230729135653135-c0dca4ca.png",r="/assets/image-20230729135658026-b780e058.png",l="/assets/image-20230729135706798-155a3e58.png",o="/assets/image-20230729135715671-0ac89583.png",g="/assets/image-20230729135721721-265a7147.png",m="/assets/image-20230729135729661-3de7ae90.png",u="/assets/image-20230729135736999-3a83a98d.png",v="/assets/image-20230729135744546-32e9fd8f.png",b="/assets/image-20230729135751309-d9c13002.png",x="/assets/image-20230729135758126-82c092bb.png",h="/assets/image-20230729135806197-0d013197.png",_="/assets/image-20230729135813855-a4c34f91.png",G="/assets/image-20230729135825860-b2db0f61.png",f="/assets/image-20230729135840215-14d215a5.png",k={},q=t(`<h1 id="_29-历史记录清理-保留代码并删除一年前的提交记录" tabindex="-1"><a class="header-anchor" href="#_29-历史记录清理-保留代码并删除一年前的提交记录" aria-hidden="true">#</a> 29-历史记录清理：保留代码并删除一年前的提交记录</h1><p><img src="https://img1.mukewang.com/5dd1d3bb0001f64406400359.jpg" alt="img"></p><blockquote><p>今天应做的事没有做，明天再早也是耽误了。——裴斯泰洛齐</p></blockquote><p>Git 仓库使用久了之后会发现响应会越来越慢，占用的存储空间也会越来越大，出现这些问题的原因是因为 Git 会将我们代码的所有历史版本都会存储起来，当我们代码迭代了上千个版本之后就会占用很大的空间。</p><p>为了让 Git 的响应速度能够快点，我们可以通过一些方式减少 Git 仓库的存储空间，这一节当中主要教大家三种方式，分别是：克隆最后一个版本、清空版本记录、清理大文件等。</p><h2 id="_29-1-克隆最后一个版本" tabindex="-1"><a class="header-anchor" href="#_29-1-克隆最后一个版本" aria-hidden="true">#</a> 29.1 克隆最后一个版本</h2><p>我们在克隆一个使用了很久的 Git 仓库时候可能会发现耗费时间非常长，这是因为 Git 会拉取所有的历史版本导致，我们如果想让 Git 在克隆代码的时候快一些，可以在 <code>git clone</code> 命令行后面加 <code>--depth=1</code> 参数，这样 Git 在克隆代码时候只会克隆最后一个版本的内容，这里我执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://gitee.com/songboy/test201907.git  tempdemo --depth==1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 克隆返回的信息如下图所示：</p><p><img src="`+s+`" alt="image-20230729135624327"></p><p>在上图中可以看到克隆已经完成，而且我在等待克隆完成的这个时间也非常短，接着我进入 Git 仓库，看看里面的代码是否已经克隆下来，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cd tempdemo &amp;&amp; ls 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 仓库的文件如下图所示：</p><p><img src="`+d+`" alt="image-20230729135630220"></p><p>在上图中可以看到文件也都存在，我们再通过 <code>git log</code> 命令看看版本列表是否完整，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 版本列表如下图所示：</p><p><img src="`+n+`" alt="image-20230729135636123"></p><p>在上图中可以看到只有一个版本记录，说明 <code>--depth==1</code> 参数是可用的。</p><h2 id="_29-2-清空版本记录" tabindex="-1"><a class="header-anchor" href="#_29-2-清空版本记录" aria-hidden="true">#</a> 29.2 清空版本记录</h2><p>上面一个例子只能解决本地仓库的占用大小，但是服务端依然保存了所以的版本记录，如果想把远程的仓库也进行清理，可以看看下面的方法，首先我们切换到 <code>develop</code> 分支中，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> cd ../test201907  &amp;&amp; git checkout  develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+p+`" alt="image-20230729135643350"></p><p>在上图中可以看到已经切换到 <code>develop</code> 分支当中。</p><p>接着我们创建一个新分支，不过在创建的时候我们需要加上一个 <code>--orphan</code> 参数，加上这个参数之后创建的分支有点特殊，他只有最后一个版本，而不是把所有的版本都复制过来，严格来说创建出来的不是分支，但很像分支，执行的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git checkout --orphan new_branch
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+c+`" alt="image-20230729135653135"></p><p>在上图中可以看到已经创建了一个 <code>new_branch</code> 分支成功，接着我们将这个特殊的分支里面的文件都添加进来，执行的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git add -A  &amp;&amp; git status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 仓库的文件状态如下图所示：</p><p><img src="`+r+`" alt="image-20230729135658026"></p><p>在上图中可以看到所有的文件都处于待添加状态，我们将这些文件使用 <code>commit</code> 命令提交到一个版本当中去，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git commit -m &quot;new version&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+l+`" alt="image-20230729135706798"></p><p>在上图中可以看到提交成功，并生成了一个版本记录，接着我们将原来的 <code>develop</code> 分支删除，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git branch -D develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+o+`" alt="image-20230729135715671"></p><p>在上图中可以看到已经将 develop 分支删除成功，接着我们在将当前所在的 <code>new_branch</code> 分支改名为 <code>develop</code>，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git branch -m develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+g+`" alt="image-20230729135721721"></p><p>在上图中可以看到已经将分支改名成功，接着我们使用 <code>git push -f</code> 命令将本地仓库强制推送到远程仓库当中，这里需要注意：</p><blockquote><p>有些仓库有 master 分支保护，不允许强制 push，需要在远程仓库项目里暂时把项目保护关掉才能推送</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git push -f origin develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 远程仓库返回的信息如下图所示：</p><p><img src="`+m+`" alt="image-20230729135729661"></p><p>在上图中可以看到强制推送到远程的 <code>develop</code> 分支已经成功，此时我们已经将远程的历史版本记录给覆盖。</p><h2 id="_29-3-清理大文件" tabindex="-1"><a class="header-anchor" href="#_29-3-清理大文件" aria-hidden="true">#</a> 29.3 清理大文件</h2><p>上面一小节中，我们可以通过清理版本库来减少 Git 存储的空间，但有时候我们需要保留历史版本记录，但又想减少 Git 存储空间，这个时候我们就可以考虑清理一些大文件。</p><p>Git 本身也给我们提供了解决方案，使用 <code>git branch-filter</code> 可以遍历 Git 的版本历史信息，然后从历史版本信息中删除大文件，最终 Git 仓库空间减少，在下面的命令中会涉及到很多 Linux 命令，这些命令我们不用细究，按照步骤执行即可。</p><blockquote><p>演示出效果需要一个使用比较久，而且里面有大文件的仓库，这里我以我们公司的一个仓库为例来演示。</p></blockquote><p>现在需要找出大文件的对应 hash 值，这里我们找出前 5 个为例，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，过滤后的 Git 返回信息如下图所示：</p><p><img src="`+u+`" alt="image-20230729135736999"></p><p>在上图中，可以看到 5 行记录，其中第 3 列代表文件占用空间大小，我们随意挑选一个 hash 值为例，将这个值 <code>6ba572e5b6b9237a29bd883595e82f5a48e62a66</code> 复制到剪贴板，然后根据 hash 值找到对应大文件名，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git rev-list --objects --all | grep 6ba572e5b6b9237a29bd883595e82f5a48e62a66
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息过滤后如下图所示：</p><p><img src="`+v+`" alt="image-20230729135744546"></p><p>在上图中可以看到这个 hash 所对应的文件为 <code>vendor.zip</code> 文件，从文件名可以看出这是一个压缩包，我们要清除这个文件在所有历史中的记录，并强制刷新到所有分支，这里推送到远程仓库需要有强制推送权限。执行删除 <code>vendor.zip</code> 文件，在所有历史版本中的记录命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch vendor.zip&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+b+`" alt="image-20230729135751309"></p><p>在上图中可以看到当前仓库有 1584 个版本记录，已经全部删除完毕；在上面的命令中我们删除了文件，但是在 Git 的 repo 里面还记录了这些文件的信息，这些信息也会占用一定的空间，我们继续清除这些信息，并收回存储空间，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rm -rf .git/refs/original/  &amp;&amp; git reflog expire --expire=now --all
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+x+`" alt="image-20230729135758126"></p><p>在清除多余信息之后，我们需要重新建立文件与 Git 仓库的关联关系，执行命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git fsck --full --unreachable
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回信息如下图所示：</p><p><img src="`+h+`" alt="image-20230729135806197"></p><p>接着我们需要重新压缩代码，减少仓库体积：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git repack -A -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，如下图所示：</p><p><img src="`+_+`" alt="image-20230729135813855"></p><p>在上图中可以看到压缩任务已经执行完成，最后可以通过 Git 的 GC 清理一些垃圾数据，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git gc --aggressive --prune=now
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 仓库的文件状态如下图所示：</p><p><img src="`+G+`" alt="image-20230729135825860"></p><p>在上图中可以看到已经回收完成，总记录表有 38091 个对象，可用的只有 14563，其余的便被回收了，刚才这些操作都是在本地，我们如果想让远程仓库也清理，可以强制推送到远程仓库，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git push --force origin master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 仓库的文件状态如下图所示：</p><p><img src="`+f+'" alt="image-20230729135840215"></p><p>在上图中可以看到已经推送到远程仓库成功。</p><h2 id="_29-4-小结" tabindex="-1"><a class="header-anchor" href="#_29-4-小结" aria-hidden="true">#</a> 29.4 小结</h2><p>在这一节当中主要学习了如何让 Git 仓库廋身，以达到让 Git 响应速度变快的同时也减少占用仓库的空间。</p><p>导致 Git 仓库太大的原因，通常是因为有大文件和迭代版本次数过多导致，前者我们尽量不要把大文件放到存储空间中去，后者的话很难避免，不过我们可以定期清理版本记录。</p>',91),w=[q];function j(z,y){return a(),i("div",null,w)}const B=e(k,[["render",j],["__file","index-29.html.vue"]]);export{B as default};
