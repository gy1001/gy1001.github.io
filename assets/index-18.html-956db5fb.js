import{_ as o,M as c,p as i,q as t,R as n,t as e,N as r,a1 as a}from"./framework-e8cb8151.js";const d="/assets/5f45c0eb0001e5a406400426-cc58509e.jpg",l={},p=a('<h1 id="_18-docker-网络模式" tabindex="-1"><a class="header-anchor" href="#_18-docker-网络模式" aria-hidden="true">#</a> 18-Docker 网络模式</h1><p><img src="'+d+'" alt="img"></p><blockquote><p>机会不会上门来找人，只有人去找机会。——狄更斯</p></blockquote><h1 id="docker-网络模式" tabindex="-1"><a class="header-anchor" href="#docker-网络模式" aria-hidden="true">#</a> Docker 网络模式</h1><p>在上一篇文章我们介绍了 Docker 网络的工作模式，包括 docker0 网桥和 iptables 等。其中 docker0 网桥是 Docker 默认网络模式，也就是 bridge 模式。</p><h2 id="_1-概览" tabindex="-1"><a class="header-anchor" href="#_1-概览" aria-hidden="true">#</a> 1. 概览</h2><p>Docker 现在的网络模块是插件式的，只要按既定协议实现就可以使用。Docker 默认实现了五种网络模式如下（现在网络上面可以搜索到的文章都说 Docker 支持四种网络模式，其实是不准确的），我们可以在 <code>Docker run</code> 的时候通过参数 <code>--net</code> 指定。</p><h3 id="bridge-模式" tabindex="-1"><a class="header-anchor" href="#bridge-模式" aria-hidden="true">#</a> bridge 模式</h3><p>Docker 的默认网络模式。这种模式会将创建出来的所有 Docker 容器链接到 docker0 网桥或者自定义网桥上，所有的 Docker 容器处于同一个子网。</p><h3 id="host-模式" tabindex="-1"><a class="header-anchor" href="#host-模式" aria-hidden="true">#</a> <em><strong>host</strong></em> 模式</h3><p>顾名思义，这种模式下，Docker 容器和宿主机使用同一个网络协议栈，也就是同一个 network namespace，和宿主机共享网卡、IP、端口等信息。好处是性能更好，缺点也很明显，没有做网络隔离。</p><h3 id="overlay-模式" tabindex="-1"><a class="header-anchor" href="#overlay-模式" aria-hidden="true">#</a> <em><strong>overlay</strong></em> 模式</h3><p>这种模式在多个 Docker daemon 主机之间创建一个分布式网络，该网络位于 Docker 主机层次之上，允许容器之间加密通讯，需要处理容器之间和主机之间的网络包。</p><h3 id="macvlan-模式" tabindex="-1"><a class="header-anchor" href="#macvlan-模式" aria-hidden="true">#</a> <em><strong>macvlan</strong></em> 模式</h3><p>macvlan 是 Linux 的一个内核模块，算是一个比较新的特性。本质上是一种网卡虚拟化技术，通过 macvlan 可以在同一个物理网卡上虚拟出多个网卡，通过不同的 Mac 地址在数据链路层进行网络数据的转发，一块网卡上配置多个 Mac 地址。Docker 的 macvlan 网络实际上就是使用 Linux 提供的 macvlan 驱动。</p><h3 id="none-模式" tabindex="-1"><a class="header-anchor" href="#none-模式" aria-hidden="true">#</a> <em><strong>none</strong></em> 模式</h3><p>这种模式下 Docker 容器拥有自己的 network namespace，但是并不会做任何网络配置。换句话说，这个 Docker 容器除了 network namespace 自带的 lo 网卡（loopback，127.0.0.1）外没有其他任何网卡、IP 等信息。这种模式如果不做额外配置是无法使用的，要使用需要自己添加网卡等，也就是它给了用户最大的自由度。</p><h3 id="network-plugins" tabindex="-1"><a class="header-anchor" href="#network-plugins" aria-hidden="true">#</a> network plugins</h3>',18),u={href:"https://docs.docker.com/engine/extend/plugins_network/",target:"_blank",rel:"noopener noreferrer"},k=a(`<h2 id="_2-bridge-模式" tabindex="-1"><a class="header-anchor" href="#_2-bridge-模式" aria-hidden="true">#</a> 2. Bridge 模式</h2><p>虽然上一篇文章已经基于 bridge 模式做了分析，这里还是简单介绍一下 bridge 模式下，Docker 初始化容器网络的步骤：</p><ul><li>创建一对虚拟网卡（veth pair）。</li><li>赋予其中一块网卡类似 “vethxxx” 的名字，将其绑定到 docker0 或者自定义网桥，用来连接宿主机的 network namespace。</li><li>将 veth pair 的另一块网卡放入新创建的 Docker 容器的 network namespace 中，命名为 eth0。</li><li>从网桥的子网中选取一个未使用的 IP 分配给 eth0，并为 Docker 容器网络设置路由和网格。</li></ul><p>Docker 会自动创建 docker0 网桥，使用 bridge 模式的 Docker 容器默认使用 docker0 网桥，除此之外，你也可以使用自定义网桥（User-defined bridge network）。自定义网桥和默认 docker0 网桥的区别在于：</p><ul><li><p>自定义网桥提供容器间的自定义 DNS 解析。默认网桥网络下的 Docker 容器只能通过 IP 地址交互，除非使用 <code>--link</code> 参数将多个 Docker 容器连接起来。</p></li><li><p>自定义网桥具有更好的隔离性。默认创建的 Docker 容器如果没有指定 <code>--network</code> 参数，都会连接到默认的 docker0 网桥上，这样相当于将所有不不相干的容器都置于一个同一个网络环境中，可能存在风险。自定义网桥相当于将 docker0 网桥按我们需要分隔成多个自定义网桥，毫无疑问，这样隔离性更好。</p></li><li><p>容器可以在运行时和自定义网桥进行绑定或者解绑。这个默认 docker0 网桥是不行的，需要停止容器。</p></li><li><p>每个自定义网桥可以自定义自己的配置，比如 MTU 和 iptables 规则等。但是如果使用默认 docker0 网桥，相当于共享配置。</p></li><li><p>通过默认网桥 Link 的 Docker 容器可以共享环境变量。所谓 Link 是指</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的时候指定</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>--link
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数。这个在自定义网桥中是不行的，但是可以通过其他方式来实现，比如：</p><ul><li>将需要共享的数据放到 volume 中，多个 Docker 容器自行 mount。</li><li>使用 <code>docker-compose</code> 启动多个 Docker 容器，将共享变量定义到 compose 文件中。</li></ul></li></ul><h2 id="_3-host-模式" tabindex="-1"><a class="header-anchor" href="#_3-host-模式" aria-hidden="true">#</a> 3. Host 模式</h2><p>Host 模式可以通过参数 <code>--network host</code> 指定，比如我们使用 host 模式启动一个 nginx 容器。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm -d --network host --name host_nginx nginx</span>
38a4b19971e5f503dc902ba070d4dec270f0737197e574f50eb9dff253c56129
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Nginx 进程会使用 80 端口，那么我们看一下刚才启动 nginx 容器有没有占用宿主机的 80 端口。首先我们要获取到容器对应的宿主机上面的进程 pid，使用命令 <code>docker top</code> 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker ps | grep host_nginx</span>
38a4b19971e5        nginx               <span class="token string">&quot;nginx -g &#39;daemon of…&quot;</span>   <span class="token number">3</span> minutes ago       Up <span class="token number">3</span> minutes                                 host_nginx
<span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker top 38a4b19971e5</span>
<span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMD
root                <span class="token number">28480</span>               <span class="token number">28460</span>               <span class="token number">0</span>                   <span class="token number">20</span>:29               ?                   00:00:00            nginx: master process nginx <span class="token parameter variable">-g</span> daemon off<span class="token punctuation">;</span>
<span class="token number">101</span>                 <span class="token number">28506</span>               <span class="token number">28480</span>               <span class="token number">0</span>                   <span class="token number">20</span>:29               ?                   00:00:00            nginx: worker process
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出表示 nginx 的 Docker 容器启动了两个进程 nginx master 和 nginx worker，分别对应到宿主机的 28480 和 28506 号进程。然后我们通过 <code>netstat</code> 命令查看 nginx master 进程有没有占用宿主机的 80 端口。答案很明显是的。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># netstat -anlp | grep 28480</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:80              <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">28480</span>/nginx: master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Host 模式的优缺点都很明显。</p><ul><li><strong>缺点</strong>：没有和宿主机的 network namespace 进行隔离。可能会存在端口冲突的情况，比如 nginx 镜像的 Docker 容器会使用 80 端口，那么我们就不能以 host 模式启动两个容器，不然会冲突。</li><li><strong>优点</strong>：共用同一个 network namespace 也就意味没有个多个 network namespace 之间的数据转发，性能更好。</li></ul><h2 id="_4-none-模式" tabindex="-1"><a class="header-anchor" href="#_4-none-模式" aria-hidden="true">#</a> 4. none 模式</h2><p>None 模式就是禁止 Docker 容器的网络，没啥可以多说的，我们还是以一个实际的例子来好了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm -ti --network none --name none-net-busybox busybox:latest sh</span>
/ <span class="token comment"># ifconfig</span>
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们首先通过 <code>--network none</code> 参数启动一个 none 模式的 busybox 容器，然后在容器中通过 ifconfig 查看发现只有一个 loopback 网卡，这也就意味这个 Docker 容器是不可访问的，也就是 none 模式的含义。</p><h2 id="_5-overlay-macvlan" tabindex="-1"><a class="header-anchor" href="#_5-overlay-macvlan" aria-hidden="true">#</a> 5. overlay &amp;&amp; macvlan</h2><p>Overlay 和 Macvlan 模式我们这里就不做过多介绍了，Overlay 模式网络我们后面在 Kubernetes 网络相关内容再介绍，毕竟现在的跨主机的 Docker 容器部署基本都是通过 Kubernetes 来部署的。</p>`,20),m={href:"https://docs.docker.com/network/macvlan/",target:"_blank",rel:"noopener noreferrer"},h=a('<h2 id="_6-最佳实践" tabindex="-1"><a class="header-anchor" href="#_6-最佳实践" aria-hidden="true">#</a> 6. 最佳实践</h2><p>官方给了一个针对各个网络模式的选择使用建议：</p><ul><li><em><strong>User-defined bridge network</strong></em> 适用于同一个宿主机上多个 Docker 容器进行通信。这里的 <em><strong>user-defined</strong></em> 可以理解为自定义网桥，不适用 docker0 网桥，这样可以更灵活地设置子网和 iptables。</li><li><em><strong>Host networks</strong></em> 适用于 Docker 容器的网络不需要和宿主机进行隔离的场景，比如对于网络性能比较敏感的场景。</li><li><em><strong>Overlay networks</strong></em> 适用于运行在多个宿主机上 Docker 容器之间的通信情况。</li><li><em><strong>Macvlan networks</strong></em> 适用于 VM 迁移的场景，这样每个 Docker 容器看起来和物理主机一样。</li><li><em><strong>Third-party network plugins</strong></em> 适用于将 Docker 和特定网络协议栈整合的场景。</li></ul><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结" aria-hidden="true">#</a> 7. 总结</h2><p>本篇文章介绍了 Docker 支持的集中网络模式，并重点介绍了最常用的 bridge 和 host 模式。由于篇幅有限，macvlan 和 第三方的 network plugin 没有做介绍，感兴趣的同学可以自行查阅。</p>',5);function b(v,g){const s=c("ExternalLinkIcon");return i(),t("div",null,[p,n("p",null,[e("除了上面默认实现的五种网络模式，你还可以使用第三方的网络插件。这部分需要较多篇幅，本篇文章暂时不介绍了。感兴趣的同学可以参考"),n("a",u,[e("这篇"),r(s)]),e("文章。")]),k,n("p",null,[e("Macvlan 相当于是处理 VM 迁移到 Docker 容器的历史遗留问题使用的方式，大部分人应该都应用不到，这里不做过多介绍。感兴趣的同学可以参考"),n("a",m,[e("这里"),r(s)]),e("。")]),h])}const _=o(l,[["render",b],["__file","index-18.html.vue"]]);export{_ as default};
