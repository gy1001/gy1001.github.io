import{_ as n,p as s,q as a,a1 as e}from"./framework-e8cb8151.js";const p="/assets/1-20240301171257295-33227ba3.png",t="/assets/1-20240301171257202-f7c5c804.png",o="/assets/1-20240301171257335-7bf563af.png",c="/assets/1-20240301171257183-55318b5a.png",i="/assets/1-20240301171257280-f21d019d.png",r={},l=e('<h1 id="_31-原型与原型链" tabindex="-1"><a class="header-anchor" href="#_31-原型与原型链" aria-hidden="true">#</a> 31-原型与原型链</h1><p>在对实例的封装中，我们将所有实例共享的方法抽离出来，挂载在一个对象里，这个对象就是<strong>原型对象</strong>。</p><h2 id="_01-原型" tabindex="-1"><a class="header-anchor" href="#_01-原型" aria-hidden="true">#</a> 01-原型</h2><p>构造函数中，使用 <code>prototype</code> 指向原型对象。 实例对象中，使用 <code>__proto__</code> 指向原型对象。 原型对象中，使用 <code>constructor</code> 指向构造函数。</p><p>他们的关系如下图。</p><p><img src="'+p+`" alt="img"></p><p>从图中很自然能够得出如下的结论</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token comment">// Object.getPrototypeOf 能够获取实例的原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_02-原型链" tabindex="-1"><a class="header-anchor" href="#_02-原型链" aria-hidden="true">#</a> 02-原型链</h2><p>在上例中，Person 的原型对象也是一个对象。因此，原型对象也是别人的实例。可以观察一下<img src="`+t+'" alt="img">我们会发现，Person 的原型对象中，也有一个 <code>__proto__</code> 属性，用于指向自己的原型对象。而该原型对象的构造函数， <code>constructor</code> 指向 Object()。</p><p>我们可以完善上图</p><p><img src="'+o+`" alt="img"></p><p>对于实例对象 p1 而言，它的原型对象为 <code>p1.__proto__</code> 对于 p1 的原型对象而言，它的原型对象为 <code>p1.__proto__.__proto__</code></p><p>此时我们发现，一个单向的链表模型存在于对象的关联关系中，这就是<strong>原型链。</strong></p><p>现在有如下代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，并没有往实例对象 p 的原型对象中，添加任何方法。我们观察一下，p 能访问哪些方法。</p><p><img src="`+c+'" alt="img"></p><p>很神奇的是，实例对象 p 居然能够访问这么多方法/属性，name 属性来自构造函数，constructor 与 <code>__proto__</code> 属性来自原型对象，其他的属性来自哪里呢？进一步观察</p><p><img src="'+i+`" alt="img"></p><p>我们发现其他的属性来自于 Object 的原型对象。也就是说，<strong>实例对象能够访问原型链中的正方向节点中的每一个属性与方法。</strong></p><p>例如</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// p 对象中并没有 constructor 属性，但是能够从其原型对象中找到，所以</span>
p<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,23),u=[l];function d(k,m){return s(),a("div",null,u)}const v=n(r,[["render",d],["__file","index-31.html.vue"]]);export{v as default};
