import{_ as s,p as n,q as a,a1 as e}from"./framework-e8cb8151.js";const l="/assets/5f16817000017b5706400426-104889f4.jpg",o={},i=e('<h1 id="_21-数据共享volume-的使用指南" tabindex="-1"><a class="header-anchor" href="#_21-数据共享volume-的使用指南" aria-hidden="true">#</a> 21-数据共享volume 的使用指南</h1><p><img src="'+l+`" alt="img"></p><blockquote><p>人不可有傲气，但不可无傲骨。——徐悲鸿</p></blockquote><p>在上一篇文章中，我们介绍了 Docker 数据存储的三种模式：<em><strong>volume</strong></em>，<em><strong>bind mounts</strong></em>，<em><strong>tmpfs</strong></em>。主要还是偏理论部门，这篇文章我们就来看一下 volume 的典型使用场景。</p><h2 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h2><p>我们知道 Docker 的镜像是由多个只读层组合而成的，运行的容器在这些只读层之上加入一个读写层。这种设计主要提高了镜像构建、存储和分发的效率，但是这种设计带来了一些使用上的不便：</p><ul><li>容器中的文件存储在宿主机上面形式复杂，不能在宿主机上方便地访问和修改。</li><li>容器运行过程中的数据都存储在读写层，也就意味着容器停止之后，这些数据都将丢失。</li><li>容器之间的数据无法直接共享使用。</li></ul><p>volume 正是诞生于这个背景下。volume 存在于一个或多个容器中的特定文件或者文件夹，这个目录能够以联合文件系统的形式在宿主机中存在，并未数据的共享和持久化提供一下便利，包括：</p><ul><li>volume 在容器创建时会自动初始化，容器运行起来就可以直接使用。当然你也可以自己先创建 volume。</li><li>volume 可以在不同容器之间共享和重用。</li><li>对 volume 中数据的操作会立刻生效。</li><li>对 volume 中数据的操作不会影响到镜像本身。</li><li>volume 的生命周期独立于容器的生命周期，也就是说即使删除容器，volume 依然可以使用。</li></ul><p>下面我们重点介绍一下 volume 的几种典型使用场景。</p><h2 id="_2-先创建-volume" tabindex="-1"><a class="header-anchor" href="#_2-先创建-volume" aria-hidden="true">#</a> 2. 先创建 volume</h2><p>我们可以通过命令 <code>docker volume create</code> 创建 volume。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker volume create myvol2</span>
myvol2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的命令就是创建一个名字叫 <em><strong>my-vol</strong></em> 的 volume。创建完之后，这个 volume 的数据会被存储在 <code>/var/lib/docker/volumes/myvol2/</code> 。其实这个目录 <code>/var/lib/docker/volumes/</code> 下面会保存所有 volume，如果 volume 没有名字，则 volume 对应的是一个长字符串，下面是我的 Docker 宿主机上面的 volumes 列表。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># ls /var/lib/docker/volumes/</span>
0d677566872e112e6792b7dd1e71f4b5c26fec701de4d43fe401fd1d5bd93afd/
12a0226aff0e607425bd2f8ed6544154ec276feda24dee39255e377b978d4014/
22340dc6d144f4f4be30c93afc1186734f8559acb20aeeb861fa929d4c26e30b/
9bfb60bba113c35ab3c973edde821c493ec1b79a6a561d3eb6ca47105b12fba9/
a074cf769c98c44395e8ba9b11f473ccb296ccfef4a8b4de8d3d56632a4bb562/
a7fe694cc0abea99d1e455e31d25a49a523e4ff661f4172d48e3b61ccd00c2c0/
b769fe6cc2c9368299aea8d0a16ebd2911d1a15752d0c8e91706afe2974f70f8/
b801cc75e3485b5d90ed59cc38eeb86d96401c2698fb8598f73969c92fba4e48/
metadata.db
my-vol/
myvol2/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建完 volume 之后，我们就可以按需使用创建出来 volume，使用参数 <code>-v</code> 或者 <code>--mount</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> devtest <span class="token punctuation">\\</span>
  <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>myvol2,target<span class="token operator">=</span>/app <span class="token punctuation">\\</span>
  nginx:latest
$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> devtest <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> myvol2:/app <span class="token punctuation">\\</span>
  nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>容器启动之后，我们就可以通过命令 <code>docker inspect</code> 去查看容器中的 volume 信息如下，我们可以看到其中的 Source 字段即为 volume 在宿主机的目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;Mounts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">&quot;Type&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;volume&quot;</span>,
        <span class="token string">&quot;Name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;myvol2&quot;</span>,
        <span class="token string">&quot;Source&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/var/lib/docker/volumes/myvol2/_data&quot;</span>,
        <span class="token string">&quot;Destination&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/app&quot;</span>,
        <span class="token string">&quot;Driver&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;local&quot;</span>,
        <span class="token string">&quot;Mode&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;z&quot;</span>,
        <span class="token string">&quot;RW&quot;</span><span class="token builtin class-name">:</span> true,
        <span class="token string">&quot;Propagation&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-容器启动添加-volume" tabindex="-1"><a class="header-anchor" href="#_3-容器启动添加-volume" aria-hidden="true">#</a> 3. 容器启动添加 volume</h2><p>第一种使用方式比较简单，直接在创建容器的时候用 <code>-v</code> 的参数（或者使用 <code>--mount</code> 参数）创建一个 volume，这时候会创建出来一个匿名的 volume，也就是上一小节的那一串字符串。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm -it -v /data busybox sh</span>
/ <span class="token comment"># ls /</span>
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们使用 <code>docker inspect</code> 查看启动的容器的 volume 相关信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;Mounts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">&quot;Type&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;volume&quot;</span>,
        <span class="token string">&quot;Name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;41553e5efcc2ebce3e1ce35df0afa4e0a6b456a2583d2990184e32a2da525c65&quot;</span>,
        <span class="token string">&quot;Source&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/var/lib/docker/volumes/41553e5efcc2ebce3e1ce35df0afa4e0a6b456a2583d2990184e32a2da525c65/_data&quot;</span>,
        <span class="token string">&quot;Destination&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/data&quot;</span>,
        <span class="token string">&quot;Driver&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;local&quot;</span>,
        <span class="token string">&quot;Mode&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
        <span class="token string">&quot;RW&quot;</span><span class="token builtin class-name">:</span> true,
        <span class="token string">&quot;Propagation&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-从宿主机挂载" tabindex="-1"><a class="header-anchor" href="#_4-从宿主机挂载" aria-hidden="true">#</a> 4. 从宿主机挂载</h2><p>从宿主机挂载的应用场景是我们有时候想要将宿主机的文件共享到容器中，但是有不想停止容器，那么我们就可以通过这种方式来实现。使用方式是 <code>-v</code> 参数，格式为 <code>-v /host/dir:/container/dir</code> 。下面我们演示一下，首先我们在宿主机上面找到一个目录 <code>/root/demo</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment"># ls</span>
hello.py  __pycache__  webapp.py  webapp.pyc
<span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment"># pwd</span>
/root/demo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动容器。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment"># docker run -it -v /root/demo:/demo busybox sh</span>
/ <span class="token comment"># ls /demo</span>
__pycache__  hello.py     webapp.py    webapp.pyc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出我们可以看到宿主机的目录以及映射到容器内部了。我们可以在宿主机上面的目录做一点改动，然后看一下对应的容器目录有没有同步改动。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment"># touch 123</span>
<span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment"># ls</span>
<span class="token number">123</span>  hello.py  __pycache__  webapp.py  webapp.pyc
<span class="token punctuation">[</span>root@docker demo<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是容器内部对应的目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/ <span class="token comment"># ls /demo</span>
<span class="token number">123</span>          __pycache__  hello.py     webapp.py    webapp.pyc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-使用-dockerfile-添加-volume" tabindex="-1"><a class="header-anchor" href="#_5-使用-dockerfile-添加-volume" aria-hidden="true">#</a> 5. 使用 Dockerfile 添加 volume</h2><p>在 dockerfile 的语法中可以通过 <code>VOLUME</code> 创建一个 volume 或者多个 volume。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment">#创建一个 volume</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /data</span>
<span class="token comment"># 创建多个 volume</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> [<span class="token string">&quot;/data1&quot;</span>, <span class="token string">&quot;/data2&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建 volume 之后，Docker 会在容器启动时挂载一个 volume 到挂载点 <code>/data</code> 。如果镜像中存在目录 <code>/data</code> ，则这个文件夹中的文件都将全部被复制到宿主机中 volume 对应的文件夹中，一般位于目录 <code>/var/lib/docker/volumes/</code>。</p><p>我们下面演示一下通过 busybox 作为 base 镜像构建自己的镜像，并创建一个 volume。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> busybox:latest</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /data</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>docker build</code> 基于此 Dockerfile 构建新的镜像。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker dockerfile2<span class="token punctuation">]</span><span class="token comment"># docker build -t volume-image:v1 .</span>
Sending build context to Docker daemon   <span class="token number">5</span>.12kB
Step <span class="token number">1</span>/2 <span class="token builtin class-name">:</span> FROM busybox:latest
 ---<span class="token operator">&gt;</span> 6d5fcfe5ff17
Step <span class="token number">2</span>/2 <span class="token builtin class-name">:</span> VOLUME /data
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> c74eeadfbf3f
Removing intermediate container c74eeadfbf3f
 ---<span class="token operator">&gt;</span> 71d5c091d1c0
Successfully built 71d5c091d1c0
Successfully tagged volume-image:v1
<span class="token punctuation">[</span>root@docker dockerfile2<span class="token punctuation">]</span><span class="token comment"># docker images | grep volume-image</span>
volume-image        v1                  71d5c091d1c0        <span class="token number">13</span> seconds ago      <span class="token number">1</span>.22MB
<span class="token punctuation">[</span>root@docker dockerfile2<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动容器，然后我们可以发现在根目录确实多了一个 /data 目录，这个挂载点挂载的就是我们新建的 volume。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker dockerfile2<span class="token punctuation">]</span><span class="token comment"># docker run -ti volume-image:v1 sh</span>
/ <span class="token comment"># ls /</span>
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
/ <span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以通过 <code>docker inspect &lt;containerId&gt;</code> 来查看其中的 volume 信息。其中的 Source 就是 volume 所在宿主机的位置 <code>/var/lib/docker/volumes/</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">..</span>.
<span class="token string">&quot;Mounts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">&quot;Type&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;volume&quot;</span>,
        <span class="token string">&quot;Name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;b769fe6cc2c9368299aea8d0a16ebd2911d1a15752d0c8e91706afe2974f70f8&quot;</span>,
        <span class="token string">&quot;Source&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/var/lib/docker/volumes/b769fe6cc2c9368299aea8d0a16ebd2911d1a15752d0c8e91706afe2974f70f8/_data&quot;</span>,
        <span class="token string">&quot;Destination&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/data&quot;</span>,
        <span class="token string">&quot;Driver&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;local&quot;</span>,
        <span class="token string">&quot;Mode&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
        <span class="token string">&quot;RW&quot;</span><span class="token builtin class-name">:</span> true,
        <span class="token string">&quot;Propagation&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Dockerfile 中使用 volume 有一点需要注意的是，由于 volume 只有在容器创建的时候才会挂载进来，所以如果我们在 Dockerfile 中尝试将 volume 作为一个目录并做一下操作，这个是不会生效的，原因就是在当前镜像中这个文件夹还不存在。比如如下的操作：</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">VOLUME</span> /data</span>
<span class="token instruction"><span class="token keyword">RUN</span> touch /data/file</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>正确做法是先创建该目录，执行我们需要的操作，最后添加 volume。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">RUN</span> mkdir /data</span>
<span class="token instruction"><span class="token keyword">RUN</span> touch /data/file</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /data</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-volume-共享" tabindex="-1"><a class="header-anchor" href="#_6-volume-共享" aria-hidden="true">#</a> 6. volume 共享</h2><p>volume 共享可以通过参数 <code>--volumes-from</code> 实现。我们在上面启动了一个带有 volume 的容器，我们下面启动一个新的容器共享之前的 volume。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker ps | grep volume-image:v1</span>
12be76fd253e        volume-image:v1     <span class="token string">&quot;sh&quot;</span>                     <span class="token number">20</span> minutes ago      Up <span class="token number">20</span> minutes                                modest_lumiere
<span class="token punctuation">[</span>root@docker ~<span class="token punctuation">]</span><span class="token comment"># docker run -ti --volumes-from modest_lumiere busybox:latest sh</span>
/ <span class="token comment"># ls</span>
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
/ <span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出，我们可以看到新创建出来的 Docker 容器也有了目录 <code>/data</code> ，但是和之前的容器中的 volume 是不是同一个呢？我在之前启动的容器中的 <code>/data</code> 目录下创建一个临时文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/data <span class="token comment"># touch 1</span>
/data <span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们在新的 Docker 容器中检查一下该目录下的文件内容。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/ <span class="token comment"># ls /data</span>
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然你可以通过 <code>docker inspect</code> 查看这两个 Docker 容器中的 Mount 中的 volume 信息是不是相同即可。</p><p>我们上面的例子中是共享了一个 volume，这里有一个小问题，如果第一个容器中使用了多个 volume，那个通过 <code>--volumes-from</code> 共享过来的是不是所有的 volume 呢？答案是肯定的。那么如果要共享其中一个，可以做到吗？通过容器间共享的方式确实是做不到的，我们可以通过手动创建多个 volume，各个容器使用的按需挂载。</p><h2 id="_7-volume-备份与迁移" tabindex="-1"><a class="header-anchor" href="#_7-volume-备份与迁移" aria-hidden="true">#</a> 7. volume 备份与迁移</h2><p>我们现在知道了 volume 的数据的存储位置：</p><ul><li>容器内的指定挂载点</li><li>宿主机的 <code>/var/lib/docker/volumes</code></li></ul><p>这两者的关联可以通过 <code>docker inspcet</code> 来查看，那么我们备份的话是备份那部分数据呢？其实都可以。官方建议备份容器内的指定挂载点的数据，好处是可以通过自动化或者说程序化的方式来备份，也就是下面的命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> --volumes-from dbstore <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/backup busybox <span class="token function">tar</span> cvf /backup/backup.tar /data
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这行命令有以下几个作用：</p><ol><li>启动一个工具容器 busybox，和目标容器共享 volume</li><li>将宿主机的当前目录和容器的目录 <code>/backup</code> 做映射</li><li>将共享的 volume 的挂载点的数据压缩拷贝到容器内部的目录 <code>/backup</code></li></ol><p>这样通过三步操作就将原容器中的 volume 数据备份到宿主机上了。对应的我们可以通过下面的命令将备份的数据进行恢复，这里就不再解释了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> --volumes-from dbstore2 <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/backup ubuntu <span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">&quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_8-总结" tabindex="-1"><a class="header-anchor" href="#_8-总结" aria-hidden="true">#</a> 8. 总结</h2><p>Volume 是 Docker 中非常有用的技术，它提供了一种将数据和镜像容器解耦的方式。本文介绍了 volume 的六种使用方式：</p><ul><li>先创建 volume；</li><li>容器启动添加 volume；</li><li>从宿主机挂载；</li><li>在 Dockerfile 中使用 volume；</li><li>volume 共享；</li><li>volume 数据迁移和备份。</li></ul><p>希望各位同学可以按自己的场景选择合适的使用方式。</p>`,71),c=[i];function t(d,p){return n(),a("div",null,c)}const r=s(o,[["render",t],["__file","index-21.html.vue"]]);export{r as default};
