import{_ as e,M as o,p as c,q as i,R as n,t as s,N as t,a1 as a}from"./framework-e8cb8151.js";const l="/assets/image-20230809221525323-f9a04e31.png",u="/assets/image-20230809222015760-6dcc712a.png",r="/assets/image-20230809222825822-18992f20.png",d="/assets/image-20230809223054059-ed221319.png",k="/assets/image-20230809225857488-7d2aee39.png",m={},b=a('<h1 id="_04-代码优化-快来看看怎样写出真正高性能的代码" tabindex="-1"><a class="header-anchor" href="#_04-代码优化-快来看看怎样写出真正高性能的代码" aria-hidden="true">#</a> 04-代码优化 (快来看看怎样写出真正高性能的代码)</h1><h2 id="_01-js-开销和如何缩短解析时间【为什么我的-js-运行慢】" tabindex="-1"><a class="header-anchor" href="#_01-js-开销和如何缩短解析时间【为什么我的-js-运行慢】" aria-hidden="true">#</a> 01:JS 开销和如何缩短解析时间【为什么我的 JS 运行慢】</h2><h3 id="开销在哪里" tabindex="-1"><a class="header-anchor" href="#开销在哪里" aria-hidden="true">#</a> 开销在哪里</h3><ul><li>加载</li><li>解析 &amp; 编译</li><li>执行</li></ul><blockquote><p>如下如，对于同样大小的 图片和 js 文件，网络传输耗时一样，资源加载耗时就不一致了，对于 js 文件 花费了 2s 左右的解析编译，又花费了 1.5 的执行时间，而对于图片下载完成后，直接在 0.064s 内完成了图片编码，又花费了 0.028s 的绘制</p></blockquote><p><img src="'+l+'" alt="image-20230809221525323"></p><p>对于 Reddit.com 下图可以看出，对于 js 代码还是压缩后的，花费了 1/3 左右的时间</p><p><img src="'+u+'" alt="image-20230809222015760"></p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ul><li>Code splitting 代码拆分，按需加载</li><li>Tree shaking 代码减重</li></ul><h3 id="减少主线程工作量" tabindex="-1"><a class="header-anchor" href="#减少主线程工作量" aria-hidden="true">#</a> 减少主线程工作量</h3><ul><li>避免长任务</li><li>避免超过 1kb 的行间脚本</li><li>使用 rAf 和 rIc 进行时间调度</li></ul><h3 id="progressive-bootstrapping" tabindex="-1"><a class="header-anchor" href="#progressive-bootstrapping" aria-hidden="true">#</a> Progressive Bootstrapping</h3><ul><li>可见不可交互 vs 最小可交互资源集</li></ul><p><img src="'+r+'" alt="image-20230809222825822"></p><h2 id="_02-配合-v8-有效优化代码【路走对了才能快】" tabindex="-1"><a class="header-anchor" href="#_02-配合-v8-有效优化代码【路走对了才能快】" aria-hidden="true">#</a> 02: 配合 V8 有效优化代码【路走对了才能快】</h2><h3 id="v8-编译原理" tabindex="-1"><a class="header-anchor" href="#v8-编译原理" aria-hidden="true">#</a> V8 编译原理</h3><blockquote><p>js -&gt; Parse it -&gt; AST(Abstract Syntax Tree) 抽象语法树 -&gt; Interpreter （解释器理解抽象语法树）-&gt; Optimising Compiler（编译器优化）[1]-&gt; machine Code -&gt; Bytecode</p></blockquote><blockquote><p>拿到你的 js 字符，解析处理，变为抽象语法树 AST，所有的编程语言都有这样一个过程。先把你的文本，识别成字符，然后把里面重要的信息提取出来，变为一些节点，存储在一定的数据结构里。然后在这个数据结构里，进行理解解释是什么意义。这就是接下来，解释器要做的事情。然后呢，再把我们的代码变为机器码去运行之前，这个编译器会进行一些优化工作，也就是 Optimising Compiler. 当然，他做的优化工作不一定合适，如果它发现不合适，这时会发生一个逆优化过程。这样就造成一些不必要的开销，所以我们要注意的就是按照他优化的方式、按照它期望的方式，并且回顾可能让他出现逆优化的过程的方式，进行书写代码。</p></blockquote><p><img src="'+d+`" alt="image-20230809223054059"></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// node.js</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> performance<span class="token punctuation">,</span> PerformanceObserver <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;perf_hooks&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b

<span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token number">2</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">&#39;start&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> <span class="token string">&#39;s&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 这里注意：类型发生变化！类型发生变化！类型发生变化！</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">&#39;end&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">entryTypes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;measure&#39;</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
performance<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token string">&#39;测量1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;start&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;end&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>类型发生变化时 运行耗时</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PerformanceMeasure <span class="token punctuation">{</span>
  name: <span class="token string">&#39;测量1&#39;</span>,
  entryType: <span class="token string">&#39;measure&#39;</span>,
  startTime: <span class="token number">20.10079099982977</span>,
  duration: <span class="token number">5.206250000745058</span>,
  detail: null
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+k+`" alt="image-20230809225857488"></p><p><strong>类型未发生变化时 运行耗时</strong></p><blockquote><p>我们上面类型变化的代码 注释掉，再重新运行，得出如下结果</p><p>注：单次执行可能存在误差，可以多执行几次，取平均值</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PerformanceMeasure <span class="token punctuation">{</span>
  name: <span class="token string">&#39;测量1&#39;</span>,
  entryType: <span class="token string">&#39;measure&#39;</span>,
  startTime: <span class="token number">21.454458000138402</span>,
  duration: <span class="token number">3.105374999344349</span>,
  detail: null
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看明显的速度提升，同样进行多次相加，但是类型没有发生变化，对代码进行了优化 如果类型发生了变化，会触发 V8 的反优化，增加耗时。</p><h3 id="抽象语法树" tabindex="-1"><a class="header-anchor" href="#抽象语法树" aria-hidden="true">#</a> 抽象语法树</h3><ul><li>源码 =&gt; 抽象语法树 =&gt; 字节码 Bytecode =&gt; 机器码</li><li>编译过程会进行优化</li><li>运行过程可能发生优化</li></ul><h3 id="v8-优化机制" tabindex="-1"><a class="header-anchor" href="#v8-优化机制" aria-hidden="true">#</a> V8 优化机制</h3><ul><li><p>脚本流：</p><blockquote><p>下载过程中就开始解析。</p><p>当下载超过 30kb 的时候就新开单独线程去解析，等全部加载好之后，在进行解析时，之前的已经解析过的合并过来，减少解析时间。</p></blockquote></li><li><p>字节码缓存</p><blockquote><p>源码翻译成字节码之后，例如在不同页面存在<code>部分相同的片段</code>,就把它缓存起来</p></blockquote></li><li><p>懒解析</p><blockquote><p>针对函数，先不解析内部逻辑，真正用时再解析。</p></blockquote></li></ul><p>说到这里，大家可以检查下自己的代码中时候有类型的代码，可以进行优化下·～～</p><p>这里也可以看出，ts 的引入会让我们解决一些类型转换的问题。。</p><h2 id="_03-函数优化【必会】" tabindex="-1"><a class="header-anchor" href="#_03-函数优化【必会】" aria-hidden="true">#</a> 03: 函数优化【必会】</h2>`,35),v={href:"https://blog.csdn.net/szengtal/article/details/78924931",target:"_blank",rel:"noopener noreferrer"},g=a(`<h3 id="函数的解析方式" tabindex="-1"><a class="header-anchor" href="#函数的解析方式" aria-hidden="true">#</a> 函数的解析方式</h3><ul><li><code>lazy parsing</code> 懒解析 VS <code>eager parsing</code> 饥饿解析</li><li>利用 <code>Optimize.js</code> 优化初次加载时间</li></ul><p>() 括号包裹函数，告诉解析器这是一个 eager parsing 饥饿解析。</p><p>如果知道该函数在解析期间会被调用，则使用 eager parsing，如果不调用，使用 lazy parsing。 因为使用立刻会被调用的情况下，如果使用 lazy parsing，会导致之前的优化无效，还需要重新反优化，增加时间。</p><p>压缩的过程中，（）会被去掉，通过 optimize.js 来解决</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">*</span> b <span class="token comment">// 懒解析，这里先记住函数，并不进行解析</span>
  <span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用 webpack 对上面代码进行打包 为了方便定位，进行下面的配置，把 test.js 打包到单独的文件中</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e7bf2044a3b47deab33d346d2a5337c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><p><strong>打包出来的结果</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd95c70fc4240e29718e01e455a23bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><p><strong>实际项目中的时常</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832087e42f1746a89110c8cb4629b52b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><p><strong>代码解读</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">*</span> b <span class="token comment">// 懒解析，这里先记住函数，并不进行解析</span>
  <span class="token comment">// 让add 函数 饥饿解析的方式 如下</span>
  <span class="token comment">// const add = ((a, b) =&gt; a*b); // 饥饿解析</span>

  <span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际 webpack 打包压缩(Uglify)的过程中，会把我们的括号去掉，就不能进行饥饿解析了</p>`,15),h={href:"https://juejin.cn/post/6857145619157368839#heading-14",target:"_blank",rel:"noopener noreferrer"},f=n("h3",{id:"利用-optimize-js-优化初次加载时间",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#利用-optimize-js-优化初次加载时间","aria-hidden":"true"},"#"),s(" 利用 Optimize.js 优化初次加载时间")],-1),y={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnolanlawson%2Foptimize-js",target:"_blank",rel:"noopener noreferrer"},j=a(`<p>可以把压缩后的省略的括号找回来</p><blockquote><p>optimize-js input.js &gt; output.js</p></blockquote><p>Example input:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">runIt</span><span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">runIt</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Example output:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">runIt</span><span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">runIt</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>官方给的速度提升的数据</strong></p><table><thead><tr><th>Browser</th><th>Typical speed boost/regression using optimize-js</th></tr></thead><tbody><tr><td>Chrome 55</td><td>20.63%</td></tr><tr><td>Edge 14</td><td>13.52%</td></tr><tr><td>Firefox 50</td><td>8.26%</td></tr><tr><td>Safari 10</td><td>-1.04%</td></tr></tbody></table><h3 id="重要" tabindex="-1"><a class="header-anchor" href="#重要" aria-hidden="true">#</a> 重要</h3><p>后面 webpack4 包括 Uglify，已经把上面的(括号省略等)问题处理了。</p><p>可能更早的项目需要做一些兼顾</p><blockquote><p>问：变 lazy parsing 为 eager parsing，webpack 它处理了吗，如果有，是怎么做到的 ？</p><p>答：是的，Webpack 可以处理将 lazy parsing 转换为 eager parsing 的需求。在 Webpack 中，可以通过配置文件或者在代码中使用特定的语法来实现。</p><p>在配置文件中，可以使用 <code>optimization.splitChunks</code> 选项来配置代码分割的行为。通过设置 <code>splitChunks.chunks</code> 为 <code>&#39;all&#39;</code>，Webpack 将会对所有模块进行代码分割，将公共的部分提取出来，从而实现 eager parsing。</p><p>另外，在代码中，可以使用 <code>import()</code> 函数来实现动态导入模块的功能。通过使用 <code>import()</code> 函数，Webpack 将会自动将模块进行代码分割，并在需要的时候进行加载，从而实现 eager parsing。</p><p>需要注意的是，Webpack 的代码分割功能需要配合其他优化选项一起使用，例如使用 <code>optimization.runtimeChunk</code> 选项来提取运行时代码，以及使用 <code>optimization.splitChunks.cacheGroups</code> 选项来配置代码分割的规则。</p><p>总之，Webpack 提供了多种方式来处理 lazy parsing，可以根据具体的需求选择合适的方式进行配置。</p></blockquote><p>另外</p><blockquote><p>webpack 可以处理 lazy parsing 和 eager parsing，通过配置和插件可以实现。Lazy parsing 是指在运行时按需加载模块，而 eager parsing 是指在编译时预先加载所有模块。 要启用 eager parsing，你可以在 webpack 配置文件中设置<code>optimization.moduleIds</code>属性为<code>&#39;deterministic&#39;</code>，这将使 webpack 使用模块路径来生成模块标识，从而实现 eager parsing。此外，你还可以设置<code>optimization.chunkIds</code>属性为<code>&#39;deterministic&#39;</code>来生成可预测的块标识。</p><p>除了配置，webpack 还提供了一些插件来优化模块加载。例如，使用<code>PrefetchPlugin</code>和<code>PreloadPlugin</code>插件可以预先加载代码块，以提高应用程序的性能。这些插件可以通过配置手动添加，也可以使用相关的插件或工具自动分析和添加。</p><p>总之，通过适当的配置和插件，webpack 可以实现 lazy parsing 和 eager parsing 的处理，以优化模块加载和应用程序性能。</p></blockquote><h2 id="_04-对象优化【js-对象避坑地图】" tabindex="-1"><a class="header-anchor" href="#_04-对象优化【js-对象避坑地图】" aria-hidden="true">#</a> 04: 对象优化【JS 对象避坑地图】</h2><h3 id="对象优化可以做哪些" tabindex="-1"><a class="header-anchor" href="#对象优化可以做哪些" aria-hidden="true">#</a> 对象优化可以做哪些？</h3><blockquote><p>做这些优化的根据是迎合 V8 引擎进行解析，把你的代码进行优化，它也是用代码写的，它所做的优化其实也是代码实现的一些规则，如果我们写的代码可以迎合这些规则，就可以帮你去优化，代码效率可以得到提升</p></blockquote>`,17),_=a(`<li><p>以相同顺序初始化对象成员，避免隐藏类的调整</p><blockquote><p>以相同顺序初始化对象成员，避免隐藏类的调整 js 是动态、弱类型语言，写的时候不会声明和强调它变量的类型，但是对于编辑器而言，实际上还是需要知道确定的类型，在解析时，它根据自己的推断，它会给这些变量赋一个具体的类型，它有多达 21 种的类型，我们管这些类型叫隐藏类型（hidden class），之后它所做的优化都是基于 hidden class 进行的</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">RectArea</span> <span class="token punctuation">{</span>
  <span class="token comment">// HC0</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">l<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l <span class="token comment">// HC1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w <span class="token comment">// HC2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当声明了矩形面积类之后，会创建第一个hidden class（HC0），</span>
<span class="token keyword">const</span> rect1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RectArea</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 创建了隐藏类HC0, HC1, HC2</span>
<span class="token comment">// 对于编辑器而言，它会做相关的优化，你在接下来再创建的时候，还能按照这个顺序做，那么就可以复用这三个隐藏类，所做的优化可以被重用</span>
<span class="token keyword">const</span> rect2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RectArea</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">// 相同的对象结构，可复用之前的所有隐藏类</span>

<span class="token keyword">const</span> car1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">&#39;red&#39;</span> <span class="token punctuation">}</span> <span class="token comment">// HC0，car1声明对象的时候附带会创建一个隐藏类型</span>
car1<span class="token punctuation">.</span>seats <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment">// HC1，追加个属性再创建个隐藏类型</span>

<span class="token keyword">const</span> car2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">seats</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token comment">// 没有可复用的隐藏类，创建HC2，car2声明时，HC0的属性是关于color的属性，car2声明的是关于seats的属性，所以没办法复用，只能再创建个HC2；HC1不是只包含seats的属性，是包含了color和seats两个属性，也会强调顺序，隐藏类型底层会以描述的数组进行存储，数组里会去强调所有属性声明的顺序，或者说索引，索引的位置</span>
car2<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span> <span class="token comment">// 没有可复用的隐藏类，创建HC3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>由于每次的初始化顺序不一样,导致 v8 内部创建的 HC 不能复用,每次都会重新创建</strong></p></li><li><p>实例化后避免添加新属性</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;nordon&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 此时声明的属性 是 In-object属性</span>
<span class="token punctuation">}</span>
p1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span> <span class="token comment">// 此时声明的属性是 Normal/Fast 属性,存储在 property store里, 需要通过描述数组间接查找</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,2),w=n("p",null,"尽量使用 Array 代替 arry-like 对象",-1),q=n("p",null,"尽量使用 Array 代替 array-like 对象 array-like 对象：js 里都有一个 arguments 这样的对象，它包含了函数参数变量的信息，本身是一个对象，但是可以通过索引去访问里面的属性，它还有 length 的属性，像是一个数组，但它又不是数组，不具备数组带的一些方法，比如说 foreach 如果本身真的是数组，v8 引擎会对这个数组进行极大性能的优化，只是 array-like 的话，它做不了这些事情，在调用 array 方法时，通过间接的手段可以达到遍历 array-like 对象，但是效率没有在真实数组上高",-1),x={href:"https://juejin.cn/post/7022245324563415076",target:"_blank",rel:"noopener noreferrer"},z=a(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrObj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 不如在真实数组上效率高</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 将类数组先转成数组，再进行遍历，转换也是有代价的，这个开销与后面性能优化对比怎么样？</span>
<span class="token comment">// v8做了实践，得出结论：将类数组先转成数组，再进行遍历比不转换直接使用效率要高，所以我们也最好遵循它的要求</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrObj<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 转换的代价比影响优化小</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),C=a(`<li><p>避免读取超过数组的长度</p><blockquote><p>这是讲越界的问题，js 里不容易发现这越界问题，越界了也不一定报错 越界比较的话会造成沿原型链额外的查找，这个能相差到 6 倍</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 越界比较，正常是&lt;,这边是&lt;=，超过边界的值也会比较进来，</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1.造成array[3]的值 undefined 与数进行比较</span>
      <span class="token comment">// 2.数组本身也是一个对象，在数组对象里找不到要的属性之后，会沿原型链向上查找，会造成额外的开销</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 这个数据是无效的，会造成业务上无效、出错</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// [10,100,1000]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>避免元素类型转换</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// PACKED_SMI_ELEMENTS，满的整型元素</span>

array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// PACKED_DOUBLE_ELEMENTS，之前对数组具体到PACKED_SMI_ELEMENTS类型所做的优化全都无效，需要对数组类型进行一次更改，变成PACKED_DOUBLE_ELEMENTS类型，会造成额外的开销，编辑器效率就不高了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c61cdf9b704fe3b66c44e4e038ea20~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><blockquote><p>类型越具体，编辑器能做的优化就越多，如果变得越通用，能做的优化余地就越少</p></blockquote></li>`,2),E=a(`<p><strong>除了以上这些，还有很多，可以去v8官方看看技术博客，会经常更新它们的优化方案，我们如果可以不断配合他们的优化方案，可以让我们代码的效率不断提高</strong></p><h2 id="_05-html-优化【必会】" tabindex="-1"><a class="header-anchor" href="#_05-html-优化【必会】" aria-hidden="true">#</a> 05: HTML 优化【必会】</h2><blockquote><p>html优化空间比较小，html大小在整个页面所有资源里占比比较小，但是也不能忽视，优化工作要做到极致，即使1kb也不能放弃，</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9f4e2fa9d7849e5b1b81f1fcf5eb47c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><p>在html里，有很多没有用的空间，还有一些可以省略的元素，就类似上图中的企鹅群，大家可以再挤一挤，挤在一起就可以达到优化的目的</p><h3 id="html-优化也很重要" tabindex="-1"><a class="header-anchor" href="#html-优化也很重要" aria-hidden="true">#</a> HTML 优化也很重要</h3><ul><li><p>减少 iframes 使用</p><blockquote><p>使用 iframes 额外添加了文档，需要加载的过程，也会阻碍父文档的加载过程，<strong>如果它加载不完成，父文档本身的onload事件就不会触发</strong>，一直等着它，在iframe里创建的元素，比在父文档创建同样的元素，开销要高出很多；</p><p>非要用iframe的话，可以做个延时加载，不要一上来就加载iframe，声明一个iframe，在父文档加载完成之后，再拿到iframe，再对src赋值，让它做加载，达到延迟的目的，不会影响刚开始页面的加载过程</p></blockquote><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;DOMContentLoaded&quot;</span> <span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&#39;src&#39;</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>压缩空白符</p><blockquote><p>编程的时候，为了方便阅读，会留空白或者空行，这些空白符也是占空间的，最后打包时要把空白符去掉</p></blockquote></li><li><p>避免节点深层级嵌套</p><blockquote><p>嵌套越深消耗越高，节点越多最后生成dom树占有内存会比较高，有个遍历，嵌套越深遍历就越慢</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56db723e32bd4a09b9917307b60f32db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p></li><li><p>避免使用table布局</p><blockquote><p>table布局本身有很多问题，使用起来没有那么灵活，造成的开销非常大，同样实现一种布局的方式，用table布局开发和维护起来，相对而言都更麻烦</p></blockquote></li><li><p>删除注释</p><blockquote><p>把无效内容去掉，减少大小</p></blockquote></li><li><p>CSS &amp; Javascript 尽量外链</p><blockquote><p>CSS 和 Javascript 直接写在行间，会造成html文档过大，对于引擎来说，后续也不好做优化，</p><p>css 和 Javascript 有时确实要做在行间，这个和偷懒写在行间是两码事</p></blockquote></li><li><p>删除元素默认属性</p><blockquote><p>本身默认那个值，没有必要写出来，写出来就添加了额外的字符，要通过网络传送给客户端，这就是一些浪费</p></blockquote></li></ul><h3 id="html-最佳实践" tabindex="-1"><a class="header-anchor" href="#html-最佳实践" aria-hidden="true">#</a> HTML 最佳实践</h3><ul><li><p><strong>head 里有很多 meta，每个 meta 要清楚对应的作用，没有用的不要写上去，都是浪费 css 通过外部 css 进行引入</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aac166133fb4193bde5dad998ba1b40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p></li><li><p>body部分多使用html5的语义标签，方便浏览器理解你写的内容是什么，可以进行相关的优化</p></li><li><p>有一些元素，前面有open tag，后面有 closing tag，并不是所有元素需要 closing tag，比如img、li</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4166bd6e0d4bf3b5d2286351fb2918~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p></li><li><p>考虑可访问性，video，浏览器支持或者不支持，还有支持的视频格式都要进行考虑</p></li><li><p>js要放在body的尾部进行加载，为了防止影响dom的加载，js是阻塞的，如果开始就进行加载，它的加载解析就会影响后面dom的加载</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f7ca4187dee46c8b897ee22df209afa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p></li></ul><h3 id="借助工具" tabindex="-1"><a class="header-anchor" href="#借助工具" aria-hidden="true">#</a> 借助工具</h3><ul><li>html-minifier</li></ul><h2 id="_06-css-对性能的影响-【必会】" tabindex="-1"><a class="header-anchor" href="#_06-css-对性能的影响-【必会】" aria-hidden="true">#</a> 06: CSS 对性能的影响 【必会】</h2><h3 id="样式计算开销" tabindex="-1"><a class="header-anchor" href="#样式计算开销" aria-hidden="true">#</a> 样式计算开销</h3><ul><li><p>利用 DevTools 测量样式计算开销</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df01fd11e09745a8b6d109fec74b5fbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f445d4b39d0a4c82855e939e746ae272~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p></li><li><p>复杂度计算，降低计算的复杂度，对元素进行定义样式，尽量定义单一的样式类去描述它的样式，尽量不要使用过于复杂的伪类，多层级联，去锁定这个元素进行样式描述 css解析的原则是自右向左去读，先会找出最具体的元素，把所有的a全都找出来，再根据#box进行过滤，再进行过滤，再进行过滤，直到把所有受到影响的元素全都过滤出来，然后运用这个样式，<strong>随着浏览器解析不断进步，现在这种复杂度的计算已经不是最主要的问题</strong></p></li></ul><h3 id="css优化" tabindex="-1"><a class="header-anchor" href="#css优化" aria-hidden="true">#</a> CSS优化</h3><ul><li><p>降低CSS对渲染的阻塞</p><blockquote><p>由于CSS对渲染的阻塞是无法进行避免的，所以我们从两个角度进行优化：</p><ol><li>尽量早的完成css的下载，尽早的进行解析；</li><li>降低css的大小，首次加载时，只加载当前路径或者首屏有用的css，用不到的进行推迟加载，把影响降到最低</li></ol></blockquote></li><li><p>利用 GPU 进行完成动画</p></li><li><p>使用 <code>contain</code> 属性</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7f795e8896e4e68a100b3622cbd238c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><p>从上图可以看出，没有使用contain布局消耗的时间大概是56.89ms，使用之后可以降低到0.04ms，这是一个非常大的优化</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6493753136b245d8aec860f75de79464~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><p>contain有多个值，layout是其中一个，是现在目前主流浏览器支持比较好的值，作用也比较大 上图是新闻的一个展示页，如果想在第一条内容里插入其他一些内容，对于我们关键渲染路径而言，浏览器并不能知道你插入的东西会不会影响到其他元素的布局，这个时候它就需要对这个页面上的元素进行重新的检查，重新的计算，开销很大，这里有将近10000条的新闻，将近10000个元素要受到影响，如何降低影响？因为我们只是想在第一条里去插入一个东西，后面这些元素本身是不会受到影响的，形状和大小都不会变，这个时候我们就用到contain，contain是开发者和浏览器进行沟通的一个属性，通过contain:layout告诉浏览器，相当于你可以把它看成一个盒子，盒子里所有的子元素和盒子外面的元素之间没有任何布局上的关系，也就是说里面无论我怎么变化不会影响外面，外面怎么变化也不会影响盒子里面，这样浏览器就非常清楚了，盒子里面的元素如果有任何的变化，我会单独的处理，不需要管理页面上其他的部分，这样我们就可以大大减少重新去进行回流或者布局时的计算，这就是 contain:layout 的作用</p></li><li><p>使用font-display属性</p><blockquote><p>可以帮助我们让我们的文字更早的显示在页面上，同时可以适当减轻文字闪动的问题</p></blockquote></li></ul>`,16);function S(T,H){const p=o("ExternalLinkIcon");return c(),i("div",null,[b,n("p",null,[n("a",v,[s("“解析 JavaScript — lazy 是否比 eager 更好?”"),t(p)])]),g,n("p",null,[n("a",h,[s("ParalleUglifyPlugin 多进程代码压缩"),t(p)])]),f,n("p",null,[n("a",y,[s("github.com/nolanlawson…"),t(p)])]),j,n("ul",null,[_,n("li",null,[w,n("blockquote",null,[q,n("p",null,[s("作者：搞定 链接："),n("a",x,[s("https://juejin.cn/post/7022245324563415076"),t(p)]),s(" 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])]),z]),C]),E])}const P=e(m,[["render",S],["__file","index-04.html.vue"]]);export{P as default};
