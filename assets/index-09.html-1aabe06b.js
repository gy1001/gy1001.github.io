import{_ as a,p as e,q as s,a1 as n}from"./framework-e8cb8151.js";const p={},r=n(`<h1 id="_09-基础数据类型为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#_09-基础数据类型为什么是不可变的" aria-hidden="true">#</a> 09-基础数据类型为什么是不可变的</h1><p>这跟垃圾回收机制的工作逻辑有关。</p><p>首先我们需要明确一点，JavaScript 中的任何内存，不能凭空回收，而只能由垃圾回收器回收。</p><p>其次需要明确第二点，回收器会周期性的遍历内存空间，找到内存垃圾然后进行回收利用。也就意味着，垃圾产生的那一刻，并不会立刻被回收，而是要等到垃圾回收器遍历到此处时，才会被回收。</p><p>这个过程就如同扫地机器人。扫地机器人在屋内转圈圈，当你向地上扔一个垃圾时，如果没有扔在扫地机器人的面前，它就不会再那一瞬间将垃圾吸收走，而是要等到它走到垃圾处时，垃圾才会被收走。</p><p>此时我们来分析一个简单的值改变的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
a <span class="token operator">=</span> <span class="token number">20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们首先声明变量 <code>a = 10</code> ，并且将变量修改为 20。当我给变量 a 赋值为 10 的时候，此时内存空间中，会分配一个空间，专门存放 10 这个数字。</p><p>当我们将一个新的数字 20 赋值给 a 时，此时 10 这个数字成为了垃圾，这里许多人就会误解，那我能不能就在 10 这个内存空间的位置，直接填充 20 ？不能！因为垃圾回收器不会闪现过来处理这个逻辑。</p><p>因此，10 所占的内存空间不能立即释放，需要等待垃圾回收器，而此时只能给 20 分配一个新的内存空间，10 因为失去了引用，成为了内存垃圾，等待被回收。</p><p>所以，我们可以推断出，基础数据类型，在内存中是不可以被改变的。</p>`,11),c=[r];function t(d,i){return e(),s("div",null,c)}const l=a(p,[["render",t],["__file","index-09.html.vue"]]);export{l as default};
