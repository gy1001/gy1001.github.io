import{_ as a,p as e,q as i,a1 as l}from"./framework-e8cb8151.js";const r="/assets/image-20230813222402791-47087474.png",h="/assets/image-20230813222505485-6af859eb.png",t="/assets/image-20230813222808873-59878f1b.png",s="/assets/image-20230813222902207-008d1b3c.png",d="/assets/image-20230813223602778-0677145e.png",n="/assets/image-20230813223755969-fce00350.png",c={},o=l('<h1 id="_09-性能优化问题面试指南【能胸有成竹的一步】" tabindex="-1"><a class="header-anchor" href="#_09-性能优化问题面试指南【能胸有成竹的一步】" aria-hidden="true">#</a> 09-性能优化问题面试指南【能胸有成竹的一步】</h1><h2 id="_01-web加载-渲染基本原理" tabindex="-1"><a class="header-anchor" href="#_01-web加载-渲染基本原理" aria-hidden="true">#</a> 01：Web加载&amp;渲染基本原理</h2><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p>从输入url到页面加载显示完成都发生了什么？</p><h3 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h3><ul><li>知识点广，区分度高</li><li>自己擅长的点可以适当展开</li><li>渲染过程是重点</li></ul><h3 id="解答" tabindex="-1"><a class="header-anchor" href="#解答" aria-hidden="true">#</a> 解答</h3><ul><li><p>UI thread：搜索 or url？ -&gt; 搜索引擎 or 请求的站点</p><img src="'+r+'" alt="image-20230813222402791" style="zoom:50%;"></li><li><p>Network thread</p><img src="'+h+'" alt="image-20230813222505485" style="zoom:50%;"></li><li><p>Renderer process</p><p><img src="'+t+'" alt="image-20230813222808873"></p><p><img src="'+s+'" alt="image-20230813222902207"></p></li></ul><h2 id="_02-首屏加载优化" tabindex="-1"><a class="header-anchor" href="#_02-首屏加载优化" aria-hidden="true">#</a> 02：首屏加载优化</h2><h3 id="问题-1" tabindex="-1"><a class="header-anchor" href="#问题-1" aria-hidden="true">#</a> 问题</h3><p>什么是首屏加载？怎么优化？</p><h3 id="分析-1" tabindex="-1"><a class="header-anchor" href="#分析-1" aria-hidden="true">#</a> 分析</h3><ul><li>web 增量加载的特点决定了首屏性能不会完美</li><li>过长的白屏影响用户体验和留存</li><li>首屏（above the fold） -&gt; 初次印象</li></ul><h3 id="解答-1" tabindex="-1"><a class="header-anchor" href="#解答-1" aria-hidden="true">#</a> 解答</h3><ul><li><p>首屏：用户加载体验的3个关键时刻</p><img src="'+d+'" alt="image-20230813223602778" style="zoom:50%;"></li><li><p>测量指标：</p><img src="'+n+'" alt="image-20230813223755969" style="zoom:67%;"></li></ul><h3 id="解答-2" tabindex="-1"><a class="header-anchor" href="#解答-2" aria-hidden="true">#</a> 解答</h3><ul><li><p>资源体积太大</p><blockquote><p>资源压缩，传输压缩，代码拆分，tree shaking，http/2，缓存</p></blockquote></li><li><p>首页内容太多</p><blockquote><p>路由/组件/内容lazy-loading，预渲染/ssr，inline css</p></blockquote></li><li><p>加载顺序不合适</p><blockquote><p>prefetch，preload</p></blockquote></li></ul><h2 id="_03-javascript-内存管理" tabindex="-1"><a class="header-anchor" href="#_03-javascript-内存管理" aria-hidden="true">#</a> 03: JavaScript 内存管理</h2><h3 id="问题-2" tabindex="-1"><a class="header-anchor" href="#问题-2" aria-hidden="true">#</a> 问题</h3><p>js是怎样管理内存的？什么情况会造成内存泄漏？</p><h3 id="分析-2" tabindex="-1"><a class="header-anchor" href="#分析-2" aria-hidden="true">#</a> 分析</h3><ul><li>内存泄漏严重影响性能</li><li>高级语言 != 不需要管理内存</li></ul><h3 id="解答-3" tabindex="-1"><a class="header-anchor" href="#解答-3" aria-hidden="true">#</a> 解答</h3><ul><li>变量创建时自动分配内存，不使用时“自动”释放内存（GC）</li><li>内存释放的主要问题是如何确定不再需要使用的内存</li><li>所有的 GC 都是近似实现，只能通过判断变量是否还能再次访问到</li><li>局部变量，函数执行完，没有闭包引用，就会被标记回收</li><li>全局变量，直至浏览器卸载页面时释放</li><li>引用计数（无法解决循环引用的问题）</li><li>标记清除</li><li>避免意外的全局变量产生</li><li>避免反复运行引发大量闭包</li><li>避免脱离的dom元素</li></ul>',24),p=[o];function u(m,_){return e(),i("div",null,p)}const g=a(c,[["render",u],["__file","index-09.html.vue"]]);export{g as default};
