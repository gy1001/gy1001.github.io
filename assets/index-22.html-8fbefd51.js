import{_ as e,p as s,q as a,a1 as n}from"./framework-e8cb8151.js";const o="/assets/5f51a3e000013a1506400426-6752fc61.jpg",c={},d=n('<h1 id="_22-dockerfile-你真的会用吗" tabindex="-1"><a class="header-anchor" href="#_22-dockerfile-你真的会用吗" aria-hidden="true">#</a> 22-Dockerfile 你真的会用吗？</h1><p><img src="'+o+`" alt="img"></p><blockquote><p>没有引发任何行动的思想都不是思想，而是梦想。 —— 马丁</p></blockquote><h1 id="dockerfile-最佳实践" tabindex="-1"><a class="header-anchor" href="#dockerfile-最佳实践" aria-hidden="true">#</a> Dockerfile 最佳实践</h1><p>我们前面了解到 Docker 会根据 Dockerfile 中指令构建出镜像，关于 Dockerfile 的指令规范可以参考我们之前的文章。Docker 镜像是由多个只读的文件层（layer）组成的，Dockerfile 中的每个指令会生成一个层，而且层是以 delta 增量的形式组织的。下面我们就来介绍一下在使用 Dockerfile 过程中的最佳实践。</p><h3 id="from" tabindex="-1"><a class="header-anchor" href="#from" aria-hidden="true">#</a> FROM</h3><p>任何时候，base 镜像尽量使用官方的镜像，比如 Alpine 镜像，作为一个完整的 Linux 发行版，大小不足 5MB。</p><h3 id="label" tabindex="-1"><a class="header-anchor" href="#label" aria-hidden="true">#</a> LABEL</h3><p>我们可以通过给镜像添加 label 来管理我们的镜像，比如记录 license 信息等。下面是集中比较好的 LABEL 编写格式。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># Set one or more individual labels</span>
<span class="token instruction"><span class="token keyword">LABEL</span> com.example.version=<span class="token string">&quot;0.0.1-beta&quot;</span></span>
<span class="token instruction"><span class="token keyword">LABEL</span> vendor1=<span class="token string">&quot;ACME Incorporated&quot;</span></span>
<span class="token instruction"><span class="token keyword">LABEL</span> vendor2=ZENITH\\ Incorporated</span>
<span class="token instruction"><span class="token keyword">LABEL</span> com.example.release-date=<span class="token string">&quot;2015-02-12&quot;</span></span>
<span class="token instruction"><span class="token keyword">LABEL</span> com.example.version.is-production=<span class="token string">&quot;&quot;</span></span>
<span class="token comment"># Set multiple labels on one line</span>
<span class="token instruction"><span class="token keyword">LABEL</span> com.example.version=<span class="token string">&quot;0.0.1-beta&quot;</span> com.example.release-date=<span class="token string">&quot;2015-02-12&quot;</span></span>
<span class="token comment"># Set multiple labels at once, using line-continuation characters to break long lines</span>
<span class="token instruction"><span class="token keyword">LABEL</span> vendor=ACME\\ Incorporated <span class="token operator">\\</span>
      com.example.is-beta= <span class="token operator">\\</span>
      com.example.is-production=<span class="token string">&quot;&quot;</span> <span class="token operator">\\</span>
      com.example.version=<span class="token string">&quot;0.0.1-beta&quot;</span> <span class="token operator">\\</span>
      com.example.release-date=<span class="token string">&quot;2015-02-12&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="run" tabindex="-1"><a class="header-anchor" href="#run" aria-hidden="true">#</a> RUN</h3><p><code>RUN</code> 指令后面可以接任何命令，当 <code>RUN</code> 后面接的命令太长时，我们可以将命令拆成多行，从而使我们的 dockerfile 可读性更好。</p><h5 id="apt-get" tabindex="-1"><a class="header-anchor" href="#apt-get" aria-hidden="true">#</a> apt-get</h5><p><code>RUN</code> 指令的一个典型应用就是和 <code>apt-get</code> 结合起来使用，我们这里看一下 <code>apt-get</code> 的使用注意事项。</p><p>不要在 dockerfile 中使用 <code>RUN apt-get upgrade</code> 或者 <code>dist-upgrade</code> ，因为 <code>upgrade</code> 会升级镜像中安装的所有包（如果包有更新的话）。取而代之的是，我们可以使用 <code>apt-get update</code> 获取更新的软件包列表，然后如果确定要升级的话再使用 <code>apt-get install -y foo</code> 去自动更新。</p><p>将 <code>apt-get udpate</code> 和 <code>apt-get install</code> 写到一条 <code>RUN</code> 的指令中，也就是像下面这样。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; apt-get install -y <span class="token operator">\\</span>
    package-bar <span class="token operator">\\</span>
    package-baz <span class="token operator">\\</span>
    package-foo</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果把 <code>apt-get update</code> 和 <code>apt-get install</code> 分开编写的话可能会因为 docker build cache 的问题导致没有安装最新的包，举个例子。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:18.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get install -y curl</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 docker build 之后，上面 dockerfile 生成的所有文件层都在 Docker cache 中。如果你之后想安装其他的软件包，比如 nginx，然后将 dockerfile 修改成如下的样子。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:18.04</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get install -y curl nginx</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重新执行 docker build 的时候，由于 cache 的原因，<code>RUN apt-get update</code> 这一行并不会被重新执行，也就是说我们可能会 <code>apt-get install</code> 安装的不是最新版本软件包。</p><p>将 <code>apt-get update</code> 和 <code>apt-get install</code> 写在一行就是典型的 <em><strong>cache-busting</strong></em> 技术。</p><h4 id="使用-pipes" tabindex="-1"><a class="header-anchor" href="#使用-pipes" aria-hidden="true">#</a> 使用 pipes</h4><p>有些 <code>RUN</code> 指令后面的命令涉及的 Linux 的管道（pipe），比如将一个命令执行的输出作为下一个命令的输入。比如下面这个例子：先 wget 下载一个文件，然后使用 wc 统计行数。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">RUN</span> wget -O - https://some.site | wc -l &gt; /number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Docker 执行 <code>RUN</code> 后面的指令是使用 <code>/bin/sh -c</code> 来执行的，对于上面的管道情况，只会把最后一个命令的返回值来作为整个管道链接起来的这条命令的返回值。也就是说上面这条 dockerfile 的指令，只要 <code>wc -l</code> 执行成功 Docker 就认为这条指令 <code>docker build</code> 成功了。但是这个不是符合预期的，比如前面的 <code>wget</code> 执行失败，应该导致 build 失败才是预期的。</p><p>为了解决这个问题，或者说解决此类问题：对于管道中的任何阶段的命令失败都导致 build 失败，我们可以使用 <code>set -o pipefail</code> 来解决。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">RUN</span> set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h3><p><code>CMD</code> 指令用于执行镜像中包含的软件，可以带参数。<code>CMD</code> 大多数情况都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 的形式使用。比如说 Apache 服务镜像，我们可以执行类似于 <code>CMD [&quot;apache2&quot;, &quot;DFOREGROUND&quot;]</code> 形式的命令。</p><p>对于一些其他的 case，<code>CMD</code> 应该提供一个交互式的 shell，比如 Linux 的 bash，python 或者 perl。比如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code> ，<code>CMD [&quot;python&quot;]</code> 和 <code>CMD [&quot;php&quot;, &quot;-a&quot;]</code> 。一旦设置这种形式的 <code>CMD</code>，当我们以类似 <code>docker run -ti &lt;image&gt;</code> 的形式启动容器时，容器启动之后会自动进入一个可用的 shell。</p><p><code>CMD</code> 的另外一种形式 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 只有和 <code>ENTRYPOINT</code> 结合使用的情况下才会用这种形式。</p><h3 id="expose" tabindex="-1"><a class="header-anchor" href="#expose" aria-hidden="true">#</a> EXPOSE</h3><p><code>EXPOSE</code> 指令用来指定容器暴露的端口。对于一些默认的服务镜像，我们应该尽量使用这些服务的默认端口。比如 Apache web server 使用 80 端口：<code>EXPOSE 80</code> ，MongoDB 使用 <code>EXPOSE 27017</code> 。</p><p>我们在容器中暴露了端口之后，<code>docker run</code> 的时候就可以在参数中通过端口隐射的方式将端口暴露到宿主机上。</p><h3 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h3><p><code>ENV</code> 指令用来指定镜像中的环境变量。比如对于 nginx 镜像我们可以将 nginx 的 bin 加到环境变量 PATH 中，然后 CMD 指定 nginx 就可以直接使用了。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">ENV</span> PATH /usr/local/nginx/bin:<span class="token variable">$PATH</span></span>
...
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;nginx&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ENV</code> 除了设置用户的自定义环境变量，有时候还可以用来设置版本号，类似于我们编程中的常量。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">ENV</span> PG_MAJOR 9.3</span>
<span class="token instruction"><span class="token keyword">ENV</span> PG_VERSION 9.3.4</span>
<span class="token instruction"><span class="token keyword">RUN</span> curl -SL http://example.com/postgres-<span class="token variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span>
<span class="token instruction"><span class="token keyword">ENV</span> PATH /usr/local/postgres-<span class="token variable">$PG_MAJOR</span>/bin:<span class="token variable">$PATH</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="add-和-copy" tabindex="-1"><a class="header-anchor" href="#add-和-copy" aria-hidden="true">#</a> ADD 和 COPY</h3><p><code>ADD</code> 和 <code>COPY</code> 的功能非常类似，但是一般优先使用 <code>COPY</code> ，因为 <code>COPY</code> 的功能更单一，只是将本地文件拷贝到容器中，而 <code>ADD</code> 还包括压缩文件解压和以 URL 指定的远程文件支持。</p><p><code>ADD</code> 的最佳实践是将本地的 tar 文件提取到镜像中，例如 <code>ADD rootfs.tar.xz</code> ，这里所说的提取包括拷贝和解压。</p><p>如果需要拷贝多个文件，那么在 dockerfile 文件中最好每次拷贝一个单独的文件，这样的好处是我们可以利用 Docker 的 build cache，每次一个文件变化只会影响单个层的 build cache 失效。举个例子。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">COPY</span> . /tmp/</span>
<span class="token instruction"><span class="token keyword">RUN</span> ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 dockerfile 只要当前目录的任何一个文件变化都会导致 <code>COPY . /tmp</code> 层重新构建，导致后面的指令的 build cache 缓存失效。</p><p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 或者 <code>wget</code> 先下载包，使用完之后将包删除掉。</p><h3 id="entrypoint" tabindex="-1"><a class="header-anchor" href="#entrypoint" aria-hidden="true">#</a> ENTRYPOINT</h3><p><code>ENTRYPOINT</code> 的最佳实践是设置镜像的主命令，使用该镜像启动容器的时候将会执行 <code>ENTRYPOINT</code> 中指定的命令。<code>CMD</code> 可以作为 <code>ENTRYPOINT</code> 的补充，指定主命令的默认参数。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;s3cmd&quot;</span>]</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;--help&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ENTRYPOINT</code> 还可以结合一个辅助脚本使用，下面是 Postgres 官方镜像使用的脚本和 <code>ENTRYPOINT</code> 设置。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token operator">=</span> <span class="token string">&#39;postgres&#39;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">chown</span> <span class="token parameter variable">-R</span> postgres <span class="token string">&quot;<span class="token variable">$PGDATA</span>&quot;</span>

    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-A</span> <span class="token string">&quot;<span class="token variable">$PGDATA</span>&quot;</span><span class="token variable">)</span></span>&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        gosu postgres initdb
    <span class="token keyword">fi</span>

    <span class="token builtin class-name">exec</span> gosu postgres <span class="token string">&quot;<span class="token variable">$@</span>&quot;</span>
<span class="token keyword">fi</span>

<span class="token builtin class-name">exec</span> <span class="token string">&quot;<span class="token variable">$@</span>&quot;</span>
COPY ./docker-entrypoint.sh /

ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;/docker-entrypoint.sh&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>shell 脚本的意思当启动参数中的第一个参数是 postgres 时，会做一些和 $PGDATA 相关的工作，最后再调用 Linux 的系统命令 exec 执行所有参数。借助于这个 <code>ENTRYPOINT</code> ，我们就可以以多种方式启动容器。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run postgres
<span class="token comment"># 或者</span>
$ <span class="token function">docker</span> run postgres postgres <span class="token parameter variable">--help</span>
<span class="token comment"># 或者</span>
$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> postgres <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="volume" tabindex="-1"><a class="header-anchor" href="#volume" aria-hidden="true">#</a> VOLUME</h3><p><code>VOLUME</code> 使用用来存储任何数据库存储文件、配置文件和 Docker 容器创建的文件。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变数据。</p><h3 id="user" tabindex="-1"><a class="header-anchor" href="#user" aria-hidden="true">#</a> USER</h3><p>如果某个服务不需要使用 root 用户执行时，建议使用 <code>USER</code> 指令切换到非 root 用户。使用 <code>USER</code> 之前，要先创建用户或者用户组，类似如下命令。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">RUN</span> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后，为了减少层数和复杂度，避免频繁使用 <code>USER</code> 来回切换用户。</p><h3 id="workdir" tabindex="-1"><a class="header-anchor" href="#workdir" aria-hidden="true">#</a> WORKDIR</h3><p>为了 dockerfile 的可读性， <code>WORKDIR</code> 应该尽量使用绝对路径。对于类似 <code>RUN cd ... &amp;&amp;&amp; do-something</code> 的指令应该尽量避免，取而代之用 <code>WORKDIR</code> 来代替。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>本篇文章系统地总结了在 Dockerfile 编写中的注意事项和最佳实践，希望大家在日常使用过程中可以作为参考使用。</p>`,65),i=[d];function t(r,p){return s(),a("div",null,i)}const u=e(c,[["render",t],["__file","index-22.html.vue"]]);export{u as default};
