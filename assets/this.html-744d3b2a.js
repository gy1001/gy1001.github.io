import{_ as a,p as s,q as n,a1 as e}from"./framework-e8cb8151.js";const t={},o=e(`<h1 id="this-指针" tabindex="-1"><a class="header-anchor" href="#this-指针" aria-hidden="true">#</a> this 指针</h1><h2 id="_1、判断-this" tabindex="-1"><a class="header-anchor" href="#_1、判断-this" aria-hidden="true">#</a> 1、判断 this</h2><ol><li><p>函数是否在 new 中调用(new 绑定) ？</p><blockquote><p>如果是的话，this 绑定的时新创建的对象</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？</p><blockquote><p>如果是的话，this 绑定的是指定的对象</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？</p><blockquote><p>如果是的话，this 绑定的是那个上下文对象</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined 中，否则绑定到全局对象</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>就是这样，对于正常的函数调用来说，理解了这些就可以明白 this 的绑定原理了。不过，凡事总有例外。</p><h2 id="_2、-箭头函数" tabindex="-1"><a class="header-anchor" href="#_2、-箭头函数" aria-hidden="true">#</a> 2、 箭头函数</h2><p><strong>ES6</strong> 中的箭头函数并不会使用上述四种标准的绑定规则，而是根据当前的词法作用域来决定 <strong>this</strong>，具体来说，箭头函数会继承外层函数调用的 <strong>this</strong> 绑定（无论 <strong>this</strong> 绑定到什么）。这其实 <strong>ES6</strong> 之前代码中的 <strong>self = this</strong> 机制一样</p>`,6),i=[o];function p(c,r){return s(),n("div",null,i)}const d=a(t,[["render",p],["__file","this.html.vue"]]);export{d as default};
