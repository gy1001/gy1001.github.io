import{_ as p,M as o,p as i,q as r,R as n,t as s,N as e,a1 as t}from"./framework-e8cb8151.js";const c="/assets/1-20240301173504266-a4d5e5ca.png",l="/assets/1-20240301173504713-7fc0c8d7.png",u="/assets/1-20240301173504604-003e0b74.png",d="/assets/1-20240301173504308-16ca4cb2.png",v="/assets/1-20240301173504340-a7489eaa.png",k="/assets/1-20240301173504311-b2f5ccea.png",m="/assets/1-20240301173504453-1e439900.png",g="/assets/1-20240301173504402-fc0a54de.png",b="/assets/1-20240301173504508-9ed8c6c7.png",_="/assets/1-20240301173504581-89abe22a.png",h="/assets/1-20240301173504625-9182a7c0.png",y="/assets/1-20240301173504668-2d40991d.png",f="/assets/1-20240301173504647-29aceca5.png",q="/assets/1-20240301173504802-246c7965.png",x="/assets/1-20240301173504771-122e4eb5.png",j={},S=n("h1",{id:"_11-v8-引擎是如何工作的",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_11-v8-引擎是如何工作的","aria-hidden":"true"},"#"),s(" 11-V8 引擎是如何工作的")],-1),T=n("p",null,"JavaScript 的代码执行顺序，是每个前端开发工程师都必须要关注的重中之重。无论是未来我们会学习到的函数调用栈，还是事件循环等，都是为了探索代码执行顺序的奥秘而展开的。只有清晰明白代码执行的过程，我们才能对我们自己写的代码更加了解。",-1),J=n("p",null,"那么代码执行顺序，是不是就如我们写的代码那样，从上到下执行的呢？当然没有那么简单！这里我们先了解一下 JavaScript 引擎的简单工作思路，再进行后续的探索。",-1),I=n("h2",{id:"_01-简介",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_01-简介","aria-hidden":"true"},"#"),s(" 01-简介")],-1),V=n("p",null,"JavaScript 引擎也是一个应用程序，它是 JavaScript 执行环境。在浏览器中，它是浏览器的组成部分。每个浏览器对应的 JavaScript 引擎都不一样，例如 chrome 是 v8，firefox 是 SpiderMonkey，safari 是 Nitro 等。",-1),P=n("p",null,"JavaScript 引擎会解析与编译我们所写的 JavaScript 代码。虽然有不同的 JavaScript 引擎，它们的实现方式可能有所差异，解析原理也不尽相同，但是原则它们都必须按照 ECMAScript 的标准来实现。因此想要了解 JavaScript的工作原理，我们了解 V8 就足够了。",-1),A={href:"https://v8.dev/",target:"_blank",rel:"noopener noreferrer"},w=t('<p>V8 内部是由许多小的子模块组成，它的工作流程图如下：</p><p><img src="'+c+`" alt="img"></p><p><em>Blink 是谷歌浏览器的渲染引擎，V8 是 Blink 的内置 JavaScript 引擎</em></p><p>我们依次来了解其中最重要的四个模块。</p><h2 id="_02-scanner" tabindex="-1"><a class="header-anchor" href="#_02-scanner" aria-hidden="true">#</a> 02-scanner</h2><p>scanner 是一个扫描器，用于对纯文本的 JavaScript 代码进行词法分析。它会将代码分析为 tokens。<strong>token</strong> 在这里是一个非常重要的概念，它是词义单位，是指语法上不能再分割的最小单位，可能是单个字符，也可能是一个字符串。</p><p>例如，一段简单的代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的代码的 token 集合如下</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Keyword&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;const&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Identifier&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;a&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Punctuator&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;=&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Numeric&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;20&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_03-parser" tabindex="-1"><a class="header-anchor" href="#_03-parser" aria-hidden="true">#</a> 03-parser</h2>`,11),F={href:"https://esprima.org/demo/parse.html",target:"_blank",rel:"noopener noreferrer"},N=n("img",{src:l,alt:"image.png"},null,-1),B=t(`<p>同样一段代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const a = 20
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>被解析成抽象语法树之后，变成</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Program&quot;</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;body&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;VariableDeclaration&quot;</span><span class="token punctuation">,</span>
      <span class="token string-property property">&quot;declarations&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;VariableDeclarator&quot;</span><span class="token punctuation">,</span>
          <span class="token string-property property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Identifier&quot;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;a&quot;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token string-property property">&quot;init&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token string-property property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Literal&quot;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            <span class="token string-property property">&quot;raw&quot;</span><span class="token operator">:</span> <span class="token string">&quot;20&quot;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token string-property property">&quot;kind&quot;</span><span class="token operator">:</span> <span class="token string">&quot;const&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;sourceType&quot;</span><span class="token operator">:</span> <span class="token string">&quot;script&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，parser 的解析有两种情况，预解析与全量解析。理解他们有助于你编写性能更优的代码。</p><p><strong>预解析 pre-parsing: Layze</strong></p><p>原则上来说，应该对应用中我们编写的所有代码进行解析。但是实际情况有很大的优化空间。在我们代码里，有大量的代码，虽然声明了函数，但是这部分代码并未被使用，因此如果全部都做 Full-parsing 的话，那么整个解析过程就会做许多无用功。</p><p>使用浏览器的调试工具 Coverage 能够清晰的看出来，如下图，表格中的 Usage Visualization 表示的代码使用情况，红色部分表示未被执行过的代码，蓝色部分表示执行过的代码。我们发现，未被使用的代码超过了一半多。这些代码多半是我们在项目中引入的依赖包中声明的函数等。<img src="`+u+`" alt="image.png"></p><p>于是就有了预解析的方案，它在提高代码执行效率上起到了非常关键的作用。它有如下特点</p><ul><li>预解析会跳过未被使用的代码</li><li>不会生成 AST，会产生不带有变量引用和声明的 scopes 信息</li><li>解析速度快</li><li>根据规范抛出特定的错误</li></ul><p>我们来看这样一段代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo1&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo2&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中，声明了两个函数 foo1 和 foo2，但是只有 foo2 被执行了。因此对于 foo1 来说，生成 AST 就变得没有意义。这个时候，foo1 的解析方式就是预解析。但是会生成作用域信息。</p><p>如图，注意观察作用域引用 Scopes。<img src="`+d+`" alt="image.png"></p><p><strong>全量解析 Full-parsing: Eage</strong></p><p>全量解析很好理解，它会解析所有立即执行的代码。这个时候会生成 AST，并且进一步明确更多的信息。</p><ul><li>解析被使用的代码</li><li>生成 AST</li><li>构建具体的 scopes 信息，变量的引用，声明等</li><li>抛出所有的语法错误</li></ul><p>此时对应的，其实就是<strong>执行上下文</strong>的创建过程，关于执行上下文我们后续详细分析。需要区分的是，作用域与作用域链的信息是在预解析阶段就已经明确了。</p><p>分析一下这段代码的解析过程</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 声明时未调用，因此会被认为是不被执行的代码，进行预解析
function foo() {
  console.log(&#39;foo&#39;)
}

// 声明时未调用，因此会被认为是不被执行的代码，进行预解析
function fn() {}

// 函数立即执行，只进行一次全量解析
(function bar() {

})()

// 执行 foo，那么需要重新对 foo 函数进行全量解析，此时 foo 函数被解析了两次 
foo();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三个函数对应三种不同的情况，函数 foo 在函数声明时，被认为是不被执行的代码，因此进行一次预解析，但是后面会调用执行该方法，因此会再次进行全量解析，也就意味着 foo 函数被解析了两次。</p><p>而立即执行函数 bar，在声明时就已经知道会执行，因此只会进行一次全量解析。</p><p>函数声明 fn，从头到尾一直未被执行，因此只会进行一次预解析。</p><p>那如果我在函数 foo 里面再次声明一个函数呢，那是不是也就意味着，foo 内部的函数也会被跟着解析两次。嵌套层级太深甚至会导致更多次数的解析。因此，减少不必要的嵌套函数，能提高代码的执行效率。</p><p>注意：V8 引擎会对 parser 阶段的解析结果，缓存 3 天，因此如果我们把不怎么变动的代码打包在一起，如公共代码，把经常变动的业务代码等打包到另外的 js 文件中，能够有效的提高执行效率。</p><h2 id="_04-ignition" tabindex="-1"><a class="header-anchor" href="#_04-ignition" aria-hidden="true">#</a> 04-Ignition</h2><p>Ignition 是 v8 提供的一个解释器。他的作用是负责将抽象语法树 AST 转换为字节码「bytecode」。并且同时收集下一个阶段「编译」所需要的信息。这个过程，我们也可以理解为预编译过程。基于性能的考虑，预编译过程与编译过程有的时候不会区分的那么明显，有的代码在预编译阶段就能直接执行。</p><h2 id="_05-turbofan" tabindex="-1"><a class="header-anchor" href="#_05-turbofan" aria-hidden="true">#</a> 05-TurboFan</h2><p>TurboFan 是 v8 引擎的编译器模块。它会利用 Ignition 收集到的信息，将字节码转换为汇编代码。这也就是代码被最终执行的阶段。</p><p>Ignition + TurboFan 的组合，就是字节码解释器 + JIT 编译器的黄金组合「边解释边执行」。Ignition 收集大量的信息，交给 TurboFan 去优化，多方面条件都满足的情况下，会被优化成机器码，这个过程称为 Optimize，当判断无法优化时就会触发去优化「De-optimize」操作，这些代码逻辑会重新回到 Ignition 中称为字节码。</p><p>在这个过程中，有一个建议能够帮助我们避免去优化操作，从而提高代码执行效率。那就是<strong>不要总是改变对象类型。</strong></p><p>例如以下一个例子</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 JavaScript 的动态性，我们虽然定义了一个函数 foo，但是该函数的参数 obj 并没有明确它的类型，那么这个时候，如果我传入的参数分别为以下几种情况</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>obj0 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Alex&#39;</span>
<span class="token punctuation">}</span>

obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;tom&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Jake&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">gender</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对编译器而言，obj0，obj1，obj2 是三种不同的类型，此时 TurboFan 就无法针对这种情况做优化处理，只能执行 De-optimize 操作。这意味着执行效率的降低。</p><p>因此，定义函数时，严格要求参数格式保持一致，在实践中是非常重要的优化策略，这也是 typescript 的作用之一。</p><h2 id="_06-orinoco" tabindex="-1"><a class="header-anchor" href="#_06-orinoco" aria-hidden="true">#</a> 06-Orinoco</h2><p>在我们执行的 JavaScript 代码中，有大量的垃圾内存需要处理。甚至绝大多数内存占用都是垃圾。因此我们必须有一个机制来管理这些垃圾内存，用于回收利用。这就是垃圾回收器 Orinoco。</p><p>垃圾回收器会定期的执行以下任务</p><ul><li>标记活动对象，和非活动对象「标记阶段」</li><li>回收被非活动对象占用的内存空间「清除阶段」</li><li>合并或者整理内存「整理阶段」</li></ul><h2 id="_07-总结" tabindex="-1"><a class="header-anchor" href="#_07-总结" aria-hidden="true">#</a> 07-总结</h2><p>v8 的 Compiler Pipeline 并非一开始就是使用的 Ignition + TurboFan 组合。也是在不断的迭代过程中演变而来。例如在他们之前，是 Full-codegen + Crankshaft，并且他们也共存过一段时间。</p>`,43),E={href:"https://docs.google.com/presentation/d/1chhN90uB8yPaIhx_h2M3lPyxPgdPmkADqSNAoXYQiVE/edit#slide=id.g18d89eb289_1_389",target:"_blank",rel:"noopener noreferrer"},z=t('<ul><li>减少了内存占用</li><li>减少了启动时间</li><li>降低了复杂度</li></ul><p><img src="'+v+'" alt="image.png">image.png<img src="'+k+'" alt="image.png">image.png<img src="'+m+'" alt="image.png">image.png</p><p>并展示了不同版本的编译过程</p><p><img src="'+g+'" alt="image.png">image.png<img src="'+b+'" alt="image.png">image.png<img src="'+_+'" alt="image.png">image.png<img src="'+h+'" alt="image.png">image.png<img src="'+y+'" alt="image.png">image.png<img src="'+f+'" alt="image.png">image.png</p><p>详细介绍了机器码的执行过程<img src="'+q+'" alt="image.png"></p><p><img src="'+x+`" alt="image.png">image.png</p><p>以及其他的分析过程，内存占用，时间消耗等。详细的大家可以阅读 PPT 进一步了解。最后的结论是</p><p><strong>Ignition + Turbofan 是 v8 的未来。</strong></p><h2 id="_08-思考题" tabindex="-1"><a class="header-anchor" href="#_08-思考题" aria-hidden="true">#</a> 08-思考题</h2><p>有如下一段代码，你是如何理解活动对象，和非活动对象的，哪些内存是垃圾需要被回收？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">m</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">n</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11);function C(D,L){const a=o("ExternalLinkIcon");return i(),r("div",null,[S,T,J,I,V,P,n("p",null,[n("a",A,[s("点击查看 V8 文档"),e(a)])]),w,n("p",null,[s("顾名思义，parser 模块我们可以理解为是一个解析器。解析过程是一个语法分析的过程，它会将词法分析结果 tokens 转换为抽象语法树「Abstract Syntax Tree」，同时会验证语法，如果有错误就抛出语法错误。我们可以通过在线网站 "),n("a",F,[s("esprima"),e(a)]),s(" 来观察 JavasSript 代码通过词法分析变成 AST 之后的样子。"),N]),B,n("p",null,[s("在官方文档中，提供了"),n("a",E,[s("一个 PPT"),e(a)]),s("，我们可以观察不同版本的演变过程。该 PPT 介绍了为何要使用新的编译组合。")]),z])}const O=p(j,[["render",C],["__file","index-11.html.vue"]]);export{O as default};
