import{_ as e,p as a,q as d,a1 as t}from"./framework-e8cb8151.js";const i="/assets/image-20230729131904726-f7827c59.png",s="/assets/image-20230729131911462-7e680c30.png",c="/assets/image-20230729131918386-9b827091.png",o="/assets/image-20230729131926092-86c7ed07.png",r="/assets/image-20230729131937013-19d91453.png",n="/assets/image-20230729131945799-a793e72e.png",g="/assets/image-20230729131952710-a54a8d20.png",p="/assets/image-20230729131959780-7fa79fdc.png",l="/assets/image-20230729132006925-f6bc4982.png",m="/assets/image-20230729132013537-7d85e284.png",u="/assets/image-20230729132019799-a7d2b7a9.png",v="/assets/image-20230729132026211-2c2c10dc.png",h={},b=t(`<h1 id="_24-合并代码保留提交记录-rebase功能使用" tabindex="-1"><a class="header-anchor" href="#_24-合并代码保留提交记录-rebase功能使用" aria-hidden="true">#</a> 24-合并代码保留提交记录：rebase功能使用</h1><p><img src="https://img4.mukewang.com/5dd1d3a0000139a906400359.jpg" alt="img"></p><blockquote><p>老骥伏枥，志在千里； 烈士暮年，壮心不已。 ——曹操</p></blockquote><p>在第 20 节中，我们了学习使用 <code>git merge</code> 进行分支合并，在执行合并时候会将目标分支的代码与当前分支的代码进行合并，合并完成之后会产生一个新的版本，在这一节当中我们学习一个与 <code>git merge</code> 类似的 <code>git rebase</code> 命令，<code>git rebase</code> 会将另外一个分支的提交的所有新版本记录复制到当前分支中，但和 <code>merge</code> 稍有差异；</p><p>大多数情况下使用 <code>git merge</code> 命令已经满足合并需求，但如果你不想在分支中看到合并完成后产生的 <code>merge branch</code> 版本记录时可以使用 <code>git rebase</code> 命令，这样会让当前分支看起来更加整洁，但区别也不仅仅如此，在这一节当中我使用 <code>git merge</code> 和 <code>git rebase</code> 作对比来进行演示。</p><h2 id="_24-1-merge-合并" tabindex="-1"><a class="header-anchor" href="#_24-1-merge-合并" aria-hidden="true">#</a> 24.1 merge 合并</h2><p><code>git merge</code> 命令和 <code>git rebase</code> 应用场景很类似，在这一节当中我们先使用 <code>git merge</code> 进行合并操作一次，然后大家注意观察版本记录列表中的版本记录顺序。</p><h3 id="_24-1-1-在-test-分支修改代码" tabindex="-1"><a class="header-anchor" href="#_24-1-1-在-test-分支修改代码" aria-hidden="true">#</a> 24.1.1 在 test 分支修改代码</h3><p>现在首先我切换到 <code>test</code> 分支中，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git checkout test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回信息如下图所示：</p><p><img src="`+i+`" alt="image-20230729131904726"></p><p>在上图中，可以看到已经切换到 <code>test</code> 分支当中，现在我随意在 <code>test</code> 分支当中修改代码，然后提交一个版本，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>echo &#39;44444444&#39; &gt;&gt; aa.txt &amp;&amp; git commit . -m &#39;rebase测试&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，会修改 <code>aa.txt</code> 文件的代码，并执行了 <code>git commit</code> 提交工作区的修改到新版本中，返回信息如下所示：</p><p><img src="`+s+`" alt="image-20230729131911462"></p><p>在上图中可以看到提交新版本成功。</p><h3 id="_24-1-2-将-test-分支推送到远程仓库" tabindex="-1"><a class="header-anchor" href="#_24-1-2-将-test-分支推送到远程仓库" aria-hidden="true">#</a> 24.1.2 将 test 分支推送到远程仓库</h3><blockquote><p>一会使用 <code>git rebase</code> 命令演示时候还需要当前的场景，这里我将刚才提交的版本推送到远程去，这样需要恢复当前版本的时候就可以用远程覆盖本地版本，免得重复构建实验环境。</p></blockquote><p>执行推送到远程仓库的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git push --set-upstream origin test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，远程仓库返回的信息如下图所示：</p><p><img src="`+c+`" alt="image-20230729131918386"></p><p>在上图中可以看到推送到远程仓库已经成功，接下来在 <code>develop</code> 也进行一些改动。</p><h3 id="_24-1-3-在-develop-分支修改代码" tabindex="-1"><a class="header-anchor" href="#_24-1-3-在-develop-分支修改代码" aria-hidden="true">#</a> 24.1.3 在 develop 分支修改代码</h3><p>首先切换到 <code>develop</code> 分支中去，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git checkout develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回信息如下图所示：</p><p><img src="`+o+`" alt="image-20230729131926092"></p><p>在上图中可以看到已经切换到 <code>develop</code> 分支，接着我随意的修改代码提交几个版本，执行命令如下所示： develop 仓库提交代码多次代码。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>echo &#39;1111111111&#39; &gt;&gt; aa.txt &amp;&amp; git commit . -m &#39;rebase测试&#39;
echo &#39;2222222222&#39; &gt;&gt; aa.txt &amp;&amp; git commit . -m &#39;rebase测试2&#39;
echo &#39;3333333333&#39; &gt;&gt; aa.txt &amp;&amp; git commit . -m &#39;rebase测试3&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+r+`" alt="image-20230729131937013"></p><p>在上图中可以看到提交了三个版本，</p><h3 id="_24-1-4-使用-merge-命令合并代码" tabindex="-1"><a class="header-anchor" href="#_24-1-4-使用-merge-命令合并代码" aria-hidden="true">#</a> 24.1.4 使用 merge 命令合并代码</h3><p>接着我们回到 <code>test</code> 分支中，并使用 <code>git merge</code> 命令将 <code>develop</code> 分支的代码合并过来，回到 <code>test</code> 分支的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git checkout test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+n+`" alt="image-20230729131945799"></p><p>在上图中可以看到已经切换回 test 分支当中，接着使用 <code>git merge</code> 命令合并代码，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git merge develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+g+`" alt="image-20230729131952710"></p><p>在上图中可以看到合并代码成功，显示了一行代码变更，我们现在就可以使用 <code>git log</code> 命令查看版本日志列表的效果了，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的版本列表信息如下图所示：</p><p><img src="`+p+`" alt="image-20230729131959780"></p><p>在上图中可以看到刚才分别在两个分支下提交的四个版本，在版本列表中顺序是时间的先后顺序，最开始在 <code>test</code> 分支提交的版本在最下方，后来切换到 <code>develop</code> 分支提交的三个版本在上方，最上方的版本为 <code>merge branch</code> 的版本记录，先记住这是 <code>git merge</code> 命令合并代码效果。</p><h2 id="_24-2-rebase-效果" tabindex="-1"><a class="header-anchor" href="#_24-2-rebase-效果" aria-hidden="true">#</a> 24.2 rebase 效果</h2><p>接下来我们来试试 <code>git rebase</code> 命令的效果，通过版本记录列表对比两者有什么区别，我们现在依然在 <code>test</code> 分支下。</p><h3 id="_24-2-1-从远端恢复环境" tabindex="-1"><a class="header-anchor" href="#_24-2-1-从远端恢复环境" aria-hidden="true">#</a> 24.2.1 从远端恢复环境</h3><p>使用 <code>git reset</code> 命令将版本撤销到 <code>git merge</code> 前的状态，直接以远端为准即可，执行命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git reset origin/test  --hard
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+l+`" alt="image-20230729132006925"></p><p>在上图中可以看到分支的版本已经回滚成功，我们可以使用 <code>git log</code> 命令来查看版本列表进行确认，执行的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git  log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的版本列表如下图所示：</p><p><img src="`+m+`" alt="image-20230729132013537"></p><p>在上图中可以看到当前只有 <code>rebase测试</code>这个版本了，其他几个版本已经被撤销。</p><h3 id="_24-2-2-使用-rebase-命令复制版本记录" tabindex="-1"><a class="header-anchor" href="#_24-2-2-使用-rebase-命令复制版本记录" aria-hidden="true">#</a> 24.2.2 使用 rebase 命令复制版本记录</h3><p>接着我们使用 <code>git rebase</code> 命令将 <code>develop</code> 分支的的代码复制过来，执行的命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git rebase develop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 返回的信息如下图所示：</p><p><img src="`+u+`" alt="image-20230729132019799"></p><p>在上图中可以看到 <code>git rebase</code> 已经成功执行，接着我们使用 git log 查看提交日志，执行命令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令执行完毕之后，Git 的版本列表如下图所示：</p><p><img src="`+v+'" alt="image-20230729132026211"></p><p>在上图中可以看到四个版本顺序与之前 <code>git merge</code> 版本记录是不一样的，<code>git rebase</code> 命令后版本顺序不是按照时间，而是将 <code>develop</code> 分支的版本记录放在下方，在当前分支提交的版本放在最上方，同时也没有产生一个 <code>Merge branch</code> 的版本记录。</p><h2 id="_24-3-小结" tabindex="-1"><a class="header-anchor" href="#_24-3-小结" aria-hidden="true">#</a> 24.3 小结</h2><p>在这节中我们学习了一个 <code>git rebase</code> 命令，这个命令如果仅仅从代码层面比较，基本是没有区别的，主要的区别在于版本记录的变化，比如说，因为一些情况我需要在 <code>test</code> 分支修改一些代码，如果我使用了 merge 命令将 develop 的版本合并了进来，后续我想去撤销这次修改的代码，就比较麻烦。</p><p>因为 <code>git merge</code> 合并后的版本记录的顺序是按照时间顺序来的，这样在 <code>test</code> 分支提交的版本就可能在非常往后，而如果是 <code>git rebase</code> 命令进行的代码合并，则是把 ‘develop’ 分支的提交放在最后， 这样当需要撤销的时候就非常的方便，我们主要记录两个区别：</p><ol><li><code>git merge</code> 命令合并代码之后，版本记录会按照时间顺序排序，并自动产生一个 <code>Merge branch</code> 的版本；</li><li><code>git rebase</code> 命令合并代码之后，版本记录会将目标分支的版本放在后面，然后再将当前分支的版本记录放在前边</li></ol>',74),x=[b];function _(f,k){return a(),d("div",null,x)}const q=e(h,[["render",_],["__file","index-24.html.vue"]]);export{q as default};
