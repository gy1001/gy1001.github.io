import{_ as n,p as a,q as s,a1 as i}from"./framework-e8cb8151.js";const l="/assets/23种设计模式-脑图-bd4151bd.png",e={},t=i(`<h1 id="_03-设计原则-设计模式只是套路-设计原则是指导思想" tabindex="-1"><a class="header-anchor" href="#_03-设计原则-设计模式只是套路-设计原则是指导思想" aria-hidden="true">#</a> 03-设计原则 - 设计模式只是套路，设计原则是指导思想</h1><blockquote><p>设计模式应该分开读：从设计到模式。因此先从基本的设计原则入手，引用《UNIX/Linux 设计哲学》一书来辅助讲解。然后再由设计过度到模式，介绍 23 种设计模式。</p></blockquote><h2 id="_01-章介绍" tabindex="-1"><a class="header-anchor" href="#_01-章介绍" aria-hidden="true">#</a> 01：章介绍</h2><h3 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h3><ul><li>SOLID 五大设计原则</li><li>介绍 23 种设计模式，以及前端常用设计模式</li><li>Unix/Linux 设计哲学</li></ul><h3 id="学习方法" tabindex="-1"><a class="header-anchor" href="#学习方法" aria-hidden="true">#</a> 学习方法</h3><ul><li>尝试理解设计的价值</li><li>分开理解“设计”和“模式”</li><li>重点关注开放封闭原则</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li>只需要掌握前端常用的设计模式即可，不需要掌握所有的</li><li>设计原则如果理解不了，那就记录下来背诵，下文而后化</li></ul><h2 id="_02-设计原则" tabindex="-1"><a class="header-anchor" href="#_02-设计原则" aria-hidden="true">#</a> 02：设计原则</h2><h3 id="感性与理性" tabindex="-1"><a class="header-anchor" href="#感性与理性" aria-hidden="true">#</a> 感性与理性</h3><ul><li>设计原则和设计模式都不难理解，它们是“讲道理”的。</li><li>因为：计算机越偏向底层就越简单、执拗、越傻（如必须使用二进制，不使用十进制），因为其本质是电子 + 数学。</li><li>而越偏向于高层或者表层就要越聪明，越任性（如 java 语言，设计原则），因为其本质是应对变化和需求。</li><li>但这个道理一定是<strong>理性</strong>的：</li><li>感性和理性永远是一对矛盾。感性喜欢宣传“多快好省”，但理性就需要思考如何具体实现，以及低成本的运作和维护（全流程）。</li><li>俗话说“书生误国”，文科生喜欢夸夸其谈，说理想，说结果，但从不考虑如何实现，以及如何监控、运维。</li><li>设计原则，设计模式，乃至整个软件工程，都是基于纯理性的思考。</li></ul><h3 id="五大设计原则" tabindex="-1"><a class="header-anchor" href="#五大设计原则" aria-hidden="true">#</a> 五大设计原则</h3><ul><li>S 单一职责原则</li><li>O 开放封闭原则</li><li>L 李氏置换原则</li><li>I 接口独立原则</li><li>D 依赖导致原则</li></ul><h3 id="s-单一职责原则" tabindex="-1"><a class="header-anchor" href="#s-单一职责原则" aria-hidden="true">#</a> S: 单一职责原则</h3><p>一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立。</p><h3 id="o-开放封闭原则-最重要" tabindex="-1"><a class="header-anchor" href="#o-开放封闭原则-最重要" aria-hidden="true">#</a> O: 开放封闭原则(最重要)</h3><ul><li>对修改封闭</li><li>对扩展开放，<strong>这是软件设计的终极目标</strong></li></ul><p>即要设计一种机制，当需求发生变化时，根据这种机制扩展代码，而不是修改原有的代码。</p><h3 id="l-李氏置换原则" tabindex="-1"><a class="header-anchor" href="#l-李氏置换原则" aria-hidden="true">#</a> L: 李氏置换原则</h3><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li><li><strong>前端应用较少</strong></li></ul><h3 id="i-接口隔离原则" tabindex="-1"><a class="header-anchor" href="#i-接口隔离原则" aria-hidden="true">#</a> I: 接口隔离原则</h3><ul><li>保持接口的单一独立，避免出现“胖接口”。</li><li>类似于单一职责原则，只不过前者说的比较统一，后者是单独对接口的规定。JS 中没有接口，因此体现较少。</li></ul><h3 id="d-依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#d-依赖倒置原则" aria-hidden="true">#</a> D: 依赖倒置原则</h3><ul><li>面向接口编程，依赖于抽象而不依赖于具体。</li><li>写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>p<span class="token operator">:</span> Student<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 依赖具体的类</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>p<span class="token operator">:</span> IPerson<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 依赖接口</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明" aria-hidden="true">#</a> 举例说明</h3><p>以常见的 Promise 来解释一下前两个原则。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 加载图片</span>
<span class="token keyword">function</span> <span class="token function">loadImg</span><span class="token punctuation">(</span>src<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;img&#39;</span><span class="token punctuation">)</span>
    img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    img<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&#39;图片加载失败&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    img<span class="token punctuation">.</span>src <span class="token operator">=</span> src
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> promise
<span class="token punctuation">}</span>

<span class="token keyword">const</span> src <span class="token operator">=</span> <span class="token string">&#39;https://www.imooc.com/static/img/index/logo_new.png&#39;</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">loadImg</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>
result
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token operator">:</span> HTMLImageElement<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;img.width&#39;</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span>width<span class="token punctuation">)</span>
    <span class="token keyword">return</span> img
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token operator">:</span> HTMLImageElement<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;img.height&#39;</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span>height<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>单一职责原则：每个<code>then</code>中的逻辑只做好一件事，如果要做多个就用多个<code>then</code></li><li>开放封闭原则：如果这个需求要修改，那去扩展<code>then</code>即可，现有的逻辑不用修改，即对扩展开放、对修改封闭</li></ul><p>这里引申两点：</p><ul><li>其实 S 和 O 是相符现成的，相互依赖</li><li>开放封闭原则的好处不止于此，从整个软件开发流程看，减少现有逻辑的更改，也会减少测试的成本</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li>设计模式是<em><strong>理性</strong></em>的，“讲道理”的</li><li>SOLID 五大设计原则</li><li>重点理解前两个 S 和 O</li></ul><h2 id="_03-unix-linux-设计哲学" tabindex="-1"><a class="header-anchor" href="#_03-unix-linux-设计哲学" aria-hidden="true">#</a> 03: UNIX Linux 设计哲学</h2><ul><li><p>大型复杂的系统，才能体现出设计的价值。操作系统是这个世界上最复杂的系统之一，他的设计思路值得我们学习。</p></li><li><p>按我的理解，通俗来说，设计（仅指编程设计）就是按照哪一种思路或者标准来实现功能。同样的功能，不同的设计思想都能用不同的方式来实现，前期效果可能一样，但是随着产品功能的增加和扩展，设计的作用才会慢慢的显示出来。</p></li></ul><p>结合《UNIX/Linux 设计哲学》中提到的系统设计原则 https://github.com/wangfupeng1988/read-notes/blob/master/book/Linux-Unix%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md 。可能有一些会跟传统思想有区别，但是请你重视它们。</p><ul><li>准则1：小即是美</li><li>准则2：让每个程序只做好一件事</li><li>准则3：快速建立原型</li><li>准则4：舍弃高效率，而更关注可移植性和扩展性</li><li>准则5：采用纯文本来存储数据</li><li>准则6：充分利用软件的杠杆效应（软件复用，代码复用）</li><li>准则7：使用 shell 脚本来提高杠杆效应和可移植性</li><li>准则8：避免强制性的用户界面</li><li>准则9：让每个程序都称为过滤器</li><li>十条小准则 <ul><li>允许用户定制环境</li><li>尽量使操作系统内核小而轻量化</li><li>使用小写字母并尽量简短</li><li>保护树木</li><li>沉默是金</li><li>并行思考</li><li>各部分之和大于整体</li><li>寻求 90% 的解决方案</li><li>更坏就是更好</li><li>层次化思考</li></ul></li></ul><p>无论你现在能否理解以上这些准则，我都希望你每隔一段时间（如半年）都重新自省一下，看自己结合自己的工作经历，是否又加深了这些准则的理解。</p><h2 id="_04-介绍-23-种设计模式" tabindex="-1"><a class="header-anchor" href="#_04-介绍-23-种设计模式" aria-hidden="true">#</a> 04: 介绍 23 种设计模式</h2><h3 id="从设计到模式" tabindex="-1"><a class="header-anchor" href="#从设计到模式" aria-hidden="true">#</a> 从设计到模式</h3><p>“设计”和“模式”两个词应该分开读，先有设计，后有模式。</p><ul><li>设计：即设计原则，设计思想</li><li>模式：前辈总结出来的固定的套路</li><li>1995 年《设计模式：可复用面向对象软件的基础》23 种设计模式</li></ul><h3 id="设计的价值" tabindex="-1"><a class="header-anchor" href="#设计的价值" aria-hidden="true">#</a> 设计的价值</h3><ul><li>从需求到设计，从设计到开发</li><li>为何需要设计？？ <ul><li>因为软件规模变大，甚至是一个系统集群，需要先设计，后开发，否则就乱掉</li></ul></li><li>为何需要模式？ <ul><li>可套用前人经验，降低设计和沟通的成本</li></ul></li></ul><h3 id="_23-种设计模式" tabindex="-1"><a class="header-anchor" href="#_23-种设计模式" aria-hidden="true">#</a> 23 种设计模式</h3><ul><li>创建型模式 <ul><li><strong>工厂模式</strong>（包括：工厂方法模式，抽象工厂模式，建造者模式）</li><li><strong>单例模式</strong></li><li><strong>原型模式</strong></li></ul></li><li>结构型模式 <ul><li>适配器模式</li><li><strong>装饰器模式</strong></li><li><strong>代理模式</strong></li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul></li><li>行为型模式 <ul><li>策略模式</li><li>模板方法模式</li><li><strong>观察者模式</strong></li><li><strong>迭代器模式</strong></li><li>职责连模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul></li></ul><p><img src="`+l+'" alt=""></p><h3 id="前端常用的设计模式" tabindex="-1"><a class="header-anchor" href="#前端常用的设计模式" aria-hidden="true">#</a> 前端常用的设计模式</h3><blockquote><p>这就是课程的价值，帮你节省时间，直击重点，不盲目</p></blockquote><p>1995 年还没有前端，所有当时的一些设计模式，并不完全适用于现在。而且，前后端也有区别。</p><p>所以，前端最常用的设计模式，就以下几个：</p><ul><li>工厂模式</li><li>单例模式</li><li>原型模式</li><li>装饰器模式</li><li>代理模式</li><li>观察者模式</li><li>迭代器模式</li></ul><p>要结合实际应用，把它们学精、学透彻，要明白 JS 是如何体现这些设计模式的。 让你学完了就忘不了（不常用的，学完就忘）</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h3><ul><li>从设计到模式</li><li>23 种设计模式</li><li>前端常用设计模式</li></ul><h2 id="_05-章总结" tabindex="-1"><a class="header-anchor" href="#_05-章总结" aria-hidden="true">#</a> 05：章总结</h2><h3 id="内容回顾" tabindex="-1"><a class="header-anchor" href="#内容回顾" aria-hidden="true">#</a> 内容回顾</h3><ul><li>S O L I D五大设计原则</li><li>介绍 23 种设计模式，以及前端常用设计模式</li><li>Unix/Linux 设计哲学</li></ul><h3 id="重要细节" tabindex="-1"><a class="header-anchor" href="#重要细节" aria-hidden="true">#</a> 重要细节</h3><ul><li><strong>开放封闭原则</strong></li><li>学习工厂模式不必拆分为 3 种，按一种学习即可</li></ul><h3 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1" aria-hidden="true">#</a> 注意事项</h3><ul><li>理解感性与理性</li><li>只需要掌握前端常用的设计模式即可，不需要掌握所有的</li><li>设计原则如果理解不了，不要停留，继续学习</li></ul>',63),p=[t];function o(c,u){return a(),s("div",null,p)}const d=n(e,[["render",o],["__file","index-03.html.vue"]]);export{d as default};
