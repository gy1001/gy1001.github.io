import{_ as s,p as n,q as a,a1 as e}from"./framework-e8cb8151.js";const p={},t=e(`<h1 id="_65-类型兼容性是关键" tabindex="-1"><a class="header-anchor" href="#_65-类型兼容性是关键" aria-hidden="true">#</a> 65-类型兼容性是关键</h1><p>在 ts 的开发中，类型兼容性无处不在。</p><p>可是大家在学习 ts 时，往往会忽略类型兼容性的重要性。</p><p>不理解类型兼容性，就容易在使用时出现很多无法理解的错误。实际使用时，往往需要对各种类型声明进行融合，而要合理的融合，那么类型兼容性就是关键。</p><h2 id="_01-子类型" tabindex="-1"><a class="header-anchor" href="#_01-子类型" aria-hidden="true">#</a> 01-子类型</h2><p>非常简单的案例，</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">30</span>

b <span class="token operator">=</span> a <span class="token comment">// ✅ ok</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，将一个变量，赋值给另外一个变量的场景非常多，因此这里就会涉及到，这两个变量的类型比较问题</p><p>如果 a 的类型，无法兼容 b 的类型，那么，这样的赋值就存在风险。</p><p>上面的例子中，a 与 b 的类型相同，因此可以相互兼容。</p><p>如果稍微调整一下，就会出现错误</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">&#39;500&#39;</span>

b <span class="token operator">=</span> a <span class="token comment">// ❌ error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误提示：不能讲 number 类型分配给 string 类型</p><p>如果此时，我们将 b 的类型，进行一个扩展，让 b 的类型从 number 变成 <code>number | string</code>，就会发现错误消失了</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;500&#39;</span>

b <span class="token operator">=</span> a <span class="token comment">// ✅ ok</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们可以将 <code>number</code> 类型分配给 <code>number | string</code> 类型。</p><p>但是反过来就不行，</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;500&#39;</span>

a <span class="token operator">=</span> b <span class="token comment">// ❌ error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因就是因为 b 的类型可能是一个 string 类型，当其为 string 类型时，就无法分配给 a 的 number 类型。</p><p>因此，在这种情况下。<strong>被赋值的类型范围，要大于等于赋值的类型范围。</strong></p><p>此时我们基于这个例子，来探讨一下子类型的概念。</p><p>从语义上，我们可以很容易知道，Person 类，是父类，而 Student 类，是子类。因为 Person 类，概念更宽泛。而 Student 类，概念更具体。</p><p>因此，更具体的我们称之为子类。也可以称之为我们这里的<strong>子类型。</strong></p><p>那么有如下两个类型</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>他们谁是子类型，谁是父类型呢？</p><p>概念更宽泛的为父类型，也就是 B 概念更具体的为子类型，也就是 A</p><p>从概念范围上来说，我们用 <code>A &lt;= B</code> 来表示 A 是 B 的子类型。</p><p>在设计模式的章节中，我们学习过里氏替换原则，也可以扩展到我们的类型兼容性里，任何使用父类型的地方，都能够用子类型替换。</p><p>因此，我们再来看一下这个例子，<code>b = a</code> ，其实就是子类型，替换父类型。也就是说，子类型能够赋值给父类型。反之则不行。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;500&#39;</span>

<span class="token comment">// 子类型、替换 父类型</span>
b <span class="token operator">=</span> a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看一个对象的例子。</p><p>首先定义一个数据类型如下</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
  phone<span class="token operator">:</span> <span class="token builtin">string</span>
  pwd<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明一个变量，该变量的类型为 User，具体赋值的字段对象，要比 User 中的多一个</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
  phone<span class="token operator">:</span> <span class="token builtin">string</span>
  pwd<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> defUser1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">&#39;xxx1234sd&#39;</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>
  phone<span class="token operator">:</span> <span class="token string">&#39;12312312313&#39;</span><span class="token punctuation">,</span>
  pwd<span class="token operator">:</span> <span class="token string">&#39;123123&#39;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> defUser2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">&#39;xxx1234sd&#39;</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>
  phone<span class="token operator">:</span> <span class="token string">&#39;12312312313&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user<span class="token operator">:</span> User <span class="token operator">=</span> defUser1 <span class="token comment">// ✅ ok</span>
<span class="token keyword">const</span> user2<span class="token operator">:</span> User <span class="token operator">=</span> defUser2 <span class="token comment">// ❌ error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们要根据概念区分谁是父类型，谁是子类型。</p><p>从概念上来说，</p><p>字段更少的对象，概念更宽泛，为父类型</p><p>字段更多的对象，概念更具体，为子类型</p><p>因此，<code>defUser1 &lt;= User &lt;= DefUser2</code>，defUser1 能够赋值给 User，defUser2 不能赋值给 User。</p><p>这里对于子类型与父类型的理解，我们要多思考一下，如果没从概念范围的角度思考清楚，你会觉得好像我们列举的这两个例子明明是反着的，但是结论却又一样，就会很困扰。所以如果没能马上理解，建议回过头多阅读几遍。</p><h2 id="_02-函数类型" tabindex="-1"><a class="header-anchor" href="#_02-函数类型" aria-hidden="true">#</a> 02-函数类型</h2><p>函数类型兼容性的理解，是一个难点。</p><p>首先我们要明确场景。如下场景，并非是把函数当类型进行比较，本质上仍然是比较的基础类型或对象类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Param</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>p<span class="token operator">:</span> Param<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 试图将父类型赋值给子类型，❌ error</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">//</span>

<span class="token comment">// 将子类型赋值给父类型， ✅ ok</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比较函数类型，我们来看一个简单的例子</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">?</span> a <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

x <span class="token operator">=</span> y <span class="token comment">// ✅ ok</span>
y <span class="token operator">=</span> x <span class="token comment">// ❌ error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数类型的比较，比的是参数类型与返回值类型。这里返回值类型相同，我们暂时不考虑。参数类型上来看，</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>xP <span class="token operator">&lt;=</span> yP
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>x 的参数类型是 y 参数类型的子类型。按道理来说，函数 x 应该能够赋值给 y。但是事实上恰好相反。</p><p>y 才是 x 的子类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>y <span class="token operator">&lt;=</span> x
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种情况，我们称之为<strong>逆变</strong>。</p><p>为什么会出现这种情况呢，我们思考一下。</p><p>我们把函数 x 赋值给 y 之后，</p><p>那么对于 y 的函数类型来说，是可以接收 <code>undefined</code> 作为参数的。</p><p>但是，此时 y 的真实函数已经变成了 x。</p><p>而 x 的内部实现并没有处理 <code>undefined</code>.</p><p>因此，把 x 赋值给 y，是一个危险操作。</p><h2 id="_03-泛型" tabindex="-1"><a class="header-anchor" href="#_03-泛型" aria-hidden="true">#</a> 03-泛型</h2><p>泛型的兼容性问题，最后落点通常情况下在于泛型变量的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> p<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> q<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>

p <span class="token operator">=</span> q <span class="token comment">// ❌ error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而当我们调整一下，就可以搞定，让情况符合第一种基础类型，赋值就能成立</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> p<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> q<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>

p <span class="token operator">=</span> q <span class="token comment">// ✅ ok</span>

<span class="token comment">// number &lt;= number | string</span>
<span class="token comment">// 最后是将 number 赋值给 string | number，这是合理的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种 <code>Comp&lt;T&gt;</code> 的类型兼容性，和 <code>T</code> 的类型兼容保持一致时，我们称之为 <strong>协变</strong>。</p><p>泛型还可以有更复杂的区别，我们看看下一个例子</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">SuperType</span> <span class="token punctuation">{</span>
  base<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">SubType</span> <span class="token keyword">extends</span> <span class="token class-name">SuperType</span> <span class="token punctuation">{</span>
  addition<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p<span class="token operator">:</span> SuperType <span class="token operator">=</span> <span class="token punctuation">{</span> base<span class="token operator">:</span> <span class="token string">&#39;base&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> c<span class="token operator">:</span> SubType <span class="token operator">=</span> <span class="token punctuation">{</span> base<span class="token operator">:</span> <span class="token string">&#39;base&#39;</span><span class="token punctuation">,</span> addition<span class="token operator">:</span> <span class="token string">&#39;hex&#39;</span> <span class="token punctuation">}</span>

p <span class="token operator">=</span> c <span class="token comment">// ✅ ok</span>
c <span class="token operator">=</span> p <span class="token comment">// ❌ error</span>

<span class="token keyword">type</span> <span class="token class-name">Contravariant<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token keyword">let</span> pf<span class="token operator">:</span> Contravariant<span class="token operator">&lt;</span>SuperType<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> cf<span class="token operator">:</span> Contravariant<span class="token operator">&lt;</span>SubType<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

pf <span class="token operator">=</span> cf <span class="token comment">// ❌ error</span>
cf <span class="token operator">=</span> pf <span class="token comment">// ✅ ok 逆变</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种 <code>Comp&lt;T&gt;</code> 的类型兼容性与 <code>T</code> 相反的场景，我们称之为<strong>逆变。</strong></p><p>出现这种情况的原因，在于函数的特殊性。这个在上面我们已经分析过，就不在继续分析。</p><blockquote><p><strong>双向协变</strong> 指的 <code>Comp&lt;T&gt;</code> 类型双向兼容。关于双向协变的理解，我个人认为不用过度解读，在实践中可以通过强制类型的方式来实现双向协变，但是这并非完美的解决方案，因此此处只是做个术语解释，不做强制理解。</p></blockquote><p>在 <code>tsconfig.json</code> 中，我们可以通过配置属性 <code>strictFunctionTypes</code> 来选择是否启用逆变。如果该属性值为 false，规则判断时会使用双向协变，当该属性为 true 时，规则判断会使用逆变。</p><p>TypeScript 2.6 之后，<code>strictFunctionTypes</code> 都是默认启用，默认为逆变。</p>`,73),o=[t];function l(c,i){return n(),a("div",null,o)}const d=s(p,[["render",l],["__file","index-65.html.vue"]]);export{d as default};
