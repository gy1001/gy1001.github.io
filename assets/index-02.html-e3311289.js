import{_ as e,p as i,q as a,a1 as r}from"./framework-e8cb8151.js";const d="/assets/image-20230801215259384-9d9d5330.png",s="/assets/image-20230801221052847-cd9c7699.png",l="/assets/image-20230801223923393-b96b179f.png",t="/assets/image-20230801223942216-4c115245.png",h="/assets/image-20230801224027675-45ab1b92.png",c="/assets/image-20230801224858698-56e144a6.png",g={},n=r('<h1 id="_02-混合开发核心技术-jsbridge" tabindex="-1"><a class="header-anchor" href="#_02-混合开发核心技术-jsbridge" aria-hidden="true">#</a> 02: 混合开发核心技术 JSBridge</h1><h2 id="_01-jsbridge-实现原理" tabindex="-1"><a class="header-anchor" href="#_01-jsbridge-实现原理" aria-hidden="true">#</a> 01：JSBridge 实现原理</h2><ul><li>类似 Client/Sever 模式</li><li>将 Native 端原生接口封装成 JavaScript 接口</li><li>将 Web 端 JavaScript 接口封装成原生接口</li><li>Web 端和 Native 端之间双向通信</li></ul><p><img src="'+d+'" alt="image-20230801215259384"></p><h2 id="_02-jsbridge-实现方式一-拦截-url-schema" tabindex="-1"><a class="header-anchor" href="#_02-jsbridge-实现方式一-拦截-url-schema" aria-hidden="true">#</a> 02：JSBridge 实现方式一：拦截 URL Schema</h2><ul><li>URL Schema 是类 URL 的一种请求格式</li><li><code>&lt;protocol&gt;://&lt;domain&gt;/&lt;path&gt;?&lt;query&gt;</code></li><li><code>https://www.google.com/search?keyword=jsbridge</code></li><li>自定义 JSBridge 通信的 URL Schema</li><li><code>jsbridge://&lt;method&gt;?&lt;params&gt;</code></li><li>例子：<code>jsbridge://showToast?text=hello&amp;a=b</code></li></ul><p><img src="'+s+'" alt="image-20230801221052847"></p><h3 id="这种方式的优缺点" tabindex="-1"><a class="header-anchor" href="#这种方式的优缺点" aria-hidden="true">#</a> 这种方式的优缺点</h3><ul><li>优点：兼容性好</li><li>缺点：不直观，URL 长度有限</li></ul><p><img src="'+l+'" alt="image-20230801223923393"></p><p><img src="'+t+'" alt="image-20230801223942216"></p><h2 id="_03-jsbridge-实现方式一-注入-js-api" tabindex="-1"><a class="header-anchor" href="#_03-jsbridge-实现方式一-注入-js-api" aria-hidden="true">#</a> 03：JSBridge 实现方式一：注入 JS API</h2><p><img src="'+h+'" alt="image-20230801224027675"></p><ul><li>优点：简单直观</li><li>缺点：有兼容性问题：（Android 4.2+）</li></ul><h2 id="_03-带回调的-jsbridge" tabindex="-1"><a class="header-anchor" href="#_03-带回调的-jsbridge" aria-hidden="true">#</a> 03：带回调的 JSBridge</h2><h3 id="什么是带回调的-jsbridge" tabindex="-1"><a class="header-anchor" href="#什么是带回调的-jsbridge" aria-hidden="true">#</a> 什么是带回调的 JSBridge</h3><ul><li>在对端执行操作并返回结果</li><li>有输入有输出才是完整的调用</li></ul><p><img src="'+c+'" alt="image-20230801224858698"></p><h2 id="_04-使用-jsbridge-的开源实现" tabindex="-1"><a class="header-anchor" href="#_04-使用-jsbridge-的开源实现" aria-hidden="true">#</a> 04：使用 JSBridge 的开源实现</h2><h3 id="学习-jsbridge-的目的" tabindex="-1"><a class="header-anchor" href="#学习-jsbridge-的目的" aria-hidden="true">#</a> 学习 JSBridge 的目的</h3><ul><li>掌握原理</li><li>具备造轮子的能力</li><li>避免重复造轮子</li></ul><h3 id="jsbridge-的开源实现" tabindex="-1"><a class="header-anchor" href="#jsbridge-的开源实现" aria-hidden="true">#</a> JSBridge 的开源实现</h3><ul><li>JsBridge：拦截 URLSchema</li><li>DSBridge: 注入 JS API</li></ul>',23),o=[n];function m(_,b){return i(),a("div",null,o)}const u=e(g,[["render",m],["__file","index-02.html.vue"]]);export{u as default};
