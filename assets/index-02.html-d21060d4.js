import{_ as n,p as s,q as a,a1 as e}from"./framework-e8cb8151.js";const t="/assets/1-20240301165425550-6aa7480a.png",p="/assets/1-20240301165834770-a4e4fa45.png",o="/assets/1-20240301165834780-8b4cbd28.png",c="/assets/1-20240301165835098-b8154ac8.png",l="/assets/1-20240301165834948-a2b36821.png",i="/assets/1-20240301002841190-5d013557.png",r="/assets/1-20240301165835011-8b5483fd.png",d="/assets/1-20240301165834743-4ac0cfc0.png",u="/assets/1-20240301165835049-754b6917.png",k="/assets/1-20240301165835078-2697e1b5.png",v="/assets/1-20240301165835047-db13bf06.png",m={},b=e('<h1 id="_02-内存与数据结构" tabindex="-1"><a class="header-anchor" href="#_02-内存与数据结构" aria-hidden="true">#</a> 02-内存与数据结构</h1><p>我们可以把一个页面，看成是一个完整的独立应用。</p><p>那么，哪些个体参与了应用的运行，这些个体以什么样的形式存在，这些个体要存放在哪里「内存中」，这些个体在内存中如何存放，都是我们要一一去了解的事情。</p><p><img src="'+t+`" alt="img"></p><h2 id="_01-个体" tabindex="-1"><a class="header-anchor" href="#_01-个体" aria-hidden="true">#</a> 01-个体</h2><p>讨论参与应用的个体，是讨论在应用运行过程中，哪些角色可能会参与应用运行的课题。</p><p>在 JavaScript 中，通常可以通过声明变量、函数、对象这三个方式，来明确它们。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 声明一个变量</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token comment">// 声明一个函数</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
<span class="token comment">// 声明一个对象</span>
<span class="token keyword">class</span> <span class="token class-name">M</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，<code>a, add, M</code> 分别是不同个体的名字。我们可以通过这些名字，访问到具体个体的值。</p><h2 id="_02-数据类型" tabindex="-1"><a class="header-anchor" href="#_02-数据类型" aria-hidden="true">#</a> 02-数据类型</h2><p>讨论数据类型，是讨论个体以什么样的形式存在的课题。</p><p>ES6 中定义了 8 种数据类型。其中包括 7 种基础数据类型与一种引用数据类型「Object」。</p><h3 id="基础数据类型-「primitive-value」" tabindex="-1"><a class="header-anchor" href="#基础数据类型-「primitive-value」" aria-hidden="true">#</a> 基础数据类型 「primitive value」</h3><p>基础数据类型，通常用来表达一些结构简单的数据。</p><table><thead><tr><th style="text-align:left;">基础类型</th><th style="text-align:left;">值</th></tr></thead><tbody><tr><td style="text-align:left;">Boolean</td><td style="text-align:left;">只有两个值：<code>true</code> 与 <code>false</code></td></tr><tr><td style="text-align:left;">Null</td><td style="text-align:left;">只有一个值：<code>null</code></td></tr><tr><td style="text-align:left;">Undefined</td><td style="text-align:left;">只有一个值：<code>undefined</code></td></tr><tr><td style="text-align:left;">Number</td><td style="text-align:left;">所有数字</td></tr><tr><td style="text-align:left;">String</td><td style="text-align:left;">所有字符串</td></tr><tr><td style="text-align:left;">Symbol</td><td style="text-align:left;">符号类型 <code>var sym = Symbol(&#39;tSymbol&#39;)</code></td></tr><tr><td style="text-align:left;">BigInt</td><td style="text-align:left;">整数的末尾追加 n</td></tr></tbody></table><p>学习基础数据类型，最核心的关键点，是要理解到，<strong>基础数据类型的值，是不可改变的。</strong></p><p>乍一听，好像有点不太对。我们在使用过程中，经常会遇到修改值的场景。例如数据的累加，字符串的变动等等。是不是和「不可改变」冲突了呢？</p><p>以数据累加为例，我们写一个小案例来验证一下。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a
b<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 仍然为1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 变成了2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析一下上面的代码。我们声明一个变量 <code>a</code>, 并且声明一个变量 <code>b</code>，将 <code>a</code> 赋值给 <code>b</code>。这个时候，<code>a</code> 与 <code>b</code> 是等价的。然后我们试图去修改 <code>b</code> 的值，进行累加操作。最后发现一个奇怪的结果，<code>a</code> 的值没有变，可是 <code>b</code> 的值改变了。也就意味着，<code>a</code> <code>b</code> 的等价，并不表示他们是同一个值。我们用图例来表达这个过程。<img src="`+p+`" alt="img"></p><p>左侧表示变量，右侧表示具体的值。第三步 <code>b</code> 为 1 的结果被覆盖了，因此用虚线表示。</p><p>我们发现，变量名对应的值可能被改变，但是基础数据类型的值本身是没有改变的。对于变量 <code>b</code> 来说，是一个新的值跟他建立了对应关系。</p><p>因此，我们说，<strong>基础数据类型，是按值访问的。</strong></p><p>当两个基础类型的变量进行比较时，本质上，也是他们的值在进行比较。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">1</span>
a <span class="token operator">==</span> b <span class="token comment">// --&gt; 1 == 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面字符串的案例也能说明问题</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;K&#39;</span> <span class="token comment">// 试图修改字符串的第一个字符</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment">// 打印结果：hello world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了不可变性，基础数据类型还有一个需要我们关注的重点，那就是<strong>基础数据类型也能访问方法。</strong></p><p>这就很奇怪，如果是一个对象，能够访问方法我们能够理解，基础数据类型也能访问方法其实细想一下就很奇怪。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>
str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>原因是因为当我们在访问字符串时，实际上依然是在访问一个对象。在 JavaScript 中，针对每一种基础数据类型(null 和 undefined 除外)，都有提供对应的包装对象，例如对于字符串而言，就有一个名为 <code>String</code> 的包装对象，当我们使用字符串变量访问方法时，实际上经历了如下三步代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 首先使用包装对象创建对象</span>
<span class="token keyword">var</span> _str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// 然后使用包装对象的实例去访问方法</span>
_str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">// 最后销毁该对象</span>
_str <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>包装对象会在访问方法时临时生效，并在访问结束之后清除包装对象生成的实例。</p><h3 id="引用数据类型「reference-value」" tabindex="-1"><a class="header-anchor" href="#引用数据类型「reference-value」" aria-hidden="true">#</a> 引用数据类型「reference value」</h3><p>当数据结构变得更加复杂，不再是单一的数字或者字符串，则需要引用数据类型来表达。例如我们想要表达一本书，需要知道书的名字，作者，发行日期等许多信息，才能完整的表达它。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;JavaScript 核心进阶&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">author</span><span class="token operator">:</span> <span class="token string">&#39;这波能反杀&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">date</span><span class="token operator">:</span> <span class="token string">&#39;2020.08.02&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与基础数据类型不同的是，<strong>引用数据类型的值是可以被改变的。</strong></p><p>我们也写一个类似的案例来进行分析。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;JavaScript 核心进阶&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">author</span><span class="token operator">:</span> <span class="token string">&#39;这波能反杀&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">date</span><span class="token operator">:</span> <span class="token string">&#39;2020.08.02&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> b2 <span class="token operator">=</span> book
b2<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">&#39;反杀&#39;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span> <span class="token comment">// {title: &quot;JavaScript 核心进阶&quot;, author: &quot;反杀&quot;, date: &quot;2020.08.02&quot;}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span> <span class="token comment">// {title: &quot;JavaScript 核心进阶&quot;, author: &quot;反杀&quot;, date: &quot;2020.08.02&quot;}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个案例中，我们声明了变量 <code>book</code>，它的值类型是一个引用数据类型。并且将 <code>book</code> 赋值给新的变量 <code>b2</code>。然后修改 <code>b2</code> 的 <code>author</code> 属性。结果我们发现，<code>book</code> 和 <code>b2</code> 的值，都发生了变化。我们用图例来表达这个过程。</p><p><img src="`+o+`" alt="img"></p><p>在上图中，与变量 <code>book</code> 建立直接映射关系的，并非引用类型本身，而是引用类型值本身在内存中的地址 <code>0x0012ff7</code>。因此，当我们执行 <code>b2 = book</code> 进行一个赋值操作时，并非如基础数据类型那样，值的本身有一份新的拷贝，而只是地址进行了一份拷贝。这种只拷贝地址的操作，我们也可以称之为<strong>浅拷贝</strong>。</p><p>那么自然的，当我们通过 <code>b2</code> 修改 <code>author</code> 字段时，<code>book</code> 对应的值自然也发生了改变，因为他们最终，都是指向同样的引用类型值。</p><p>因此我们说，<strong>引用数据类型，是按引用访问的</strong>。这里的引用，说的其实就是内存空间中的地址。</p><p>当两个引用数据类型在进行比较时，本质上，是他们的内存地址在进行比较。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
a <span class="token operator">==</span> b <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中，由于 <code>a</code> 与 <code>b</code> 是两个分开创建的对象，尽管他们的值是一样的，但是他们在内存空间中的地址不一样，因此他们比较的结果也会不同。直接比较引用地址，我们称这样的操作为<strong>浅比较</strong>。</p><blockquote><p>浅拷贝与浅比较，都是针对引用数据类型的概念，它们没有非常明确的界限来定义，在其他场景里，只比较一层数据结构，也被认为是浅比较，浅比较是低成本的比较方式，浅拷贝同理。</p></blockquote><h2 id="_03-内存" tabindex="-1"><a class="header-anchor" href="#_03-内存" aria-hidden="true">#</a> 03-内存</h2><p>内存是讨论参与应用的个体存放在哪里的课题。</p><p>大家都有过购买电脑的经验。在购买电脑时，我们常常会关注两个非常重要的指标：内存与硬盘。</p><p><img src="`+c+'" alt="img"><img src="'+l+'" alt="img"></p><p>这是计算机给应用程序提供的两种存储信息的途径。我们要研究变量、函数、对象等个体存放在哪里，就是要弄明白内存与硬盘存储的区别。</p><p>对于 CPU 而言，他们的区别非常明显。内存通常用于存储程序运行时的信息，CPU 可以通过寄存器直接寻址访问。因此，CPU 访问内存的速度是非常快的。</p><p>我们可以将大量的电影，图片等永久存储在硬盘中。与内存的区别就在于，CPU 并不能直接访问硬盘中的数据，它只能通过硬件控制器来访问。</p><table><thead><tr><th style="text-align:left;">对象</th><th style="text-align:left;">容量</th><th style="text-align:left;">访问速度</th><th style="text-align:left;">CPU 能否直接访问</th><th style="text-align:left;">存储时效</th></tr></thead><tbody><tr><td style="text-align:left;">内存</td><td style="text-align:left;">小</td><td style="text-align:left;">快</td><td style="text-align:left;">能</td><td style="text-align:left;">程序运行时</td></tr><tr><td style="text-align:left;">硬盘</td><td style="text-align:left;">大</td><td style="text-align:left;">慢</td><td style="text-align:left;">不能</td><td style="text-align:left;">持久性</td></tr></tbody></table><p>对于电脑而言，一个应用程序，我们下载下来，是安装在硬盘存储中，而当我们运行这个程序时，则是在内存中进行。</p><p>与之对应的，一个 JavaScript 应用程序，也是在内存中运行。我们也可以将一些数据做持久化存储，这就是我们常说的本地缓存。本质上来说，这些本地缓存也是存储在硬盘中。在浏览器中，提供了 localStorage 对象来帮助我们实现本地缓存。</p><p>在 JavaScript 中，内存又分为栈内存与堆内存。栈内存与堆内存本身没有区别，只因为存取方式的差异，而有了不同。通常情况下，一个应用在运行时，操作系统会分配一份内存给它。假设这段内存地址为 0 ~ 1000。</p><blockquote><p>内存地址本应该用 16 进制表示，但是为了便于理解，此处使用 10 进制表示</p></blockquote><p>应用程序使用栈内存时，是从地址高位开始分配内存空间。使用堆内存时，是从地址低位开始分配空间。</p><p><img src="'+i+'" alt="img"></p><h2 id="_04-基础数据结构" tabindex="-1"><a class="header-anchor" href="#_04-基础数据结构" aria-hidden="true">#</a> 04-基础数据结构</h2><p>讨论数据结构，是讨论参与应用的个体，在内存中如何存放的课题。</p><p>其中，<strong>栈、堆、队列</strong> 是我们需要了解并掌握的三种基础数据结构。</p><h3 id="stack-栈" tabindex="-1"><a class="header-anchor" href="#stack-栈" aria-hidden="true">#</a> stack 栈</h3><p>在学习中遇到栈这个名词时，我们需要针对不同的场景去理解它所要表达的含义。</p><p>第一种场景，<strong>栈是一种数据结构</strong>。它表达的是对于数据的一种存取方式。这是一种理论基础。</p><p>要理解栈数据结构的存取方式，我们可以通过类比乒乓球盒子来分析。如下图所示。</p><p><img src="'+r+`" alt="img"></p><p>往乒乓球盒子中依次放入乒乓球，当我们想要取出来使用时，处于盒子中最顶层的乒乓球 5，它一定是最后被放进去并且最先被取出来的。而我们想要使用最底层的乒乓球 1，就必须要将上面的所有乒乓球取出来之后才能取出。但乒乓球 1 是最先放入盒子的。</p><p>乒乓球的存取方式与栈数据结构如出一辙。这种存取方式的特点我们总结为<strong>先进后出，后进先出（LIFO，Last In，First Out）</strong>。如上图右侧所示，处于栈顶的数据 true，最后进栈，最先出栈。处于栈底的数据 1，最先进栈，最后出栈。</p><p>在 JavaScript 中，数组「Array」提供了两个栈方法用来对应栈的这种存取方式。他们在实践中非常常用。</p><p><strong>push</strong>：向数组末尾添加元素「进栈方法」</p><p>push 方法可以接受任意参数，把他们逐个添加到数组末尾，并返回修改后数组的长度</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// a: [1]</span>
a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">// a: [1, 2, 4, 6]</span>
<span class="token keyword">var</span> l <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// a: [1, 2, 4, 6, 5] l: 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>pop</strong>：弹出数据最末尾的一个元素「出栈方法」</p><p>pop 方法会将数据最末尾的一个元素删除，并返回被删除的元素。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// a: [1, 2]</span>
<span class="token comment">// a.pop()的返回结果为 3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组提供的栈方法，可以很方便的让我们在实践中，模拟栈数据结构来解决问题。</p><p>第二种场景是将栈数据结构的理论运用于实践：栈内存空间。我们刚才已经知道，内存空间，因为操作方式不同才有了区别，而栈内存空间的操作方式，正是使用了栈数据结构的思维。</p><p>栈内存空间，是用于记录函数的执行记录，它代表了函数的执行顺序。因此也称之为函数调用栈「call Stack」。函数调用栈的相关知识，后续专门用一章来分析。</p><h3 id="heap-堆" tabindex="-1"><a class="header-anchor" href="#heap-堆" aria-hidden="true">#</a> heap 堆</h3><p>堆内存，与堆数据结构是完全不同的两回事。在学习时一定要仔细区分。</p><p>堆内存是内存中的空间区域。CPU 可以通过内存地址直接访问。</p><p>它的存取方式与在书架中取书的方式非常相似。书虽然整齐的放在书架上，但是我们只要知道书的名字，在书架中找到它之后就可以方便的取出，我们不用关心书的存放顺序，不用像从乒乓球盒子中取乒乓球那样，非得将上面的所有乒乓球拿出来之后才能取到中间的某一个乒乓球。</p><p>下面是一个大概的示意图。</p><p><img src="`+d+`" alt="img"></p><p>该示意图可以用字面量对象的形式体现出来。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> testHeap <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">m</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token literal-property property">n</span><span class="token operator">:</span> <span class="token number">110</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们想要访问 a 时，就只需要通过 <code>testHeap.a</code>来访问即可，我们不用关心 a，b，c 的具体顺序。</p><p>堆数据结构，是一种特殊的树状结构。他们关系大概如下：</p><p><img src="`+u+'" alt="img"></p><p>而为了易于存储与索引，在实践中，我们常常会使用二叉堆去解决问题。例如，在 v8 定时器实现原理中，我们会使用二叉堆「又称优先级队列」来决定哪个事件优先执行。</p><blockquote><p>优先级队列是非常重要的知识，高级前端工程师必备</p></blockquote><p>二叉堆是一颗完全二叉树。我们使用一个数组就完全可以存储完全二叉树。因此它非常易于存储。</p><p><img src="'+k+'" alt="img"></p><p>二叉堆又分最大堆和最小堆。</p><p><strong>最大堆</strong>，又称大顶堆，父节点的键值总是大于等于任何一个子节点。 <strong>最小堆</strong>，又称小顶堆，父节点的键值总是小于等于任何一个子节点。</p><p>暂时就介绍到这里，具体的数据结构实现，我们在后续补充章节中详细说明。</p><h3 id="queue-队列" tabindex="-1"><a class="header-anchor" href="#queue-队列" aria-hidden="true">#</a> queue 队列</h3><p>队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人。用以下的图示可以清楚的理解队列的原理。</p><p><img src="'+v+`" alt="img"></p><p>队列所要表达的核心思维是一种排队机制。因此运用到我们实践中就会有许多其他的规则，例如，位于队列首位的 人员 Peter 有其他的事情必须去完成，这个时候就需要在队列中暂时挂起，让其他的成员可以出队，当 Peter 事情做完之后，需要直接排在队列首位。</p><p>又例如在浏览器中，会将所有的异步事件都放于队列中等待执行，可需要满足一定条件才能直接执行。</p><p>因此此处队列的先进先出只是一个基础规则，结合运用到实践时，又会有新的限制条件出现。</p><h2 id="_05-内存空间管理" tabindex="-1"><a class="header-anchor" href="#_05-内存空间管理" aria-hidden="true">#</a> 05-内存空间管理</h2><p>当一个新的个体参与到应用的运行中来，我们首先需要给这个个体分配一份内存空间。而这个个体参与结束之后，它不再参与应用的运行了，我们就应该想办法让它把刚才所占的内存空间让出来，释放掉，这样才能有效的利用有限的内存空间。这个过程，就是内存管理。</p><p>对于栈内存而言，操作系统会自动回收出栈的内存空间。</p><p>对于堆内存而言，JavaScript 中提供了自动的垃圾回收机制，来释放内存。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span>
a <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三条语句，可以对应内存管理的三个过程。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1. 给新的个体分配内存空间</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span>

<span class="token comment">// 2. 参与程序运行，使用内存</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token comment">// 3. 参与完毕，释放内存</span>
a <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>垃圾回收主要依靠「引用」的概念。当一块内存空间中的数据能够被访问时，垃圾回收器就认为「该数据能够被获得」，也就意味着，这份数据可能还需要使用。不能够被获得的数据，就会被打上标记，并释放对应的内存空间。这种方式叫做<strong>标记-清除算法</strong>。</p><p>这个算法会设置一个全局对象，并定期的从全局对象开始查找，垃圾回收器将会找到所有可以获得与不能够被获得的数据。</p><p>因此在上面的简单例子中，当我们将 a 的值设置为 null，那么刚开始分配的 20，就无法被访问到了，很快就会被自动回收。</p><p><strong>注意</strong>: 在全局中，垃圾回收器无法判断全局声明的内存什么时候应该释放，因此我们在开发中，需要尽量避免使用全局变量。如果使用了全局变量，最好建议不再使用时，通过<code>a = null</code> 这样的方式释放引用，以确保能够及时回收。</p><h2 id="_06-小结" tabindex="-1"><a class="header-anchor" href="#_06-小结" aria-hidden="true">#</a> 06-小结</h2><p>本文以一个独立的完整应用作为思维的出发点，去思考当应用运行时，哪些个体参与，这些个体以什么形式存在，这些个体要放在哪里，怎么放等问题，从而轻松将数据类型，内存，数据结构等知识串联。这些看上去零散的知识，都是为了解决应用需要运行这个实际的问题，而提出的解决方案。</p><h2 id="_07-思考题" tabindex="-1"><a class="header-anchor" href="#_07-思考题" aria-hidden="true">#</a> 07-思考题</h2><p>下面代码执行后，变量 <code>m</code> 的值是否被改变了，为什么？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arg<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,122),g=[b];function h(y,f){return s(),a("div",null,g)}const _=n(m,[["render",h],["__file","index-02.html.vue"]]);export{_ as default};
