## 1. 性能优化说的什么

### 1.1. 开发时构建速度优化

从 npm run dev 敲下的一瞬间到呈现出结果需要占用多少时间

- webpack 在这方面下的功夫是很重的：cache-loader cache loader 结果（如果两次构建源代码没有产生变化，则直接使用缓存）、thread-loader、开启多线程构建等
- vite 是按需加载，所以我们不太需要 care 这方面

### 1.2. 页面性能时间：和我们怎么去写代码有关

- 首屏渲染时：fcp（first conten paint)页面中第一个元素的渲染时长
- 懒加载
- http 优化

- 协商缓存：是否使用缓存要和后端商量一下，当服务端给我们打上协商缓存的标记之后，客户端在下次刷新页面需要重新请求资源时就会发送一个协商请求到服务端，服务端如果说需要变化，则会响应具体的内容，如果服务端觉得没有变化则会响应 304
- 强缓存：服务端给响应头追加一些字段（expires），客户端记住这些字段，在 expries（截止失效时间）没有到达之前，无论怎么刷新页面，浏览器都不会重新请求页面，而是从缓存里面取

- 最大元素市场 lcp：largest content paint

### 1.3. js 逻辑

- 要注意副作用的清除

- 组件是会频繁卸载和挂载（如果在某一个组件中有定时器、监听函数，卸载时候并没有进行清除，下次挂载时候等于开了多个定时器或者监听器）

- 我们在写法上的一个注意事项：

- requestAnimation、requestIdleCallback
- 浏览器的帧率：16.6ms 去更新一次（执行 js 逻辑以及重排重绘...等）

- 防抖 节流 forEach：尽量使用lodash中的
- 作用域控制

```javascript
const arr = [1,3,3]
for(let i=0;i<arr.length;i++){} // 每次访问arr
for(let i=0,len=arr.length;i<len;i++){} // 只访问一次
```

### 1.4. css

- 继承属性
- 避免过深嵌套

### 1.5. 生产的优化

- rollup 优化体积

- 图片压缩
- cdn
- 分包
- tree-sharking