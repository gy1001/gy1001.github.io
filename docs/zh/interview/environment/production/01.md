# 运行环境
* 运行环境即浏览器（server端有 nodejs）
* 下载网页代码，渲染出页面，期间会执行若干 JS
* 要保证代码在浏览器中：稳定且高效

## 1. 网页加载过程
### 1.1 加载资源的形式
* html 代码
* 媒体文件，如图片、视频等
* JavaScript Css

### 1.2 加载资源的过程
* DNS 解析: 域名 =>  IP地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器
### 1.3 渲染页面的过程
* 根据 html 代码生成 DOM Tree
* 根据 Css 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合形成 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 script 则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染过程
### 1.4 思考题
1. 为什么建议 css 放在 head 中
2. 为什么建议 js 放在 body 之后
### 题目
#### 1. 从输入url 到渲染出页面的整个过程
* 下载资源：各个资源类型、下载过程
* 渲染页面：结合 html css JavaScript 图片等
#### 2. window.onload 和 DOMContentLoaded的区别
```javascript
window.addEventListener('load', function(){
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
window.addEventListener("DOMContentLoaded", function(){
  // DOM 渲染完即可执行，此时图片、视频可能还没有加载完成
})
```
## 2. 性能优化
* 是一个综合性问题，没有标准答案，但要求尽量全面
* 某些细节问题可能会单独提问：手写防抖、节流
* 只关心核心点，针对面试
### 2.1 性能优化原则
* 多使用内存、缓存或者其他方法
* 减少 CPU 计算量，减少网络加载耗时
* 适用于所有编程的性能优化------空间换时间
### 2.2 从何入手
#### 2.2.1 让加载更快
* 减少资源体积：压缩代码
* 减少访问次数：合并代码，SSR 服务端渲染，缓存
* 使用更快的网络：CDN
#### 2.2.2 让渲染更快
* CSS 放在 head 中，JS 放在 body 最下面
* 尽早开始执行 JS, 用 DOMContentLoaded 触发
* 懒加载（图片懒加载，上滑加载更多）
* 对 DOM 查询进行缓存
* 频繁 DOM 操作，合并到一起插入 DOM 结构
* 节流 throttle（间隔一段时间执行一次回调） 防抖 debounce（在连续的事件，只需触发一次回调）
#### 2.2.3 缓存
* 静态资源加 hash 缓存，根据文件内容计算 hash
* 文件内容不变，则 hash 不变，url 不变
* url 和文件不变，则会自动触发 http 缓存机制，返回 304
#### 2.2.4 CDN
#### 2.2.5 SSR
* 服务端渲染：将网页和数据一起加载，一起渲染
* 非SSR(前后端分离):先加载网页，再加载数据，再渲染数据
* 早先的 JSP ASP PHP，现在的 Vue React SSR
#### 2.2.6 懒加载
```html
<img id="img1" scr="preview.png" data-real-src="abc.png" />
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.scr = img1.getAttribute('data-real-src')
</script>
```
#### 2.2.7 缓存 DOM 查询
```javascript
// 不缓存 DOM 查询结果
for(let index = 0;index<document.getElementsByTagName("p").length;index++){
  // 每一次循环，都会计算 length, 频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p')
const length = pList.length
for(let index = 0; index< length; index++){
  // 缓存 length， 只进行一次 DOM 查询
}
```
#### 2.2.8 多个 DOM 操作一起插入到 DOM 结构
将频繁操作改为一次性操作
```javascript
const listNode = document.getElementById("list")
// 创建一个文档片段，此时还没有插入到 DOM 树中
const frag = document.createDocumentFragement()

// 执行插入
for(let x = 0; x<10;x++){
  const li = document.createElement("li")
  li.innerHTML = "List Item " + x
  frag.appendChild(li)
}
// 都完成以后，再插入到 DOM 树中
listNode.appendChild(frag)
```
#### 2.2.9 尽早开始 JS 执行
```javascript
window.addEventListener('load', function(){
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
window.addEventListener("DOMContentLoaded", function(){
  // DOM 渲染完即可执行，此时图片、视频可能还没有加载完成
})
```
## 3. 防抖 debounce
* 监听一个输入框的，文字变化后触发 change 事件
* 直接用keyup事件，则会频繁触发change事件
* 防抖：用户输入结束或者暂停时，才会触发 change 事件
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
  </head>
  <body>
    <input type="text" id="input" />
  </body>
  <script>
    const input1 = document.getElementById('input')
    // 未使用防抖，会频繁触发
    input1.addEventListener('keyup', function (event) {
      console.log(event.target.value)
    })
  </script>
  <script>
    // 优化一下
    const input2 = document.getElementById('input')
    let timer = null
    input2.addEventListener('keyup', function () {
      if (timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
        console.log(input2.value, '我是简单优化后的函数')
      }, 1000)
    })
  </script>

  <script>
    // 封装函数 debounce
    function debounce (fn, delay = 500) {
      // 这个 timer 是在 闭包 中的
      let timer = null

      return function () {
        if (timer) {
          clearTimeout(timer)
        }
        timer = setTimeout(() => {
          fn.apply(this, arguments)
          timer = null
        }, delay)
      }
    }
    const debounceFunc = debounce(event => {
      //  如果想用 this， 这里不能用箭头函数
      console.log(event.target.value, '我是封装的debounce函数')
    }, 600)
    input2.addEventListener('keyup', debounceFunc)
  </script>
</html>
```

## 3. 安全
