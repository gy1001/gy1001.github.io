# 从 0 到 1 开发一款 iOS App - 01

## 01. 创建第一个 XCode 工程

1. 打开 xcode 软件，选择新建项目，选择 APP 栏目，输入适当的项目信息，然后可以看到初始化后的一个项目
2. 修改`ViewController.m`文件，添加如下内容

```objective-c
// 创建一个简单的 hello world
- (void)viewDidLoad {
  [super viewDidLoad];
  [self.view addSubview:({
    UILabel *label = [[UILabel alloc] init];
    label.text = @"hello world";
    [label sizeToFit];
    label.center = CGPointMake(self.view.frame.size.width/2, self.view.frame.size.height/2);
    label;
  })];
}
@end
```

3. 运行模拟机，你就会看到一个显示`hello world`的界面

## 02. 创建多个`UIView`

> 上一节我们看到一个显示 hello world 的界面，这节我们创建两个 UIView，并注意创建顺序和层级的关系

1. 修改`ViewController.m` 中 `hello world` 的`UILable`界面内容，内容如下

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    // 创建两个子view
    UIView *view = [[UIView alloc] init];
    view.backgroundColor = [UIColor redColor];
    view.frame = CGRectMake(100, 100, 100, 100);
    [self.view addSubview:view];

    UIView *view2 = [[UIView alloc] init];
    view2.backgroundColor = [UIColor greenColor];
    view2.frame = CGRectMake(150, 150, 100, 100);
    [self.view addSubview:view2];
}

@end
```

2. 运行模拟机后，可以看到两个方块，一个红色一个绿色，并且两个元素有重叠部分，且`后创建的元素在上面`

   <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132600fea9554117a225c14192e4c6ce~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

## 03. UIView 的生命周期

1. UIView 也有很多生命周期，我们创建一个子 TestView 继承 UIView，并再实现其各个生命周期。
2. 创建一个 `view`继承`TestView`,并进行挂载。
3. 在`view`的创建和挂载出，以及`TestView`的各个生命周期处添加断点，然后运行模拟机
4. 内容如下

   ```objective-c
   #import "ViewController.h"
   
   @interface TestView: UIView
   @end
   
   @implementation TestView
   -(instancetype )init{
       self = [super init];
       return self;
   }
   - (void)willMoveToSuperview:(nullable UIView *)newSuperview{
       [super willMoveToSuperview:newSuperview]; // 此处 打断点 ，序号为 3
   }
   - (void)didMoveToSuperview{
       [super didMoveToSuperview];// 此处 打断点 ，序号为 4
   }
   - (void)willMoveToWindow:(nullable UIWindow *)newWindow{
       [super willMoveToWindow: newWindow];// 此处 打断点 ，序号为 5
   }
   - (void)didMoveToWindow{
       [super didMoveToWindow];// 此处 打断点 ，序号为 6
   }
   @end
   
   @interface ViewController()
   @end
   
   @implementation ViewController
   - (void)viewDidLoad {
       [super viewDidLoad];
       UIView *view = [[TestView alloc] init]; // 此处 打断点 ，序号为 1
       view.backgroundColor = [UIColor redColor];
       view.frame = CGRectMake(100, 100, 100, 100);
       [self.view addSubview:view]; // 此处 打断点 ，序号为 2
   }
   @end
   ```

   5. 运行模拟机可以，可以看到执行顺序：`序号1(创建)`=>`序号2（挂载 addSubview）`=>`序号3（willMoveToSuperview）`=>`序号4（didMoveToSuperview）`=>`序号5（willMoveToWindow）`=>`序号6（didMoveToWindow）`

## 04. UIViewController

### 1. 视图控制器，管理视图 View 层级结构

1. 自身包含 View,可以理解为一个容器

- 管理 View 视图的生命周期
- 响应用户操作
- 和 App 整体交互，视图的切换
- 作为一个 container 管理多个 Controller 和动画

2. ViewController 的生命周期

- init
- viewDidLoad
- viewWillAppear
- viewDidAppear
- viewWillDisappear
- viewDidDisappear
- Dealloc

选择合适的函数处理不同的业务

### 2. 代码示范

1. 修改`ViewController.h`，内容修改如下

   ```objective-c
   #import "ViewController.h"

   @interface TestView: UIView
   @end

   @implementation TestView
   -(instancetype )init{
       self = [super init];
       return self;
   }
   @end

   @interface ViewController()
   @end

   @implementation ViewController

   -(instancetype ) init{
       self = [super init];
       return self;
   }
   - (void)viewWillAppear:(BOOL)animated{
       [super viewWillAppear:animated]; // 这里打断点，序号3
   }

   - (void)viewDidAppear:(BOOL)animated{
       [super viewDidAppear:animated];// 这里打断点，序号4
   }
   // 这里的生命周期在页面消失后才会触发，这里是单页面，无法演示，后续再讲解
   - (void)viewWillDisappear:(BOOL)animated{
       [super viewWillDisappear:animated];
   }
   - (void)viewDidDisappear:(BOOL)animated{
       [super viewDidDisappear:animated];
   }
   - (void)viewDidLoad {
       [super viewDidLoad];

       TestView *view = [[TestView alloc] init]; // 这里打断点，序号1
       view.backgroundColor = [UIColor redColor];
       view.frame = CGRectMake(100, 100, 100, 100);
       [self.view addSubview:view];// 这里打断点，序号2
   }
   @end
   ```

2. 打完断点后，运行模拟器，可以看到执行顺序：`序号1（创建）`=>`序号2（挂载）`=>`序号3（viewWillAppear）`=>`序号4（viewDidAppear）`
3. 注意：`viewWillAppear`时候页面中元素还没有展示出来，展示完成后才触发的`viewDidAppear`

## 05. 实现你的第一个 TabBar 页面

### 1. 通过 UIView 和 UIViewController 的特性搭建 App

- UIView 负责页面内的内容呈现
- 使用基础的 UIViewController 管理多个 UIView
- UIViewController 在管理 UIView 的同时，负责不同的切换

### 2. 常用 App 页面结构分析

#### 1. 单页面展示

- 通过列表展示简介
- 通过较长滚动页面展示内容

#### 2. 多页面管理

- 4 个或者 5 个底部按钮：`UITabBarController`
- 通过 Push 的方式进行页面切换

#### 3. UITabBarController

> UITabBarController 功能就是管理多个 ViewController 切换，通过点击底部对应按钮，选中对应需要展示的 ViewController.
>
> 国内 App 一般展示 4-5 个可选项

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f99fc7f29f64cd6b87c30b4b2ced060~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

#### 4. UITabBar

> 可以包含 多个 UITabBarButton, UITabBarButton 又可以包含 tabBarItem.image、tabBarItem.title

- 按照加入 TabbarController 的顺序展示
- 展示的内容有对应的 ViewController 设置
- 系统负责点击的响应和切换

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/779767e5f2834fd0b90cd5ff870ad388~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

### 3. 实现自己的 TabBar

- 使用系统函数实现

- 相关开源框架和项目

  - 开源 Tabbar/Tabbarcontroller 主要是做了简易的封装+5 个按钮的样式

  1. 完全自己实现
  2. TabBar 上粘贴自定义的 SubView，响应事件调用系统方法

### 4. 代码实现

1. `AppDelegate.m`中进行如下更改，更给`rootViewController`指向

   ```objective-c
   - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
       // Override point for customization after application launch.
       self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
       UITabBarController *tabbarController = [[UITabBarController alloc] init];

       UIViewController *controller1 = [[UIViewController alloc] init];
       controller1.view.backgroundColor = [UIColor redColor];

       UIViewController *controller2 = [[UIViewController alloc] init];
       controller2.view.backgroundColor = [UIColor yellowColor];

       UIViewController *controller3 = [[UIViewController alloc] init];
       controller3.view.backgroundColor = [UIColor greenColor];

       UIViewController *controller4 = [[UIViewController alloc] init];
       controller4.view.backgroundColor = [UIColor lightGrayColor];

       [tabbarController setViewControllers:@[controller1,controller2,controller3,controller4]];

       self.window.rootViewController = tabbarController;
       [self.window makeKeyAndVisible];
       return YES;
   }
   ```

2. 运行模拟机发现报错了，报错信息如下

   ```shell
   terminating with uncaught exception of type NSException
   *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[AppDelegate setWindow:]: unrecognized selector sent to instance 0x6000011d8280'
   ```

3. 解决办法

   - 删除`info.plist` 下的`Application scence Manifest`
   - 删除 `SceneDelegate（.h和.m）`文件
   - 删除`AppDelegate.h`中的`SceneDelegate`回调方法,即如下代码（~~**删掉删掉删掉删掉删掉删掉删掉**~~）

     ```objective-c
     #pragma mark - UISceneSession lifecycle

     - (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options{
       ....
     }
     - (void)application:(UIApplication *)application didDiscardSceneSessions:(NSSet<UISceneSession *> *)sceneSessions {
     	...
     }
     ```

   - `AppDelegate.h`里加声明`window`:
     ```objective-c
     @property (nonatomic, strong) UIWindow * window;
     ```

### 代码实现中报错参考文档

[Xcode 11 版本纯代码设置 window.rootviewController](https://www.jianshu.com/p/c30ff97996ce)

### 5. 用新版本 Xcode 实现 Tabbar

> 4 小节的方法可能涉及到诸多删除代码的问题，避免删错误，可以用如下方式

#### iOS13 中 appdelegate 的职责发现了改变：

- iOS13 之前，Appdelegate 的职责全权处理 App 生命周期和 UI 生命周期；

- iOS13 之后，Appdelegate 的职责是：

- 1、处理 App 生命周期
- 2、新的 Scene Session 生命周期， 那 UI 的生命周期交给新增的 Scene Delegate 处理

- 在 `SceneDelegate.m` 中添加如下代码

  ```objective-c
  - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
      // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
      // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
      // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
      UIWindowScene *windowScene = (UIWindowScene *)scene;
      self.window = [[UIWindow alloc] initWithWindowScene:windowScene];
      self.window.frame = windowScene.coordinateSpace.bounds;

      UITabBarController *tabbarController = [[UITabBarController alloc] init];

      UIViewController *controller1 = [[UIViewController alloc] init];
      controller1.view.backgroundColor = [UIColor redColor];
      controller1.tabBarItem.title = @"新闻";

      UIViewController *controller2 = [[UIViewController alloc] init];
      controller2.view.backgroundColor = [UIColor yellowColor];
      controller2.tabBarItem.title = @"视频";

      UIViewController *controller3 = [[UIViewController alloc] init];
      controller3.view.backgroundColor = [UIColor blueColor];
      controller3.tabBarItem.title = @"推荐";

      UIViewController *controller4 = [[UIViewController alloc] init];
      controller4.view.backgroundColor = [UIColor greenColor];
      controller4.tabBarItem.title = @"我的";

      // 将四个页面的 UIViewController 加入到 UITabBarController 之中
      [tabbarController setViewControllers: @[controller1, controller2, controller3, controller4]];

      self.window.rootViewController = tabbarController;
      [self.window makeKeyAndVisible];
  }
  ```

- 重新模拟器，发现可以正常运行，显示四个导航

- 参考链接：https://time.geekbang.org/course/intro/100025901?tab=comment

## 06. 使用 UINavigationController 管理页面

### 1. UINavigationController

#### 1. 相关功能

- 通过栈管理页面间的跳转
- 通常只展示栈顶页面
- Push/Pop 操作

#### 2. 通过 UINavigationBar 响应操作，处理 UIViewController 的切换

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800265617cc4890b21bb56f066f10ee~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 3. UINavigationBar

- `UINavigationController`管理

- 顶部`UIViewController`变化，`UINavigationBar`则同步变化

  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0831288b8c4f4c2ba9318cf9ad25d2de~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 4. 实现自己的`Navigation`

- 使用系统函数实现

- 相关开源框架和项目

- 开源`Navigation`相关都集中在过渡动画的样式上

  1. WRNavigationBar
  2. KMNavigationBarTransition
  3. RTRootNavigationController

  部分项目完全自定义实现 `NavigationController`,以实现特殊动画效果。

#### 5. 代码实现

> 注意：本章节是通过 05 小节中的最新版的实现 tabBar 方式来实现，即在`SceneDelegate.m`中设置 tabBar

1. 上一节中我们实现底部四个 tabBar, 本节中我们设置第一个 tab 页面为`UINavigationController`, 并把`UINavigationController`的`initWithRootViewController`设置为我们最开始演示的一个`viewController`（红绿色方块的页面），代码如下

   ```objective-c

   #import "ViewController.h" // 此行添加

   - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {

       UIWindowScene *windowScene = (UIWindowScene *)scene;
       self.window = [[UIWindow alloc] initWithWindowScene:windowScene];
       self.window.frame = windowScene.coordinateSpace.bounds;
       UITabBarController *tabbarController = [[UITabBarController alloc] init];

     	// ------------------start:更改的部分----------------------------------------------------
       ViewController *viewController = [[ViewController alloc] init];
       UINavigationController * nagationController = [[UINavigationController alloc] initWithRootViewController:viewController];
       nagationController.view.backgroundColor = [UIColor whiteColor];
       nagationController.tabBarItem.title = @"新闻";
       nagationController.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/page@2x.png"];
       nagationController.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/page_selected@2x.png"];

       // 以下部分删除
       //    UIViewController *controller1 = [[UIViewController alloc] init];
       //    controller1.view.backgroundColor = [UIColor redColor];
       //    controller1.tabBarItem.title = @"新闻";
       //    controller1.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/page@2x.png"];
     	//    controller1.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/page_selected@2x.png"];
     	// ---------------------end-------------------------------------------------

      	[tabbarController setViewControllers:@[nagationController,controller2,controller3,controller4]];
     	// 其他保持不变
   }
   ```

2. 这里运行模拟器后，我们就可以看到页面中显示了的方块元素，证明页面挂载成功

3. 接下来，我们实现 方块元素的点击跳转效果，`ViewController.m`文件中添加如下代码

   ```objective-c
   
   - (void)viewDidLoad {
       [super viewDidLoad];
       TestView *view = [[TestView alloc] init];
       view.backgroundColor = [UIColor systemGreenColor];
       view.frame = CGRectMake(100, 100, 100, 100);
       [self.view addSubview:view];
       // 绑定点击事件
       UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(pushController)];
       [view addGestureRecognizer:tapGesture];
   }
   // 点击事件触发方法
   -(void) pushController{
       UIViewController * viewController  = [[UIViewController alloc] init];
       viewController.view.backgroundColor = [UIColor whiteColor];
       viewController.navigationItem.title = @"内容";
       viewController.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"右侧标题" style:UIBarButtonItemStylePlain target:self action:nil];
       [self.navigationController pushViewController:viewController animated:YES];
   }
   ```

## 07. App 中的窗口

|              | UIBarButtonItem | UITabBar        | UITabBarController     |
| ------------ | --------------- | --------------- | ---------------------- |
| MVC 中的角色 | M               | V               | C                      |
|              | UITabBarItem    | UINavigationBar | UINavigationController |

### 1. UIWindow

- 特殊形式的`UIView`, 提供 `App` 中展示内容的基础窗口

- 只作为容器，和 `ViewController` 一期协同工作

- 通常屏幕上只存在、展示一个`UIWindow`

- 使用`storyborad`会帮我们自动创建

- 手动创建

  1. 创建 `UIWindow`

  2. 设置`rootViewController`

  3. `makeKeyAndVisible`

     <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85086f5463f7463192599770d426cdf1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;float:left;" />

### 2. 代码演示

1. 新建项目，修改`ViewController.m`的背景颜色，增加如下代码

   ```objective-c
   - (void)viewDidLoad {
       [super viewDidLoad];
     	// 增加的代码
       UIView *view = [[UIView alloc] init];
       view.backgroundColor = [UIColor redColor];
       view.frame = CGRectMake(100, 100, 100, 100);
       self.view.backgroundColor = [UIColor yellowColor];
       [self.view addSubview:view];
       UILabel *label = [[UILabel alloc] init];
       label.text = @"hello world";
       [label sizeToFit];
       label.center = CGPointMake(self.view.frame.size.width/2, self.view.frame.size.height/2);
       [self.view addSubview:label];
   }
   ```

2. 运行项目，可以看到正常运行，并且页面显示灰色背景

3. 然后删除`Main.storyboard`和`LaunchScreen.storyboard`，并且删除`info.plist`下的`Storyboard Name`，删除项目`info`项目中的`Main storyboard file base name`以及`Application Scene Manifest`中的`Storyboard Name`选项

4. 修改`SceneDelegate.m`中的代码，添加如下代码

   ```objective-c
   #import "ViewController.h"

   - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
       UIWindowScene *windowScene = (UIWindowScene *)scene;
       self.window = [[UIWindow alloc]initWithWindowScene:windowScene];
       self.window.frame = windowScene.coordinateSpace.bounds;

       ViewController *vc =[[ViewController alloc]init];
       self.window.rootViewController = vc;
       [self.window makeKeyAndVisible];
   }
   ```

5. 重新运行模拟器，就可以看到 App 重新启动了，并且显示的事 `ViewController.m`中的内容

### 3. 常用的启动窗口逻辑

> 注意：查看下面两种滑动效果，以及差异

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8a8e7410ca432bbdfa533f2589767f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:25%;display:inline;" /><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03660e69eaac4b46a476c82817a3198d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:25%;display:inline;" />

### 4. 代码实现-01

我们目前的代码示例中实现的就是效果 1，点击进入新页面时，底部 tabbar 还是可以看到的，此处就不做演示了

### 5. 代码实现-02

1. 修改`SceneDelegate.m`中的代码，修改代码如下

```objective-c
- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {

    UIWindowScene *windowScene = (UIWindowScene *)scene;
    self.window = [[UIWindow alloc] initWithWindowScene:windowScene];
    self.window.frame = windowScene.coordinateSpace.bounds;

    UITabBarController *tabbarController = [[UITabBarController alloc] init];
    // 第一个界面我们使用 viewController
    ViewController *viewController = [[ViewController alloc] init];
    viewController.view.backgroundColor = [UIColor whiteColor];
    viewController.tabBarItem.title = @"新闻";
    viewController.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/page@2x.png"];
    viewController.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/page_selected@2x.png"];

    UIViewController *controller2 = [[UIViewController alloc] init];
    controller2.view.backgroundColor = [UIColor yellowColor];
    controller2.tabBarItem.title = @"视频";
    controller2.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/video@2x.png"];
    controller2.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/video_selected@2x.png"];

    UIViewController *controller3 = [[UIViewController alloc] init];
    controller3.view.backgroundColor = [UIColor greenColor];
    controller3.tabBarItem.title = @"推荐";
    controller3.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/like@2x.png"];
    controller3.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/like_selected@2x.png"];

    UIViewController *controller4 = [[UIViewController alloc] init];
    controller4.view.backgroundColor = [UIColor lightGrayColor];
    controller4.tabBarItem.title = @"我的";
    controller4.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/home@2x.png"];
    controller4.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/home_selected@2x.png"];
    // tabbarController 设置为四个页面 Controller
    [tabbarController setViewControllers:@[viewController,controller2,controller3,controller4]];
    // nagationController 的容器设置为 tabbarController
    UINavigationController * nagationController = [[UINavigationController alloc] initWithRootViewController:tabbarController];
    // rootViewController 设置为 nagationController
    self.window.rootViewController = nagationController;
    [self.window makeKeyAndVisible];
}
```

## 08. delegate 设计模式

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c704635e370e428a99cf54f76858746d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

此处我们以`UITabBarController`来作为例子，比如我们点击底部 tab 时候，是否要进行切换`viewController`，以及切换完成后，要做什么动作，比如页面刷新，第一个视频进行自动播放诸如此类的（由此可以满足各种各样的自定义的需求逻辑）。

由此设计了相关的协议，暴露方法`shouldSelectViewController`、`didSelectViewController`等方法，在适当的时机由`delegate`进行调用

### 1. delegate 设计模式

1. 设置 self 为 delegate 的接收者，也就是实现方法的对象

   ```objective-c
   tabBar.delegate = self;
   ```

2. 根据需求按需实现方法

   ```objective-c
   - (BOOL)tabBarController:(UITabBarController *)tabBarController ShouldSelectViewController:(UIViewController *)viewCotroller{
     return YES
   }
   - (VOID)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController{
   	// 播放当前 viewController 的第一个视频等等需求
   }
   ```

3. `UITabBarController`举例

   ```objective-c
   @property(nullable, nonatomic, weak)id<UITabBarControllerDelegate> delegate;
   ```

4. 从设计者和使用者来进行对比

   | 设计者                                                                                                                                  | 使用者                                 |
   | --------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
   | 提供一些使用者可以自定义的操作<br />@optional/@requiered 注解<br />提供@property - delegate<br />在对应的时机，让 delegate 执行对应方法 | 设置 delegate = self<br />按需实现方法 |

### 2. 代码示例

1. 修改`SceneDelegate.m`代码如下

   ```objective-c
   // 添加 UITabBarControllerDelegate 调用属性
   @interface SceneDelegate ()<UITabBarControllerDelegate>

   @end
   - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {

     // 在 tabbarController 添加 delegate 属性
     tabbarController.delegate = self; // 添加的

   }
   // 添加方法 didSelectViewController，打印 did selctor 字符串
   - (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController{
       NSLog(@"did selctor");
   }
   ```

2. 运行模拟器后，我们点击 tabBar 中任意一个 tab，即可以在编辑器里看到打印的信息

## 09. 使用 UITableView 实现简单的列表

### 1. 列表

#### 1. 特点

- 数据量大
- 样式比较统一
- 通常需要分组
- 垂直滚动
- 通常可视区只有一个（视图的复用）

#### 2. UITableView

> 包含：tableHeaderView、UITableViewCell、TableFooterView#

#### 3. 代码示例

修改`ViewController.m`，使其显示内容为一个`tableView`

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor =[UIColor whiteColor];

    UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    [self.view addSubview:tableView];
}
```

#### 4. 重新运行模拟器，就可以看到效果

### 2. UITableViewDataSource

> UITableView 作为视图，只负责展示，协助管理，不管理数据，
>
> 需要开发者为`UITableView`提供展示所需要的数据以及`Cell`
>
> 通过`delegate`的模式，开发者需要实现`UITableViewDataSource`

**@required**

- numberOfRowsInSection:(NSInteger)section;
- cellForRowAtIndexPath:(NSIndexPath \*)indexPath;

#### 1. 代码示例

1. 修改`ViewController.m`，使其显示内容为一个`tableView`

   ```objective-c
   @interface ViewController()<UITableViewDataSource> // 新增

   @end

   - (void)viewDidLoad {
       [super viewDidLoad];
       self.view.backgroundColor =[UIColor whiteColor];

       UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
       tableView.dataSource = self; // 新增的
       [self.view addSubview:tableView];
   }
   // 使用 UITableViewDataSource 后，这两个方法必须声明且实现
   - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
       return 20; // 多少个list
   };

   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
       UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"id"];
       cell.textLabel.text = @"主标题";
       cell.detailTextLabel.text=@"副标题";
       cell.imageView.image=[UIImage imageNamed:@"icon.bundle/video@2x.png"];
       return cell;
   };
   ```

2. 上述代码中的`UITableViewCellStyleSubtitle`知识其中一种，还有其他的如下图

   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b342eef3c3e14810b51328abc076a115~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

   3. `UITableView`提供的属性如下图

      <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34727405edf243cbb2aa2af43a8d8b0a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

### 3. UITableViewCell 的复用

> 系统提供复用回收池，根据 reuseIdentifer 作为标识

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca63d84663c42ed9a9640ebb743a039~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 代码实现

1. 在`tableView`中的`cellForRowAtIndexPath`中的方法中取出复用池子的`cell`

   ```objective-c
   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
       UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"id"]; // 先从系统的复用回收池里取出一个
       if(!cell){
           NSLog(@"新创建了");
           // 如果没有，就重新创建
           cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"id"];
       }else{
           NSLog(@"复用了");
       }
       cell.textLabel.text = @"主标题";
       cell.detailTextLabel.text=@"副标题";
       cell.imageView.image=[UIImage imageNamed:@"icon.bundle/video@2x.png"];
       return cell;
   };
   ```

2. 运行模拟器，然后再编辑器控制台中就可以看到打印的信息，上一节中我们创建了 20 个 cell, 滚动后的打印结果如下。

   > 我得模拟器是 8p,我滚动后发现， **新创建了**：打印了 16 次，其余都是打印 **复用的**。由此可以看出这里的优化是起了作用的

### 4. 其他

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54880208141f4b7ea88f5df4e47252dd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 1. NSIndexPath

> 我们可以获得列表中 cell 中某一行的所在 section 以及 row

修改代码如下

```objective-c
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"id"]; // 先从系统的复用回收池里取出一个
    if(!cell){
        NSLog(@"新创建了");
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"id"];
    }else{
        NSLog(@"复用了");
    }
    cell.textLabel.text = [NSString stringWithFormat:@"主标题 - %@ -%@", @(indexPath.section), @(indexPath.row)] ; // 这里新增
    cell.detailTextLabel.text=@"副标题";
    cell.imageView.image=[UIImage imageNamed:@"icon.bundle/video@2x.png"];
    return cell;
};
```

注意：我们此处只有一个 `section`，`section` 始终是 0，`row`是变化的，结果如下：

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1519a8295a724e889576a44094574999~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 2. UITableViewDelegate

- 提供滚动过程中，`UITableViewCell`的出现、消失时机
- 提供`UITableViewCell`的高度、`headers` 以及 `footers` 设置
- 提供 `UITableViewCell` 各种行为的回调（点击、删除等）

代码实现

```objective-c
// UITableViewDataSource, UITableViewDelegate中有很多方法，可以点击跳转定义查看
@interface ViewController()<UITableViewDataSource,UITableViewDelegate> //  新增加 UITableViewDelegate

@end

- (void)viewDidLoad {
  tableView.delegate = self; // 新增加
}
// 设置每一个 cell 的高度
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 100;
}
// 当每一个 row 被选中点击时候触发的回调
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    UIViewController *controller = [[UIViewController alloc]init];
    controller.view.backgroundColor =[UIColor whiteColor];
    controller.title = [NSString stringWithFormat:@"%@", @(indexPath.row)];
    [self.navigationController pushViewController:controller animated:YES];
}
```

### 5. 总结：`UITableView` 基本使用

- 提供最基础的列表类型视图组件
- 提供默认基础的 `UITableViewCell`样式、`header`、`footer`的管理
- 提供针对`UITableViewCell`的复用回收逻辑
- 提供列表基础功能，如点击、删除、插入等
  1. 创建`UITableView`，设置`delegate`和`datasource`，通过两个`delegate`
  2. 选择实现`UITableViewDataSource`中方法，行数、cell 复用
  3. 选择实现`UITableViewDelegate`中的方法（高度、`header`、`footer`、点击等）

## 10. UICollectionView

### 1. 初识 UICollectionView

#### 1. UITableView 的不足

例如下面的需求，

对于左边，如果我们使用`UITableView`还是勉强可以实现的，我们可以把左右两个块当做一个`cell`，然后点击的会后我们判断点击的是 左边 还是 右边，在进行点击后的处理

对于右边，我们就没有办法了，因为他是以一个瀑布流的形式进行展示，左右错落不齐，没有办法进行复用

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d24ec515bc4c0886ab8fe5bec5086e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

#### 2. UICollectionView

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33b03a39f0d9452c9203f6a1818a571b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

- 提供列表复用的容器
- 内置复用回收池
- 支持横向 + 纵向布局
- 更加灵活的布局方式
- 更加灵活的动画
- 更多的装饰视图
- 布局之间的切换

与 `UITableiew`有相同的 API 设计理念 --- 都是基于 datasource 以及 delegate 驱动的

row ====> item : 由于一行可以展示多个视图，row 不能准确的表达

`UICollectioniewDataSource`:

- numberOfItemsInSection:(NSInteger)section;
- cellForItemAtIndexPath:(NSIndexPath \*)indexPath;

`UICollectionViewDelegate`

- willDisplayCell / endDisPlayCell ...
- -(void)collectionView:(UICollectionView _)collectionView didSelectItemAtIndexPath:(NSIndexPath _)indexPath;

`UICollectionViewCell`

- 不提供默认的样式
  - 不是以“行”为设计基础
  - 只有 contentView / backgroundView
  - 继承自`UICollectionReusableView`
- 必须先注册 Cell 类型用于重用
  1. -(void)registerClass:(Class)cellClass forCellWithReuseIdentifier:(NSString \*)identifier;
  2. -(\_\_kindof UICollectionViewCell _)dequeueReusableCellWithReuseIdentifier:(NSString _)identifier forIndexPath:(NSIndexPath \*)indexPath;

#### 3. 代码实现

1. 新建 new File => 选择 Cocoa Touch Class => next => 选择 class:`GTVideoViewController`,Subclass of `UIViewController` ，这样我们新创建了`GTVideoViewController.h`和`GTVideoViewController.m`文件

2. `GTVideoViewController.m`文件修改内容如下

   ```objective-c
   #import "GTVideoViewController.h"
   @interface GTVideoViewController ()<UICollectionViewDelegate,UICollectionViewDataSource>
   @end

   @implementation GTVideoViewController
   -(instancetype) init{
       self = [super init];
       if(self){
           self.tabBarItem.title = @"视频";
           self.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/video@2x.png"];
           self.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/video_selected@2x.png"];
       }
       return self;
   }
   - (void)viewDidLoad {
       [super viewDidLoad];
       self.view.backgroundColor = [UIColor whiteColor];
       UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];

       UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
       collectionView.delegate = self;
       collectionView.dataSource = self;
       [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"UICollectionViewCell"];

       [self.view addSubview:collectionView];
   }

   - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{
       return 200;
   };

   - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
       UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"UICollectionViewCell" forIndexPath:indexPath];
       cell.backgroundColor = [UIColor redColor];
       return cell;
   };
   @end
   ```

3. 修改`SceneDelegate.m`文件，内容如下

   ```objective-c
   #import "GTVideoViewController.h" // 新增
   
   - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
     // 把第二个 tab 视频页修改为新创建的 GTVideoViewController 实现的页面，并且删除之前的
     UIViewController *videoController = [[GTVideoViewController alloc] init];
    // ---------------------start:删除即可--------------------
    // UIViewController *controller2 = [[UIViewController alloc] init];
    // controller2.view.backgroundColor = [UIColor yellowColor];
    // controller2.tabBarItem.title = @"视频";
    /// controller2.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/video@2x.png"];
    // controller2.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/video_selected@2x.png"];
    // ---------------------end:删除即可--------------------
   
    [tabbarController setViewControllers:@[viewController,videoController,controller3,controller4]];
   }
   ```

### 2. UICollectionViewLayou

> 用于生成 UICollectionView 布局信息的抽象类

#### 1. UICollectionViewLayoutAttributes

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cfdc8222240457b8b2669a99e110e56~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

> 属性有：frame、center、size、transform3D、bounds等等

* `UICollectionView` 提供基本的容器、滚动、复用功能
* 布局信息完全交给开发者
* 作为抽象类，业务逻辑需要继承
* 实现 `UICollectionViewLayout`(UISubclassingHooks)中的方法
* 开发者可以自定义生成 attributes，系统通过此进行布局
* 系统提供默认的流式布局 Layout

#### 2. UICollectionViewFlowLayout

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b4fd878aaca4d2abdc31df0dfbdf6af~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 25%;" />

> 流式布局，每行排满后自动换行

1. `minimumInteritemSpacing`、`minimumLineSpacing`、`itemSize`
2. `UICollectionViewDelegateFlowLayout`：根据 `inexPath` 做更细化的自定义样式

#### 3. 代码实现

1. 修改 `GTVideoViewController.m`文件

   ```objective-c
   - (void)viewDidLoad {
       [super viewDidLoad];
       self.view.backgroundColor = [UIColor whiteColor];
       UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
       flowLayout.minimumLineSpacing = 10; // 新增的，注意
       flowLayout.minimumInteritemSpacing = 20; // 新增的
       flowLayout.itemSize = CGSizeMake((self.view.frame.size.width - 30)/2, 300); // 新增的
       
       UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
       collectionView.delegate = self;
       collectionView.dataSource = self;
       [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"UICollectionViewCell"];
   
       [self.view addSubview:collectionView];
   }
   
   // 通过实现此方法可以实现每一个 item 的具体信息
   - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath{
       if(indexPath.item %3 == 0){
           return CGSizeMake(self.view.frame.size.width, 100);
       }else{
           return CGSizeMake((self.view.frame.size.width - 20)/2, 300);
       }
   };
   ```

2. 运行模拟机后，可以看到如下效果

   <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b08e5a74134725be5bab1066bc55b4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

3. 注意：minimumInteritemSpacing 是一个最小值的设置，假如屏幕有 700，每一个item 设置为 300 ,那么两块中间就有 100 的间隙，设置的值小于这个值时候系统也会按照间隙 100 处理。

### 3. UICollectionView 基本使用

#### 1. 基本使用

* 提供灵活的、可定制的列表类型视图组件
* 提供默认基础的 Flow 样式布局
* 提供针对 UICollectionView 的复用回收逻辑
* 提供列表其他功能，如点击、删除、插入以及布局的切换等
  1. 创建 UICollectionViewLayout,使用系统默认流式布局，或者自定义布局
  2. 创建 UICollectionView,设置 delegate 和 dataSource，注册 cell 类型
  3. 选择实现 UICollectionViewDataSource 中方法，行数、cell 复用
  4. 选择实现 UICollectionViewDelegate 中方法（点击，滚动等）

#### 2. 列表的选择与使用

* UITableView 其实算是特殊 Flow 布局的 UICollectionView
* 简单的列表仍然可以使用 UITableView
* 有双向的布局，特殊布局等非普通场景（瀑布流、弹幕）
* Layout的切换，在选择屏幕时有优雅的动画

## 11. UIScrollView

> 通过查看`UITableView`、`UICollectionView`的定义就可以看到，他们均继承于`UIScrollView`
>
> 通过下图，可以初步了解一些相关属性

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da3f85d54714dc2a3fba9dda059a36a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 25%;" />

### 1. 初识 UIScrollView

> 同步上图可以看到它的一些属性

1. 新建 new File => 选择 Cocoa Touch Class => next => 选择 class:`GTRecommendViewController`,Subclass of `UIViewController` ，这样我们新创建了`GTRecommendViewController.h`和`GTRecommendViewController.m`文件

   ```objective-c
   // GTRecommendViewController.m 
   #import "GTRecommendViewController.h"
   
   @interface GTRecommendViewController ()
   
   @end
   
   @implementation GTRecommendViewController
   -(instancetype)init{
       self = [super init];
       if(self){
           self.tabBarItem.title = @"推荐";
           self.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/like@2x.png"];
           self.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/like_selected@2x.png"];
       }
       return self;
   }
   
   - (void)viewDidLoad {
       [super viewDidLoad];
       self.view.backgroundColor = [UIColor whiteColor];
       
       UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];
       scrollView.backgroundColor = [UIColor lightGrayColor];
       // 我们设置它的总体宽度为 5倍 屏幕宽
       scrollView.contentSize = CGSizeMake(self.view.bounds.size.width * 5, self.view.bounds.size.height);
       scrollView.showsHorizontalScrollIndicator = NO; // 是否显示水平方向滚动条
       scrollView.pagingEnabled = YES; // 可以实现翻页的效果
       NSArray *colorArr = @[[UIColor redColor], [UIColor blueColor], [UIColor yellowColor], [UIColor lightGrayColor], [UIColor grayColor]];
       for(int i=0;i<5;i++){
          // 添加五个不同颜色的屏幕宽度的的view,x轴偏移位置依次增加，这样翻页时候我们就可以看到不同的颜色块 
           [scrollView addSubview:({
               UIView *view = [[UIView alloc] initWithFrame:CGRectMake(scrollView.bounds.size.width * i, 0, scrollView.bounds.size.width, scrollView.bounds.size.height)];
               view.backgroundColor = [colorArr objectAtIndex:i];
               view;
           })];
       }
       [self.view addSubview: scrollView];
   }
   @end
   ```

2. 修改`SceneDelegate.m`文件，内容如下

   ```objective-c
   #import "GTRecommendViewController.h" // 新增
   
   - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
     // --------------start:删除---------------------
   	// UIViewController *controller3 = [[UIViewController alloc] init];
   	// controller3.view.backgroundColor = [UIColor greenColor];
   	// controller3.tabBarItem.title = @"推荐";
   	// controller3.tabBarItem.image = [UIImage imageNamed:@"icon.bundle/like@2x.png"];
   	// controller3.tabBarItem.selectedImage = [UIImage imageNamed:@"icon.bundle/like_selected@2x.png"];
     // --------------end:删除---------------------
     
      GTRecommendViewController *recommendController = [[GTRecommendViewController alloc] init];
    
      [tabbarController setViewControllers:@[viewController,videoController,recommendController,controller4]];
     
   }
   ```

3. 运行手机模拟器，滑动 x 轴，可以看到滚动翻页的效果

### 2.深入 UIScrollView： UIScorllViewDelegate

* **滚动**：监听页面滚动，以及根据 Offset 做业务逻辑
  * -(void)scrollViewDidScroll:(UIScrollView *)scrollView:
* **拖拽**：中断一些业务逻辑，如视频/gif播放
  * -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; 
  * -(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
* **减速**：页面停止时开始逻辑，如视频自动播放
  * -(void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;
  * -(void)scrollDidEndDecelerating:(UIScrollView *)scrollView;

**代码实现如下**

```objective-c
// GTRecommendViewController.m 文件
@interface GTRecommendViewController ()<UIScrollViewDelegate> // 新增 UIScrollViewDelegate
- (void)viewDidLoad {
  
  scrollView.delegate = self;
  
}
- (void)scrollViewDidScroll:(UIScrollView *)scrollView{
    NSLog(@"scrollViewDidScroll-y-%@",@(scrollView.contentOffset.y)); 
		NSLog(@"scrollViewDidScroll-x-%@",@(scrollView.contentOffset.x));
}
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{
    NSLog(@"scrollViewWillBeginDragging");
}
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{
    NSLog(@"scrollViewDidEndDragging");
}
- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView{
}
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{
}
```

运行模拟机后，滑动页面，即可以看到控制台中的打印信息

## 12.UIscrollView 实战场景

UIKit中的滚动视图，如下图：

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811b21aa14e74a1ea9e07e02108c0165~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 25%;" />

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06f179446e834e3796fef5bfa78ea6c8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 25%;" />

## 13. 利用 UILabel 让列表展示文字

> UILabel: 展示一行或者多行只读文字的视图

* text：@”IOS开发“
* font: UIFont (大小、粗体、斜体)
* textColor: 文字颜色
* textAlignment: 对齐方式（居中、左对齐、右对齐）
* numberOfLines: 最大展示行数
* lineBreakMode: 
  * NsLineBreakByClipping
  * NsLineBreakByTruncatingMiddle
  * NSLineBreakByTruncating Tail
  * NSLineBreakTruncatingHead
* -(void)sizeToFit;
  1. 固定大小的，通过展示行数截断
  2. 可变大小使用 sizeToFit 确定大小
  3. 从固定方向顺序逐一布局

### UILabl

* 替换 UITableViewCell 中的默认布局样式，使用自定义 UILabel 进行复杂布局
* 后期学习：展示复杂样式的文字---NSAttributedString

**代码展示**

1. 新建 new File => 选择 Cocoa Touch Class => next => 选择 class:`GTNormalTableViewCell`,Subclass of `UITableViewCell` ，这样我们新创建了`GTNormalTableViewCell.h`和`GTNormalTableViewCell.m`文件

2. 修改`GTNormalTableViewCell.h`暴露一个方法

   ```objective-c
   #import <UIKit/UIKit.h>
   
   NS_ASSUME_NONNULL_BEGIN
   
   @interface GTNormalTableViewCell : UITableViewCell
   -(void)layoutTableViewCell; // 这个方法是暴露的方法
   @end
   
   NS_ASSUME_NONNULL_END
   ```

3. 修改`GTNormalTableViewCell.m`文件，内容如下

   ```objective-c
   #import "GTNormalTableViewCell.h"
   
   @interface GTNormalTableViewCell()
   @property(nonatomic, strong, readwrite) UILabel *titleLabel;
   @property(nonatomic, strong, readwrite) UILabel *sourceLabel;
   @property(nonatomic, strong, readwrite) UILabel *commentLabel;
   @property(nonatomic, strong, readwrite) UILabel *timeLabel;
   
   @end
   
   @implementation GTNormalTableViewCell
   
   - (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier{
       self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
       if(self){
           [self.contentView addSubview:({
               self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 15, 300, 50)];
               self.titleLabel.font = [UIFont systemFontOfSize:16];
               self.titleLabel.textColor = [UIColor blackColor];
               self.titleLabel;
           })];
           
           [self.contentView addSubview:({
               self.sourceLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 80, 50, 20)];
               self.sourceLabel.font = [UIFont systemFontOfSize:12];
               self.sourceLabel.textColor = [UIColor grayColor];
               self.sourceLabel;
           })];
           [self.contentView addSubview:({
               self.commentLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 80, 50, 20)];
               self.commentLabel.font = [UIFont systemFontOfSize:12];
               self.commentLabel.textColor = [UIColor grayColor];
               self.commentLabel;
           })];
           [self.contentView addSubview:({
               self.timeLabel = [[UILabel alloc] initWithFrame:CGRectMake(150, 80, 50, 20)];
               self.timeLabel.font = [UIFont systemFontOfSize:12];
               self.timeLabel.textColor = [UIColor grayColor];
               self.timeLabel;
           })];
       }
       return self;
   }
   -(void)layoutTableViewCell{
       self.titleLabel.text = @"极客时间IOS开发";
       self.sourceLabel.text = @"极客时间";
       [self.sourceLabel sizeToFit];
       
       self.commentLabel.text = @"1888评论";
       [self.commentLabel sizeToFit];
       self.commentLabel.frame = CGRectMake(self.sourceLabel.frame.origin.x + self.sourceLabel.frame.size.width + 15, self.commentLabel.frame.origin.y, self.commentLabel.frame.size.width, self.commentLabel.frame.size.height);
       
       self.timeLabel.text = @"三分钟前";
       [self.timeLabel sizeToFit];
       self.timeLabel.frame = CGRectMake(self.commentLabel.frame.origin.x + self.commentLabel.frame.size.width + 15, self.timeLabel.frame.origin.y, self.timeLabel.frame.size.width, self.timeLabel.frame.size.height);
   }
   
   @end
   ```

4. 修改`ViewController.m`文件，内容如下

   ```objective-c
   #import "GTNormalTableViewCell.h" // 新增
   
   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
      	// 造成继承的 UITableViewCell 改为 GTNormalTableViewCell
     	GTNormalTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"id"]; // 先从系统的复用回收池里取出一个
       if(!cell){
           NSLog(@"新创建了");
           // 这里也改为 GTNormalTableViewCell
           cell = [[GTNormalTableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"id"];
       }else{
           NSLog(@"复用了");
       }
     	// 使用暴露的 layoutTableViewCell 方法
       [cell layoutTableViewCell];
       return cell;
   };
   ```

5. 重新运行，可以看到如下效果

   <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91ed36ab7ed4d028be248cee5a6fa3f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

## 14. 使用UIImageView在列表展示图片

> UIImage: 管理图片数据的对象

### 1. 基本概念

* UIImage 的使用场景

  * 通过 UIImageView 的视图展示

  * 系统封装视图的图片展示

  * 在上下文中绘制

* 常用的图片类型：png、jpeg、pdf...

* 在IOS 中，图片数据都会被封装成 `UIImage`

  ```objective-c
  (nullalbe UIImage *)imageNamed:(NSString *)name; // load from main bundle
  (nullable UIImage *)imageWithContentsOfFile:(NSString *)path;
  (nullable UIImage *)imageWithData:(NSData *)data;
  (UIImage *)imageWithCGImage:(CGImageRef)cgImage;
  ```

* 图片数据的存储与管理（后续课程）

### 2. 展示一张或者一组图片的视图

* 展示一张静态图片

  ```objective-c
  UIImageView.image = UIImage
  ```

* 展示一组静态图片，成为动图

  ```objective-c
  UIImageView.animationImages = @[UIImage, UIImage, ...]
  UIImageView.animationDuration = 1
  [UIImageView startAnimating]
  ```

### 3. UIViewContentMode

> 当图片尺寸和 UIImageView 尺寸不符的时候，自定义填充方式

* ToFill
* AspectFill
* AspectFit
* TopLeft
* BottomRight
* Center
* ...  

### 4. 本节实现功能

* 替换 UITableViewCell 中的默认布局样式
* 使用自定义 UIImageView 进行复杂布局

### 5. 代码实现

修改`GTNormalTableViewCell.m`文件，内容如下

```objective-c
@interface GTNormalTableViewCell()

@property(nonatomic, strong, readwrite)UIImageView *rightImageView;// 新增加
@end

- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier{

  // 最后增加一列
  
  [self.contentView addSubview:({
    self.rightImageView = [[UIImageView alloc] initWithFrame:CGRectMake(330, 15, 70, 70)];
    self.rightImageView.contentMode = UIViewContentModeScaleToFill;
    self.rightImageView;
  })];
   return self;
}


-(void)layoutTableViewCell{
  self.rightImageView.image = [UIImage imageNamed:@"icon.bundle/icon.png"]; // 新增加
}
```

运行模拟器，效果如下

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0bb8b752574e48912dc21ca7fafc85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

## 15. iOS中的按钮、点击和手势 

### 1. UIButton

> 可以展示文字、图片，不止有静态的展示功能，同时增加了用户交互（响应用户的点击、拖拽等开发者自定义业务）

#### 1. 相关属性

* 默认的 `UIButton`提供 `imageView`和`titleLabel`的基本布局
* 通过设置`enabled`/`selected`/`highlighted`改变基本状态
* 在每种状态下都有对应的视图
* 可以忽略默认视图，直接自定义`subView`

#### 2. 代码实现

1. 修改`GTNormalTableViewCell.m`文件，内容如下

```objective-c
@interface GTNormalTableViewCell()

@property(nonatomic,strong,readwrite)UIButton *deleteButton; // 新增加
@end
  
- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier{
  
   // 添加一个 button 按钮在视图中
   [self.contentView addSubview:({
     self.deleteButton = [[UIButton alloc] initWithFrame:CGRectMake(290, 80, 30, 20)];
     [self.deleteButton setTitle:@"X" forState:UIControlStateNormal];// 默认显示 X
     [self.deleteButton setTitle:@"V" forState:UIControlStateHighlighted]; // 点击的时候显示 V
     self.deleteButton.backgroundColor = [UIColor blueColor];
     self.deleteButton;
   })];
  return self;
}
```

2. 运行模拟器，效果如下

   <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67e3dc50c39a4f478cf4235dbead70ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

### 2. Target-Action

#### 1. 相关概念

* 当某个事件触发时，调用对应 target 对象的相应方法

* 传值的限制比较多

  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6832efa5c6645e783e87f03e7e4b951~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 50%;" />

  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100a3b594e6945c19b52b9b972b08637~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

* UIButton 通过 `Target-Action`的模式，处理点击逻辑
* 系统封装用户操作事件
* 对应事件开发者实现自定义的方法

#### 2. 代码实现

修改`GTNormalTableViewCell.m` 文件 ，内容如下

```objective-c
- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier{
	[self.contentView addSubview:({
    
    // 新增加
    // 当我按钮点击时候，self.deleButton 会调用 self 的 deleButtonClick 方法
    [self.deleteButton addTarget:self action:@selector(deleButtonClick) forControlEvents:UIControlEventTouchUpInside];

  })  
}

// 新增加
-(void)deleButtonClick{
    NSLog(@"deleButtonClick");
}
```

重新运行模拟器，点击按钮可以看到打印的信息`deleButtonClick`

#### 3. UIControl

通过查看`UIButton`的定义，我们可以看到 `UIButton`继承于`UIControl`,`UIControl`又继承于`UIView`

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf50e64dcfc464aacc865ba13ae2735~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom: 33%;" />

### 3. UIGestureRecognizer

> 识别用户在屏幕中的触摸

#### 1. 手势封装方法

* UITapGestureRecognizer
* UIPinchGestureRecognizer
* UIRotationGestureRecognizer
* UISwipeGestureRecognizer
* UIPanGestureRecognizer
* UILongPressGestureRecognizer

#### 2. 创建步骤

可以在任何视图上，增加一个或者多个手势，系统自动识别手势，开发者自定义相应逻辑，采用 Target-Action 方式进行处理,步骤

1. 创建手势
2. 设置响应处理
3. 在视图中添加

#### 3. 代码实现

修改`GTRecommendViewController.m`文件，内容如下

```objective-c
- (void)viewDidLoad {
   
  
   for(int i=0;i<5;i++){
     [scrollView addSubview:({
       UIView *view = [[UIView alloc] initWithFrame:CGRectMake(scrollView.bounds.size.width * i, 0, scrollView.bounds.size.width, scrollView.bounds.size.height)];
            
       // --------------start: 新增加的-------------------
       [view addSubview:({
         // 添加一个view,并添加一个定义事件
         UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 100)];
         view.backgroundColor = [UIColor purpleColor];
         UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(viewClick)];
         [view addGestureRecognizer:tapGesture];
         view;
       })];
       // --------------end: 新增加的-------------------
            
       view.backgroundColor = [colorArr objectAtIndex:i];
       view;
     })];
   }
  
 
}
// 实现这个方法
-(void)viewClick{
    NSLog(@"viewClick");
}
```

运行模拟器，底部导航切换到 推荐 位，点击屏幕中的 紫色方块，就可以在控制台看到打印的信息

### 4. UIGestureRecognizerDelegate

#### 1. 手势的不同阶段：`UIGestureRecognizerState`

* `UIGestureRecognizerStatePossible`

* `UIGestureRecognizerStateBegan`
* `UIGestureRecognizerStateChanged`
* `UIGestureRecognizerStateEnded`
* `UIGestureRecognizerStateCancelled`
* `UIGestureRecognizerStateFailed`

* 通过 Delegate 的方式，扩展在手势识别过程中的自定义操作
  * 是否响应手势
  * 是否支持多手势
  * 多个手势冲突时如何处理

#### 2. 代码实现

修改`GTRecommendViewController.m`文件，如下

```objective-c
@interface GTRecommendViewController ()<UIScrollViewDelegate, UIGestureRecognizerDelegate> // 新增 UIGestureRecognizerDelegate

@end
  
- (void)viewDidLoad {
  for(int i=0;i<5;i++){
        [scrollView addSubview:({
            UIView *view = [[UIView alloc] initWithFrame:CGRectMake(scrollView.bounds.size.width * i, 0, scrollView.bounds.size.width, scrollView.bounds.size.height)];
            
            [view addSubview:({
                UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 100)];
                view.backgroundColor = [UIColor purpleColor];
                UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(viewClick)];
                tapGesture.delegate = self; // 新增加
                [view addGestureRecognizer:tapGesture];
                view;
            })];
            
            view.backgroundColor = [colorArr objectAtIndex:i];
            view;
        })];
    }
}

//  新增加的方法
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    // 这里设置为 NO 后在进行点击，上面的 viewClick 方法不会执行
    // 重新设置为 YES 后，再次点击事件会恢复执行
    return NO;
}
```

运行模拟器，再次点击上节中的紫色方块可以看到，在 `gestureRecognizerShouldBegin`中返回`NO`时，控制台并没有打印信息，重新改为`YES`运行后，再次点击信息可以打印。

## 16. 展示一个提醒弹窗

> UIAlertView，在新版本中已经被 deprecated

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b38675c46ce848cba86c145c95cdc1c1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

* 通过 UIView、UILabel、UIButton可以组装成任何复杂的支持交互的视图组件

* 组件内封装基本逻辑，开发者提供需要展示的数据，将基本逻辑中的可定制业务，封装`Delegate`

### 1. UIAlertView 的基本封装逻辑

* **组件内封装基本逻辑**
  1. 创建 View、Label、Button以及分割线
  2. 设置基本的样式、字体大小等
  3. 内置 Button 点击手势，取消隐藏
* **开发者提供需要展示的数据**
  1. 主标题文字、副标题文字
  2. 按钮文字
* **将基本逻辑中的可定制业务，封装Delegate**
  1. 点击按钮之后的业务逻辑
  2. 展示 AlertView 前后的处理逻辑

### 2. UIKit 使用

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e3bd51fe864d1cbbabee7042a50309~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />

1. **提供构建App最核心的模块**

   > 主要处理提供视图展示内容，以及和用户的交互

2. **基于MVC的设计模式**

   > 系统封装视图和逻辑，开发者提供数据驱动

3. **交互**

   > 通过 `Delegate` 方式或者 `Target-Action` 方式

## 17.使用 WKWebView 展示网页与内容

### 1. Web 基础知识

> 网络请求 + 解析渲染

#### 1. 历史版本

**UIWebView(ios 2.0 - 12.0)**

* 内存系统性泄漏
* 系统 OOM 较多
* 稳定性较差
* WebCore 和 JSCore Crash 较多
* 对 HTML5 和 CSS3 支持较少

**WKWebView(ios 8+)**

* 独立进程，内存
* Crash 不影响主 App
* 对 HTML 和 CSS 更好的支持
* 采用 JIT 技术

#### 2. 使用 WKWebView

* **WebKit 框架**
  * WebKit 是一个开源的 Web 浏览器引擎
  * 对于 iOS 中的 WebKit.framework 就是在 WebCore、底层桥接、JSCore 引擎等核心模块的基础上，针对 iOS 平台的项目封装

* 基本的加载

  * 通过 configuration 进行基本访问
  * 加载 URL & HTML
  * 类比之前的 UIKit 提供基础的功能，在 delegate 中处理业务逻辑

  ```objective-c
  -(instancetype) initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration;
  -(nullable WKNavigation *)loadRequest:(NSURLRequest *)request;
  -(nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
  ```

* Configuration

  * 基本的共享 Cookie 设置
  * 基础偏好设置
  * 播放视频设置
  * 默认 JS 注入

#### 3. WKWebView Delegates

| 类别                 | 回调方式                                  | 说明                                                  |
| -------------------- | ----------------------------------------- | ----------------------------------------------------- |
| WKNavigationDelegate | **decidePolicyForNavigationAction**       | 是否加载请求（scheme拦截、特殊逻辑、JS和Native 通信） |
|                      | **didFinishNavigation**                   | webView 完成加载（业务逻辑）                          |
|                      | **didFailNavigation**                     | webView 加载失败（loadingView 展示，重试按钮等）      |
|                      | **webViewWebContentProcessDidTerminate**  | webView Crash 回调（自动重新加载）                    |
| WKUIDelegate         | **runJavaScriptAlertPanelWithMessag**     | 处理 alert() 自定义样式                               |
|                      | **runJavaScriptConfirmPanelWithMessage**  | 处理 confirm() 自定义样式                             |
|                      | **runJavaScriptTextInputPanelWithPrompt** | 处理 prompt() 自定义样式                              |

### 2. 代码实现

#### 1. 新加载一个页面

1. 新建 new File => 选择 Cocoa Touch Class => next => 选择 class:`GTDetailViewController`,Subclass of `UIViewController` ，这样我们新创建了`GTDetailViewController.h`和`GTDetailViewController.m`文件, 实现上节中的列表点击跳转进入

2. 修改`GTDetailViewController.m`文件，内容如下

   ```objective-c
   #import "GTDetailViewController.h"
   #import <Webkit/WebKit.h> // 引入 webkit
   
   @interface GTDetailViewController ()
   @property(nonatomic,strong,readwrite) WKWebView *webView;
   @end
   
   @implementation GTDetailViewController
   
   - (void)viewDidLoad {
       [super viewDidLoad];
     	// 添加 webview
       [self.view addSubview:({
           self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 88, self.view.frame.size.width, self.view.frame.size.height - 88)];
           self.webView;
       })];
     	// 设置 webview 打开地址
       [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"https://time.geekbang.org/"]]];
   }
   
   @end
   ```

3. 修改 导航首页 list 页面点击效果

   ```objective-c
   #import "GTDetailViewController.h" // 新增
   
   // 修改点击回调方法
   - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
   //    UIViewController *controller = [[UIViewController alloc]init];
   //    controller.view.backgroundColor =[UIColor whiteColor];
   //    controller.title = [NSString stringWithFormat:@"%@", @(indexPath.row)];
   //    [self.navigationController pushViewController:controller animated:YES];
       
       GTDetailViewController *controller = [[GTDetailViewController alloc]init];
       controller.view.backgroundColor =[UIColor whiteColor];
       controller.title = [NSString stringWithFormat:@"%@", @(indexPath.row)];
       [self.navigationController pushViewController:controller animated:YES];
   }
   ```

4. 重新运行模拟器，点击列表进行详情，可以看到加载的页面内容

#### 2. 使用 WKWebView Delegates

1. 修改`GTDetailViewController.m`文件

```objective-c
@interface GTDetailViewController ()<WKNavigationDelegate> // 引入 WKNavigationDelegate
  
- (void)viewDidLoad {
    [super viewDidLoad];
    [self.view addSubview:({
        self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 88, self.view.frame.size.width, self.view.frame.size.height - 88)];
        self.webView.navigationDelegate = self; //  新增加
        self.webView;
    })];
    [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"https://time.geekbang.org/"]]];
}
// -------------start:新增加--------------------------------
// 是否加载，使用 decisionHandler 回调方法来进行特殊处理
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{
    NSLog(@"decidePolicyForNavigationAction");
    decisionHandler(WKNavigationActionPolicyAllow);
}
// 页面加载完成后的回调
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation{
    NSLog(@"didFinishNavigation");
}
// -------------end:新增加-------------------------------- 
```

#### 3. 总结：使用 WKWebView流程

1. 创建 WKWebView
2. 设置 Delegate 以及样式、JS 注入等
3. 加载 URL 或者 HTML 字符串
4. 在相应的回调中处理业务逻辑<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8377a7176224c1abd84fb4e0546b7e8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:33%;" />



