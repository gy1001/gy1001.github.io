# 编程必备基础

> 计算机组成原理+操作系统+计算机网络
>
> 计算机基础——更适合程序员的编程必备基础知识
>
> 文科生都能听懂学会／比大学课程学习体验更好／更贴近实际工作内容
>
> 60% 理论 + 30% 实践 + 10% 习题

## 1. 导论

### 1.1 计算机系必须专业课

计算机组成原理+操作系统+计算机网络 +（数据结构）

### 1.2 课程的目的

- 帮助大家形成计算机知识的结构体系
- 帮助大家理解计算机底层原理
- 帮助大家在工作实践中借鉴其中的优秀设计

### 1.3 学习这门可课程的原因

#### 1.3.1 互联网公司笔/面试逃不开的知识点

- 通过面试/笔试去考察同学的计算机基础知识
- 不是为了应付面试和笔试
- 关注自身方面技能的提升

#### 1.3.2 填补内容稀缺，补全短板

- 大家往往喜欢从项目入手，容易忽略后台和底层基础
- 线上关于基础知识的综合课程甚少

### 1.4 课程特点：

#### 1.4.1 内容扎实、夯实基础

- 课程内容是大学计算机系里面最重要的科目
- 目的是帮助大家夯实计算机基础知识

#### 1.4.2 知行合一、结合实践

- 为了避免学习过程的枯燥，课程加入了丰富的实践内容
  - 实践内容：缓存置换算法、线程池/异步任务、网络嗅探工具、也会穿插一些小实践

#### 1.4.3 内容重组、贴近实际

- 对内容进行了重组，突出重点，更加符合实际需求
  - 比如计算机组成原理部分，会摒弃硬件内容，专注软件逻辑与理论

#### 1.4.4 图解丰富、帮助理解

- 课程 PPT 做了很多非常多的工作，丰富的图解帮助内容的理解

### 1.5 环境说明

- Linux 环境：VMWare WorkStation + Linux 虚拟机
- 编程语言：C++, Phython

## 2. 计算机组成原理：概述篇

### 2.1 章节导学

- 计算机的发展简史
- 计算机的分类
- 计算机的体系结构
- 计算机的层次与编程语言
- 计算机的计算单位
- 计算机的字符与编码集

### 2.2 计算机发展简史

#### 2.2.1 计算机发展的四个阶段

1. 1946-1957 年：第一阶段，电子管计算机
2. 1957-1964 年：第二阶段，晶体管计算机
3. 1964-1980 年：第三阶段：集成电路计算机
4. 1980- 现 在：第四阶段：超大规模集成电路计算机

##### 2.2.1.1 第一个阶段：电子管计算机

电子管如图

<img src="https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/iiM3Ef.png" alt="image" style="zoom:50%;" />

1. 第二次世界大战是电子管计算机产生的催化剂：英国为了解密德国海军的密文

2. 计算机：埃尼亚克（ENIAC）

   - 出现的其他原因：

     - 战争使用了飞机和火箭
     - 打得准则需要计算射击参数
     - 射击参数需要几千次运算才能计算出来：（没有计算机前，需要人手算）

   - 内部构造
     - 18000 多个电子管
     - 运行耗电量 150 千瓦
     - 重量达 30 吨，占地 1500 平方英尺

3. 这个时期电子计算机的特点

   - 集成度小，占用空间大
   - 功耗高，运行速度相对慢
   - 操作复杂，更换程序时候需要重新接线

##### 2.2.1.2 第二个阶段：晶体管计算机

晶体管如图

<img src="https://pic.baike.soso.com/ugc/baikepic2/11234/cut-20180402112439-1223140248_jpg_2197_1464_388950.jpg/800" alt="image" style="zoom:70%;" />

1.  促使其发生的原因：贝尔实验室的三个科学家发明了晶体管

2.  著名的晶体管计算机：TX-0（诞生于 MIT 林肯实验室）、PDP-1（4k 内存，每秒可执行 200,000 指令，配备 512\*512 的显示器）

3.  这个时期电子计算机的特点

    - 集成度相对较高，空间占用相对较小

    - 功耗相对较低，运行速度较快

    - 操作相对简单，交互更加方便

##### 2.2.1.3 第三个阶段：集成电路计算机

集成电路计算机

<img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164654747-1929671686.png" alt="image" style="zoom:50%;" />

1. 促使其发生的原因：德州仪器的工程师发明了集成电路(IC)
2. 这时候计算机的特点
   - 计算机变得更小
   - 功耗变得更低
   - 计算速度变得更快
   - 此时：计算机具备了进入千家万户的条件
3. 这时候产生了操作系统
   - IBM 有两款计算机 7094、1401 卖的非常好，但是它们**主打功能不同**、**相互无法兼容**、**不愿意投入两组人力**，IBM 为了解决这个问题，推出了兼容的产品 System/360：它就是操作系统的雏形

##### 2.2.1.4 第四个阶段：超大规模集成电路计算机

1. 这时候计算机的特点
   - 一个芯片集成了上百万的晶体管
   - 速度更快，体积更小，价格更低，更能被大众接受
   - 用途丰富：文本处理、表格处理、高交互的游戏与应用
2. 不得不提的乔布斯
   - Apple 和 Apple 二代

##### 2.2.1.5 第五个阶段：未来的计算机(畅想篇)

###### 2.2.1.5.1 生物计算机

1. 以蛋白质分子作为主要原材料
2. 这时候计算机的特点
   - 提交小，效率高
   - 不易损坏，生物级别的自动修复
   - 不受信号干扰，无热损耗

###### 2.2.1.5.2 量子计算机

1. 遵循量子力学的物理计算机
2. 目前的研究成果
   - 2013 年 5 月，谷歌和 NASA 发布 D-Wave Two
   - 2017 年 5 月，中国科学院宣布制造出光量子计算机
   - 2019 年 1 月，IBM 展示了世界首款商业化量子计算机
   - 腾讯在 2017 年就组建了量子实验室
   - 阿里巴巴在 2017 年成立了达摩院
   -

#### 2.2.2 微型计算机的发展历史

> 主要从计算机发展历史的第三个阶段以后开始

1. 受限于性能：单核 CPU

<img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164748407-2075696834.png" alt="image" style="zoom:50%;" />

2. 关于 CPU 的性能，有一个著名的定律——**摩尔定律：集成电路的性能，每 18~24 个月就会提升一倍**。进入 21 世纪后，随着芯片的发展，芯片里面的电路越来越复杂，越来越密集，并且热损耗也越来越高，我们没有办法解决这样的问题，因此，该定律慢慢失效了。

3. 受限于单核 CPU 的性能瓶颈，于是发展出了多核 CPU。

 <img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164808683-1865841507.png" alt="image" style="zoom:50%;" />

#### 2.2.3 参考文档

[计算机发展历史](https://www.cnblogs.com/jvStarBlog/p/11941499.html)

### 2.3 计算机的分类

#### 2.3.1 超级计算机

1. 特点
   - 功能最强、运算速度最快、存储容量最大的计算机
   - 多用于国家高科技领域和尖端技术研究
   - 标记它们的运算速度的单位是 TFlop/s（1TFlop/s=每秒一万亿次浮点计算）
2. 截至 2018 年 11 月，全世界超级计算机排名前三的见下图。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909171618101-1832074648.png)

为什么神威太湖之光的处理器个数远超 Summit，但算力还没有 Summit 高呢？这是因为神威太湖之光采用的全部是拥有自主知识产权的国产芯片。

3. 截至 2018 年 11 月，中国范围内排名前三的超级计算机

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a517b9cfa5294f85a4ad7989a771b612~tplv-k3u1fbpfcp-watermark.image?)

#### 2.3.2 大型计算机

- 又称为大型机、大型主机、主机等
- 具有高性能、可处理大量数据与复杂的运算
- 在大型机市场领域，IBM 占据着很大的份额
- 不得不提，去 IOE 行动：I 指 IBM(服务器提供商)、O 指 Oracle(数据库软件提供商)、E 指 EMC(存储设备提供商)。去 IOE 行动是阿里巴巴在 2008 年提出的概念，因为 IOE 代表了高维护费用的存储系统，并且也不够灵活，伸缩性弱

#### 2.3.3 迷你计算机(服务器)

> 迷你计算机，也称为小型机、普通服务器，具备不错的算力，可以完成较复杂的运算。它不像之前的超级计算机和大型计算机，很多公司（像华为、浪潮、联想等）都可以制造。现代背景下，很多公司已经将传统的大型机替换成了普通服务器，成为大规模企业计算的中枢。云服务厂商（比如阿里云、腾讯云等），也是使用普通服务器来构建自己的云服务和数据中心的。

1. 特点
   - 也被称为小型机，普通服务器
   - 不需要特殊的空调场所
   - 具备不错的算力，可以完成较复杂的运算

#### 2.3.4 工作站

> 工作站是高端的通用微型计算机，提供比个人计算机更强大的性能，类似于普通台式电脑，体积较大，但性能强劲，主要用于图像处理、动画设计、计算机辅助设计及制造 CAD/CAM 等领域。

- 高端的通用型微型计算机，提供比个人计算机更强到的性能
- 类似于普通台式电脑，体积较大，但性能强劲

#### 2.3.5 微型计算机

- 又被称为个人计算机，是最普通的一类计算机，分为：台式机、笔记本电脑、一体机
- 麻雀虽小，五脏俱全：从构成的本质上来讲，个人计算机与前面的分类无异

#### 参考文档

[计算机分类 ](https://www.cnblogs.com/jvStarBlog/p/11941502.html)

### 2.4 计算机的体系与结构

#### 2.4.1 冯诺依曼体系

> 指将程序指令和数据一起存储的计算机设计概念结构

1. 早期计算机仅固定用途程序，如果要完成其他功能需要更改结构，重新设计电路。结果就比较坑爹（不能先打游戏然后再写代码）
2. 后来把程序存储起来并设计通用电路，这样就是**存储程序指令设计通用电路**

所以，冯诺依曼体系有以下特点

- 必须有一个存储器
- 必须有一个控制器
- 必须有一个运算器
- 必须有输入设备
- 必须有输出设备

现代计算机都是冯诺依曼机。

由冯诺依曼体系所指导完成的计算机，必须有以下的几点功能：

- 能够把需要的程序和数据送至计算机中（由输入设备完成）
- 能够长期记忆程序、数据、中间结果及最终运算结果的能力（由存储器完成）
- 能够具备算术、逻辑运算和数据传送等数据加工处理的能力（由运算器、控制器完成）
- 能够按照要求将处理结果输出给用户（由输出设备完成）

冯诺依曼体系结构示意图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092431310-1662319731.png)

Tips: 我们可以看到，存储器和 CPU 是分开的，这就导致一个问题(**冯诺依曼瓶颈**)：CPU 和存储器速率之间的问题无法调和。因为 CPU 是高速运算的，处理速率极快，而存储器没有 CPU 快，到 CPU 的数据传输速度慢，这会导致 CPU 经常空转等待数据传输，这样子是非常浪费资源的

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092442177-174994148.png)

既然我们都知道了冯诺依曼体系存在的性能瓶颈，那么，如何解决呢？

#### 2.4.2 现代计算机的结构

现代计算机在冯诺依曼体系结构基础上进行了修改，**解决了 CPU 和存储设备之间的性能差异问题**。下面是现代计算机的结构示意图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092451833-1194541326.png)

可以看到，跟前面不一样的是，运算器、控制器和存储器组成了现代计算机的 CPU。

存储器，从广义上，可以理解为存储数据的介质，包括磁带和硬盘。但是，这里的存储器主要是指围绕 CPU 的高速设备，包括寄存器和内存。现代计算机的结构，可以理解为以存储器为核心的结构。

关于存储器，还有很多需要理解的知识，我们会在后续文章里详细介绍。

#### 参考文档

[计算机体系与结构 ](https://www.cnblogs.com/jvStarBlog/p/11941506.html)

### 2.5 计算机的层次与编程语言

#### 2.5.1 程序翻译与程序解释

> 计算机是无法直接理解人类语言的，它只认识 01010101...这样的比特位，因此，我们需要进行程序翻译或程序解析，把人类语言翻译或解析成计算机所能理解的语言。
>
> 那么程序翻译和程序解析这两者之间有什么区别和联系呢？为了理解问题，我们引入两个语言，一个是较为高级的计算机语言——L1，另一个是较为低级的计算机语言——L0，我们接下来会使用这两个语言作为例子来理解什么是程序翻译，什么是程序解析。

##### 2.5.1.1 **程序翻译**

> 假设我们现在使用较为高级的计算机语言 L1 来进行程序的逻辑描述，也就是说我们使用 L1 来编写程序，那么这个由 L1 编写的程序是怎么样执行的呢？当然了，它不是直接执行的，而是在执行的时候生成一个逻辑等价的由低级语言 L0 组成的程序，这个 L0 是计算机实际执行的语言，那么由 L1 生成 L0 这个过程，我们称之为程序翻译，用于生成 L0 的工具叫编译器。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110418469-625827110.png)

##### 2.5.1.2 **程序解析**

> 同样的，假如我们使用 L1 来进行程序的逻辑描述，那么这个由 L1 编写的程序是怎样执行的呢？为了执行 L1，我们还需要使用 L0 实现另外一个程序，这个程序把 L1 程序作为输入来进行执行，每一句 L1 程序会在 L0 所实现的程序里面进行等价的转换，然后执行，这就是程序的解析，其中，使用 L0 实现的程序叫做解释器。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110459678-684415321.png)

##### 2.5.1.3 两者的总结

简要的总结程序翻译和程序解析：

1. 对于前面的两个例子而言，计算机执行的指令都是 L0
2. 翻译过程生成新的 L0 程序，解释过程不生成新的 L0 程序
3. 解释过程由 L0 编写的解释器去解释 L1 程序

理解了程序翻译和程序解释，我们来看下常见的编程语言，哪些语言是翻译型语言，哪些是解释型语言，如下图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110523773-543959654.png)

对于常见的，我们还有 Java 和 C#，它们又属于哪种语言呢？其实，严格的来说，它们既不属于翻译型语言，也不属于解释型语言，它们是属于**翻译+解释型**语言。

如何理解翻译+解释型语言呢？以 Java 程序的运行过程为例，Java 程序首先会被编译器编译成 JVM 字节码，然后会通过解释器解释成机器码，从而被计算机执行。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110537130-675156249.png)

#### 2.5.2 计算机的层次与编程语言

1. 按层次来划分计算机系统的话，我们可以划分成七个层次(分层的目的是为了便于理解)

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110546659-1074892489.png)

2. 下面逐一介绍每一层。

   - **硬件逻辑层**：主要由门电路、触发器等逻辑电路组成，属于电子工程的领域，这里就不展开介绍了。
   - **微程序机器层**：编程语言主要是微指令集，微指令所组成的微程序直接交由硬件执行，主要是由生产硬件的公司的程序员来编写的。
   - **传统机器层**：编程语言主要是 CPU 指令集（机器指令），和硬件是直接相关的，程序员所用机器指令编写的程序可以交由微程序直接进行解析，而这里提到的指令集，存储在 CPU 内部，对 CPU 的运算进行指导和优化，拥有指令集，CPU 就可以有效地运行。我们知道，CPU 的制造商分为 AMD 和 Intel 两大阵营，那么这两大厂商生产的 CPU 最大的区别是——指令集不同，Intel 的 CPU 所使用的指令集不适合 AMD 的 CPU，同样的，AMD 的 CPU 所使用的指令集也不适合 Intel。除了不同厂商以后，同一个厂商也可以生产不同指令集的 CPU，即不同架构的 CPU 使用不同的 CPU 指令集。

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110608700-1159855373.png)

   - **操作系统层**：操作系统，一方面，**向上提供了简易的操作界面，使得用户能够容易地操作计算机**；同时，**向下对接了指令系统，管理硬件资源**。操作系统对用户程序所使用机器的各种资源进行管理和分配，包括 CPU、存储器等等，比如说，当一个用户程序需要运行的时候，首先由操作系统将其加载到内存中，这就需要操作系统首先为其分配内存空间来进行存储。再比如说，某一个程序需要使用某一个输出设备进行结果输出的时候，需要操作系统为其提供该设备的控制权。由此可见，**操作系统是在软件和硬件之间的适配层**。
   - **汇编语言层**：编程语言是**汇编语言**，汇编语言可以**翻译**成可直接执行的机器语言，完成这个翻译过程的程序就是汇编器。从这一层开始，它们所使用的编程语言就是人类比较容易理解的语言了。
   - **高级语言层**：编程语言就是为广大程序员所接受的高级语言，种类非常多，有几百种，常见的编程语言有 Python、Java、C/C++、Golang 等。
   - **应用层**：计算机针对某种用途而设计的应用，像 Word、Excel 等。

#### 参考文档

[计算机层次与编程语言 ](https://www.cnblogs.com/jvStarBlog/p/11941513.html)

### 2.6 计算机的计算单位

#### 2.6.1 容量单位

在日常生活中，我们常说，200M 的光盘、8G 的内存、2T 的硬盘，这里的 M、G、T 就是容量单位，那么它们各自代表着什么含义以及它们之间是如何换算的呢？

在**计算机的物理层面，用高低电平记录信息，高电平代表 1，低电平代表 0，计算机只认识 0 和 1 两种状态**，这里的 0 或 1 我们就称为一个 bit（比特位），但是 0/1 能够表示的内容太少了，需要更大的容量表示方法，因此人们用 8 个比特位来表示一个字节（byte），一个字节等于八个比特位。随着计算机的发展，存储容量越来越大，用字节来表示容量也显得很不方便了，于是，出现了更高的容量单位。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190911215426335-1924506467.png)

上图是现在常见常使用的计算机容量单位，可以看到，1Byte=8bit，1KB=1024Byte，1MB=1024KB ... ...

#### 2.6.2 速度单位

这部分内容包括：网络速度和 CPU 频率

##### 2.6.2.1 **网络速度**

装宽带的时候，我们常说 50M 宽带、100M 宽带，这里的 M 不是容量单位，而是网络速度——带宽，单位是 Mbps(兆位/秒)，前面只是省略了 bps。

比如电信拉的是 100M 光纤，测试峰值速度只有 12M 每秒？为什么呢？因为网络常用单位是 Mbps,

100M/s = 100Mbps = 100Mbit/s

100Mbit/s = (100/8)MB/s = 12.5MB/s

##### 2.6.2.2 **CPU 频率**

CPU 的速度一般体现为 CPU 的时钟频率，也称为主频，单位为赫兹（Hz），是评定 CPU 性能的重要指标，主流 CPU 的时钟频率都在 2GHz 以上。

赫兹是国际单位制中频率的单位，是每秒中的周期性变动重复次数的计量，当用来描述计算机的 CPU 时，表达的是高低电平每秒钟变换的次数，主频越高，一个时钟周期里面完成的指令数也越多，2GHz，就是说每秒高低电平变换 20 亿次。

#### 参考文档

[计算机的计量单位 ](https://www.cnblogs.com/jvStarBlog/p/11941519.html)

### 2.7 计算机的字符与编码集

#### 2.7.1 字符编码集的历史

##### 2.7.1.1 **ASCII**

- 使用 7 个 bits 就可以完全表示 ASCII 码
- 包含 95 个可打印字符
- 33 个不可打印字符(包含控制字符)
- 33+95 = 128 = 2^7

对于 ASCII 码，相信大家在平时的学习、工作中都有所了解。

ASCII 码，英文全称为：American Standard Code for Information Interchange，翻译过来就是：美国信息交换标准代码，是我们平常常用的一种编码。那它是怎么来的呢？

在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示 1 和 0），例如，像 a、b、c、d 这样的 52 个字母（包括大写）以及 0、1 等数字还有一些常用的符号（例如\*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），假如，对于字符 a，比尔盖茨想用 0001 来表示，而乔布斯想用 0010 来表示，那么他们在沟通交流的时候谁都无法理解对方的语言。因此，为了计算机能够互相通信而不造成混乱，就必须使用相同的编码规则，于是美国有关的标准化组织就出台了 ASCII 编码，统一规定了上述常用符号用哪些二进制数来表示。

标准 ASCII 码也叫基础 ASCII 码，使用**7 个比特位来表示所有的大写和小写字母**，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，共定义了 128（2 的 7 次方）个**字符**。

下面我们通过一张表来了解部分 ASCII 码。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190913123734332-549719122.png)

表中列出了常见字符的 ASCII 码，如：字母 a 表示为 01100001、字符（不是数字哦~）1 表示为 00110001... ...

在计算机的早期，ASCII 码就能满足特定人群的使用了，但是，随着计算机的发展以及计算机的普遍性，ASCII 码逐渐不能满足人们的使用需求，比如一些数学符号以及一些国家的符号都无法表示。于是，人们对 ASCII 码进行了扩充，用 8 个比特位来表示一个字符，这就是拓展的 ASCII 码，拓展的 ASCII 码能表示 256 个字符。

##### 2.7.1.2 **Extended ASCII 码**

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190913123806096-1094066395.png)

这里面包括了常见的数学运算符、带音标的欧洲字符以及其他常用符号、表格符号等。使用了拓展的 ASCII 码极大的补充了原来的码表，使得计算机能表达的内容越来越丰富。

##### 2.7.1.3 **字符编码集的国际化**

随着计算机的进一步发展，越来越多的国家加入到了使用计算机的行列中，对字符编码集的要求也越来越高。对于欧洲、中亚、东亚、拉丁美洲等国家来说，它们的语言丰富多样，体系不一样，不以有限字符为组合，尤其以中国、韩国、日本等的语言最为复杂，ASCII 码表根本无法表达这些语言，这就迫切需要使用新的编码集，也就是字符编码集的国际化。

#### 2.7.2 中文编码集

##### 2.7.2.1**GB2312**

GB2312 是 1980 年制定的中国汉字编码国家标准，是我国最早最完备的一个编码集，一共收录了 7445 个字符，包括 6763 个汉字和 682 个其他字符，一个汉字占用两个字节。

##### 2.7.2.2 **GBK**

由于 GB2312 不符合国际标准，中国的科学家在 1995 年推出了第二套完备的编码集——GBK，GBK 向下兼容 GB2312，向上支持国际 ISO 标准，收录了 21003 个汉字，支持全部中日韩汉字。

GB2312 和 GBK 都是比较完备的编码集，但是，它们只是一个本地化的编码，在中国使用是没问题的，但要跨国使用就有问题了。举个例子，一个中国人开发了一个网站，一个外国友人访问了这个网站，如果他们本地没有安装 GB2312 编码集或 GBK 编码集的话， 那么他们在访问网站网页的时候看到的会是乱码。因此，就需要一个全球统一的编码规范。

##### 2.7.2.3 **Unicode**

为了统一所有文字的编码，Unicode 应运而生。Unicode 是一个兼容全球的字符集，定义了世界通用的符号集，可以表达全世界所有的文字和字符。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

我们平时用的 UTF-8 是其中一个编码规则，它以字节为单位对 Unicode 进行编码，平常写代码的时候都是推荐使用 UTF-8 编码。中文 Windows 操作系统默认使用 GBK 编码，因此，使用 IDE 编程时通常要设置成 UTF-8 编码。

#### 参考文档

[计算机的字符与编码集 ](https://www.cnblogs.com/jvStarBlog/p/11941521.html)

## 3. 计算机组成原理之组成篇

### 3.1 章节导学

1. 冯诺依曼计算机

   | 冯诺依曼计算机的组成部分 | 计算机硬件                          |
   | ------------------------ | ----------------------------------- |
   | 输入设备                 | 鼠标、键盘                          |
   | 输出设备                 | 显示器                              |
   | 存储器                   | CPU、内存、硬盘                     |
   | 运算器                   | CPU                                 |
   | 控制器                   | CPU、主板、显卡、声卡、电源、网卡等 |

2. 章节组成部分

   | 计算机的总线与 IO 设备 | 计算机的总线                                           | 计算机的输入与输出设备             |
   | ---------------------- | ------------------------------------------------------ | ---------------------------------- |
   | 计算机的存储器         | 计算机的存储器概览、<br />计算机的主存储器与辅助存储器 | 计算机的高速存储器                 |
   | 计算机的 CPU           | 计算机的指令系统、<br />计算机的控制器                 | 计算机的运算器、<br />指令执行过程 |

### 3.2 计算机的总线

#### 3.2.1 总线的概述

##### 3.2.1.1 总线的概述（是什么、什么用）

总线（bus），是用于连接计算机中各种功能部件（如 CPU、内存、输入、输出设备），并在它们之间传送数据的公用线路或通路，主机的各个部件通过总线相连接，外部设备（如 U 盘、移动硬盘）通过相应的接口再与总线相连接，从而形成计算机硬件系统。

USB: Universal Serial Bus, 通用串行总线

PCI 总线、ISA 总线、Thunderbolt 总线。。。

- 提供了对外连接的接口
- 不同设备可以通过 USB 接口进行连接
- 链接的标准，促使外围设备接口的统一

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022558360-281209348.png)

##### 3.2.1.2 总线的分类

1. 片内总线

   > **片内总线**，它是 CPU 内部的信息传输线，连接着控制器、运算器等部件，使用片内总线可以简化 CPU 内部的电路结构。
   >
   > 可以说是高集成度芯片内部的信息传输线

   - 芯片内部的总线
   - 寄存器与寄存器之间
   - 寄存器与控制器、运算器之间

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022613781-667181403.png)

2. 系统总线

   > **系统总线**，它是连接 CPU、主存、硬盘、IO 设备、USB 插槽、PCI 插槽等计算机组件的一条信息传输线。

   - 数据总线：一般与 CPU 位数相同(32 位、64 位)
     - 双向传输各个部件的数据信息
     - 数据总线的位数（总线宽度）是数据总线的重要参数
   - 地址总线：指定源数据或目的数据在内存中的地址，地址总线位数=n, 寻址范围：0-2^n
     - 指定源数据或目的数据在内存中的地址
     - 地址总线的位数与存储单元有关
   - 控制总线：
     - 控制总线是用来发出各种控制信号的传输线
     - 控制信号经由控制总线从一个组件发给另外一个组件
     - 控制总线可以监视不同组件之间的状态(就绪/未就绪)

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022625463-433149755.png)

#### 3.2.2 总线的仲裁

##### 3.2.2.1 为什么需要总线的仲裁

> 链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
> 来源：牛客网
>
> 为了解决多个主设备同时竞争总线控制权，必须具有总线仲裁部件，以某种方式选择其中一个主设备作为总线的下一次主方。对多个主设备提出的占用总线请求，一般采用优先级或公平策略进行仲裁。 按照总线仲裁电路的位置不同，仲裁方式分为集中式仲裁和分布式仲裁两类。

比如：当主存需要和硬盘、IO 设备进行数据交互等，当硬盘或者 IO 设备都准备就绪时候，总线应该由硬盘使用还是 IO 设备使用，这时候就需要一个第三方的仲裁器进行裁决

##### 3.2.2.1 总线仲裁的方法

> 总线的仲裁是为了解决总线使用权的冲突问题

###### 3.2.2.1.1 链式查询：

> 链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
> 来源：牛客网
>
> 链式查询方式的主要特点：总线授权信号 BG 串行地从一个 I/O 接口传送到下一个 I/O 接口。假如 BG 到达的接口无总线请求，则继续往下查询；假如 BG 到达的接口有总线请求， BG 信号便不再往下查询，该 I/O 接口获得了总线控制权。离\*\*\*仲裁器最近的设备具有最高优先级，通过接口的优先级排队电路来实现。
>
> 链式查询方式的优点 : 只用很少几根线就能按一定优先次序实现总线仲裁，很容易扩充设备。
>
> 链式查询方式的缺点 : 对询问链的电路故障很敏感，如果第 i 个设备的接口中有关链的电路有故障，那么第 i 个以后的设备都不能进行工作。查询链的优先级是固定的，如果优先级高的设备出现频繁的请求时，优先级较低的设备可能长期不能使用总线。

###### 3.2.2.1.2 计时器定时查询

- 仲裁控制器对设备编号并使用计数器累计计数
- 接收到仲裁信号后，往所有设备发出计数值
- 计数值与设备编号一致则获得总线使用权

链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
来源：牛客网

总线上的任一设备要求使用总线时，通过 BR 线发出总线请求。\*\*\*仲裁器接到请求信号以后，在 BS 线为“ 0 ”的情况下让计数器开始计数，计数值通过一组地址线发向各设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址相一致时，该设备 置“ 1 ” BS 线，获得了总线使用权，此时中止计数查询。

每次计数可以从“ 0 ”开始，也可以从中止点开始。如果从“ 0 ”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。

计数器的初值也可用程序来设置，这可以方便地改变优先次序，但这种灵活性是以增加线数为代价的。

##### 3.2.2.1.3 独立请求

- 每个设备均有总线独立链接仲裁器
- 设备可单独向仲裁器发送请求和接收请求
- 当同时收到多个请求信号，仲裁器有权按优先级分配使用权

链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
来源：牛客网

每一个共享总线的设备均有一对总线请求线 BRi 和总线授权线 BGi 。当设备要求使用总线时，便发出该设备的请求信号。\*\*\*仲裁器中的排队电路决定首先响应哪个设备的请求，给设备以授权信号 BGi 。

独立请求方式的优点：响应时间快，确定优先响应的设备所花费的时间少，用不着一个设备接一个设备地查询。其次，对优先次序的控制相当灵活，可以预先固定也可以通过程序来改变优先次序；还可以用屏蔽 ( 禁止 ) 某个请求的办法，不响应来自无效设备的请求。

#### 参考文档

[计算机的总线](https://www.cnblogs.com/jvStarBlog/p/11941522.html)

### 3.3 计算机的输入输出设备

#### 3.3.1 常见的输入输出设备

1. 常见的输入设备：
   - 字符输入设备
     - 键盘：薄膜键盘、机械键盘(黑轴，红轴，青轴，茶轴)、电容键盘
     - 鼠标
     - 数位板：输入板和压感笔、常用于绘画设计创作
     - 扫描仪：将图形信息转换为数字信号
   - 图像输出设备：
     - 显示器：CRT 显示器、液晶显示器
     - 打印机
     - 投影仪

#### 3.3.2 输入输出接口的通用设计

1. 如果要设计输入输出接口，需要完成什么工作
   - 读取数据、向设备发送数据、设备有没有被占用、设备是否已经链接、设备是否已经启动
2. 主要有：
   - 数据线：
     - 是 I/O 设备与主机之间进行数据交换的传送线
     - 单向传输数据线
     - 双向传输数据线
   - 状态线
     - IO 设备状态向主机报告的信号线
     - 查询设备是否已经正常链接并就绪
     - 查询设备是否已经被占用
   - 命令线
     - CPU 向设备发送命令的信号线
     - 发送读写信号
     - 发送启动禁止信号
   - 设备选择线
     - 主机选择 I/O 设备进行操作的信号线
     - 对连在总线上的设备进行选择

#### 3.3.3 CPU 与 IO 设备的通信

> CPU 速度与 IO 设备速度不一致

1. 程序中断：提供低速设备通知 CPU 的一种异步的方式；CPU 可以高速运转同时兼顾低俗设备的响应
   - 当外围 IO 设备就绪时，向 CPU 发出中断信号
   - CPU 有专门的电路响应中断信号
2. DMA(直接存储器访问)：当主存与 IO 设备交换信息时，不需要中断 CPU，可以提高 CPU 的效率
   - DMA 直接连接主存与 IO 设备
   - DMA 工作时不需要 CPU 的参与
   - 硬盘里、显卡都有这种设备

### 3.4 计算机存储器概览

#### 3.4.1 存储器的分类

1. 按照存储介质来分类
   - 半导体存储器：内存、U 盘、固态硬盘
   - 磁存储器：磁带、磁盘
2. 按照存取方式分类
   - 随机存储器 RAM: 可以随机读取、与位置无关
   - 串行存储器：与位置有关、按顺序查找
   - 只读存储器 ROM：只读不写

#### 3.4.2 存储器的层次结构

1. 读写速度：5200 转、7200 转，越快越好
2. 存储容量：2T、4T，越大越好
3. 价格：越便宜越好

所以用一个单位来衡量这几个结构标准的性价比，叫做位价(每比特位价格)=<容量+价格

可以划分为：

- 缓存：速度快、位价高
- 主存：速度适中、位价适中
- 缓存：速度慢、位价低

**主存-缓存层次**：是在主存之外增加辅助存储器（磁盘、SD 卡、U 盘等），目的是解决主存容量不足的问题。假设我们运行一个超大型游戏，而内存通常只有 8G，此时，就可以把游戏当前使用的数据加载到内存中，把不使用的数据放在辅存中

- 原理：局部性原理
- 实现：在 CPU 与主存之间增加一层速度快(容量小)的 Cache，主存之外增加辅助存储器（磁盘、SD 卡、U 盘等）
- 目的：解决主存速度不足的问题

**局部性原理**：是指 CPU 访问存储器时，无论是**存取指令**还是**存取数据**，所访问的存储单元都**趋于聚集在一个较小的连续区域中**

#### 参考文档

[存储器 ](https://www.cnblogs.com/jvStarBlog/p/11941524.html)

### 3.5 计算机的主存储器与辅助存储器

> 为什么计算机断电时候，内存数据会丢失
>
> 计算机断电时候，磁盘数据不会丢失

#### 3.5.1 主存储器---内存

- RAM：随机存取储器，Random Access Memory.
- RAM: 通过电容存储数据，必须隔一段时间刷新一次
- 如果掉电，那么一段时间后丢失所有数据

#### 3.5.2 辅助存储区----硬盘

1. 特点

- 表面是可磁化的硬磁特性材料
- 移动磁头径向运动读取磁道信息

2. 算法有：

- 先来先服务算法
  - 按顺序访问进程的磁道读写需求
- 最短寻道时间优先
  - 与磁头当前位置有关
  - 优先访问离磁头最近的磁道
- 扫描算法（电梯算法）
  - 每次只往一个方向移动
  - 到达一个方向需要服务的尽头再反方向移动
- 循环扫描算法
  - 读取只能往一个方向移动
  - 到达一个方向的尽头，就又回到起点重新开始

### 3.6 计算机的高速缓存

回顾一下:

1. 存储器的层次结构: 高速缓存位于 CPU 与 主存之间的，是为了解决 CPU 与主存的速度不匹配的问题。

#### 3.6.1 高速缓存的工作原理

1. 字：是指存放在一个存储单元中的二进制代码组合，一个字有 32 位
2. 字块：存储在连续的存储单元中而被看作是一个单元的一组字 ，一个字块共 B 个字
3. 主存共 M 个字块：B _ M = 主存总字数，B _ M \* 32 = 主存总容量(bits)
4. 字的地址包含两个部分：前 m 位表示制定字块的地址，后 b 位制定字在字块中的地址，所以：2^m = M, 2^b = B

> CPU 需要的数据在缓存里
>
> CPU 需要的数据不在缓存里
>
> 不在缓存的数据需要去主存中拿
>
> 这里就产生了一个指标

- 命中率是衡量缓存的重要性能指标
- 理论上 CPU 每次都能从告诉缓存取数据的时候，命中率为 1
- 命中率的计算公式：访问主存次数为 N(m), 访问 Cache 次数为 N(c),那么命中率 h = N(c) / (N(c)+N(m))
- 访问效率 e:
  - 假设访问主存时间为 t(m), 访问缓存时间为 t(c), 访问 Cache-主存系统的平均时间为：t(a) = h _ t(c) + (1 - h) _ t(m)
  - 访问效率 e = t(c)/t(a) = t(c) / (h* t(c) + (1-h) * t(m) )

1. 假设 CPU 在执行某段程序时，共访问了 Cache 命中 2000 次，访问主存 50 次，已知 Cache 的存取时间为 50ns, 主存的存取时间为 200ns, 求 Cache-主存系统的命中率、访问效率和平均访问时间
   - 访问效率 e = t(c)/t(a) = t(c) / (h* t(c) + (1-h) * t(m) ) = 50/(0.97 _ 50 + (1-0.97) _ 200 ) = 0.917 = 91.7%
   - 命中率 h =
   - 平均访问时间 t(a) = 0.97 _ 50 + (1-0.97)_ 200 = 54.5 ns

#### 3.6.2 高速缓存的替换策略

> 高速缓存的替换时机：当 CPU 需要的数据不存在高速缓存中时候，就需要从主存载入所需数据

- 随机算法
- 先进先出算法（FIFO）
  - 把高速缓存看做是一个先进先出的队列
  - 优先替换最先进入的字块
- 最不经常使用算法(LFU)
  - 优先淘汰最不经常使用的字块
  - 需要额外的空间记录字块的使用频率
- 最近最少使用算法(LRU)
  - 优先淘汰一段时间内没有使用的字块
  - 有多种实现方法，一般使用双向链表
  - 把当前访问节点置于链表前面（保证链表头部节点是最近使用的）

### 3.7 计算机的指令系统

#### 3.7.1 机器指令的形式

机器指令主要由两部分组成：操作码、地址码

- 操作码指明指令所要完成的操作

- 操作码的位数反映了机器的操作种类
- 地址码直接给出操作或者操作数的地址
- 分三地址指令、二地址指令和一地址指令、零地址指令（在机器指令中无地址码，空操作、停机操作、中断返回操作等）

#### 3.7.2 机器指令的操作类型

1. 数据传输

   - 寄存器之间、寄存器与存储单元、存储单元之间传送

   - 数据读写、交换地址数据、清零置一等操作

2. 算数操作类型：

   - 操作数之间的加减乘除运算
   - 操作数的与或非等逻辑位运算

3. 移位操作

   - 数据左移(乘 2)、数据右移动(除 2)
   - 完成数据在算术逻辑单元的必要操作

4. 控制指令：

   - 等待指令、停机指令、空操作指令、中断指令等

#### 3.7.3 机器指令的寻址方式

1. 指令寻址方式

   - 顺序寻址
   - 跳跃寻址

2. 数据寻址方式

   - 立即寻址：直接获取操作数、无需访问存储器
   - 直接寻址：直接给出操作数在主存的地址、寻找操作数简单、无需计算数据地址
   - 间接寻址：指令地址码给出的是操作数地址的地址、需要访问一次或者多次主存来获取操作数

3. 对比

   | 寻址方式 | 优点             | 缺点                         |
   | -------- | ---------------- | ---------------------------- |
   | 立即寻址 | 速度快           | 地址码位数限制操作数表示范围 |
   | 直接寻址 | 寻找操作数简单   | 地址码位数限制操作数寻址范围 |
   | 间接寻址 | 操作数寻址范围大 | 速度较慢                     |

### 3.8 计算机的控制器

> 控制器是协调和控制计算机运行的
>
> 主要构成部分有：程序计数器、时许发生器、指令译码器、各种寄存器（指令寄存器、主存地址寄存器、主存数据寄存器、通用寄存器）、总线

1. 程序计数器
   - 程序计数器用来存储下一条指令的地址
   - 循环从程序计数器中拿出指令
   - 当指令被拿出时，指向下一条指令
2. 时序发生器
   - 电气工程领域，用于发送时许脉冲
   - CPU 依据不同的时序脉冲有节奏的进行工作
   - 可以理解为 CPU 的节拍器
3. 指令译码器
   - 指令译码器是控制器的主要部件之一
   - 计算机指令是由操作码和地址码组成
   - 翻译操作码对应的操作以及控制传输地址码对应的数据
4. 指令寄存器
   - 指令寄存器也是控制器的主要部件之一
   - 从主存或者高速缓存取计算机指令
5. 主存地址寄存器
   - 保存当前 CPU 正要访问的内存单元的地址
6. 主存数据寄存器
   - 保存当前 CPU 正要读取或写的主存数据
7. 通用寄存器
   - 用于暂时存放或传送数据或者指令
   - 可以保存 ALU 的运算中间结果
   - 容量比一般专用寄存器要大

### 3.9 计算机的运算器

> 运算器是用来进行数据运算加工的
>
> 主要组成部分有：数据缓存器、ALU、通用寄存器、状态字寄存器、总线

1. 数据缓存器
   - 分为输入缓存和输出缓存
   - 输入缓存暂时存放外设送过来的数据
   - 输出缓存暂时存放送往外设的数据
2. ALU:
   - ALU：算术逻辑单元，是运算器的主要组成
   - 常见的位运算：左右移动、与或非等
   - 算术运算: 加减乘除等
3. 状态字寄存器
   - 存放运算状态: 条件码、进位、溢出、结果正负等
   - 存放运算控制信息：调试跟踪标记位、允许中断位等
4. 通用寄存器
   - 用于暂时存放或传送数据或指令
   - 可保存 ALU 的运算中间结果
   - 容量比一般专用寄存器要大

### 3.10 计算机指令的执行过程

#### 3.10.1 指令执行过程

> 步骤：取指令 =》 分析指令 =》 执行指令
>
> 涉及的设备：数据缓存器、指令缓存器、寄存器、数据缓存器、状态字寄存器、程序计数器、指令译码器、时序发生器、指令寄存器

1. 取指令：从缓存中取出指令，送到指令寄存器
2. 分析指令：指令译码器译码，发出控制信号，程序计时器+1
3. 执行指令：装载数据到寄存器，ALU 处理数据，记录运算状态，送出计算结果

上述过程中，在取指令或者分析指令时候，主要是控制器在进行工作；在执行指令时候，主要是由运算器进行工作的。所以说，运算器和控制器不是同时工作的，这样就导致 CPU 的综合利用率并不高。具体解决看下节内容

#### 3.10.2 CPU 的流水线设计

- 类似工厂的装配线
- 工厂的装配线使得多个产品可以同时被加工
- 在同一时刻，不同产品均位于不同的加工阶段

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8edd8057fddf41f59e58576963ce20d6~tplv-k3u1fbpfcp-watermark.image?)

假设执行 m 条指令，取指令、分析指令、执行指令所需时间一致并且都是 t

串行执行需要时间 T1 = 3t \* m

流水线执行 m 条指令需要时间：T2 = t \* (m+2)

H = T2 / T1 = t _ (m+2) / (3t _ m) = 1/3 + 1 / (3 _ m) = 1/3 + 1/ (3 _ m)

## 4 计算机组成原理之计算篇

### 4.1 章节导学

1. 进制运算的基本知识

   进制运算的基础、

2. 二进制数据的表示方式

   有符号数与无符号数、二进制的补码表示法、二进制的反码表示法、小数的二进制补码表示

3. 二进制数据的运算

   定点数与浮点数、定点数的加减法运算、浮点数的加减法运算、浮点数的乘除法运算

### 4.2 进制运算的基础

#### 4.2.1 进制的概述

1. 进制的定义

   - 进位制是一种计数方式，亦称进位计数法或位值记数法
   - 有限种数字符号来表示无限的数值
   - 使用的数字符号的数目称为这种进位制的基数或底数

2. 常见的进制

   > 计算机喜欢二进制，但是二进制表达太长了
   >
   > 使用大进制位可以解决这个问题
   >
   > 八进制、十六进制满足 2 的 n 次方的要求

   - 二进制：
   - 十进制
   - 八进制：
   - 十六进制：0-9、A、B、C、D、E、F
   - 二十进制：玛雅文明的玛雅数字、因努伊特的因努伊特数字
   - 六十进制：时间、坐标、角度等量化数据

#### 4.2.2 二进制运算的基础

- 正整数 N，基数为 r:

  1024 = 1 _ 10^3 + 0 _ 10^2 + 2*10^1 + 4 * 10^0 （基数是 10）

- （整数）二进制转换十进制的方法：按权展开法

- （整数）十进制转换二进制：重复相除法

- （小数）二进制转换十进制：按权展开法

  0.11001 = 1 _ 2^-1 + 1 _ 2^-2 + 1 \* 2^-5 = 0.78125 = 25/32

- (小数)十进制转换二进制：重复相乘法

### 4.3 有符号数与无符号数

> 上面都是整数或者小数，那么负数怎么办呢，使用 0 表示正数，使用 1 表示负数
>
> +237 = 011101101
>
> -237 = 111101101
>
> 那么怎么判断是数字位还是符号位呢？那我们约定把符号位放在数字位的最前面

原码表示法

1. 特点

   - 使用 0 表示正数、1 表示负数

   - 规定符号位位于数值第一位

   - 表达简单明了，是人类最容易理解的表示法

2. 缺点

   - 0 只有两种表示方法：00、10
   - 原码表示法运算非常复杂，特别是两个操作数符号不同的时候：判断两个操作数绝对值大小、使用绝对值大的数减去绝对值小的数、对于符号值，以绝对值大的为准

所以我们需要找到具有以下特点的其他方法

- 希望可以找到不同符号操作数更加简单的运算方法
- 希望找到使用正数代替负数的方法
- 使用加法操作代替减法操作，从而消除减法

### 4.4 二进制的补码表示法

1. 补码的定义：

对于 x, 位数为 n，

如果 0 <= x < 2^n，那么它的补码是 x;

如果 -2^n <= x < 0，那么它的补码是 x + 2^(n+1)

2. 例子 1：n=4，x=13，计算 x 的 二进制原码和补码

   原码 ：x = 0,1101 补码： x = 01101

3. 例子 2：n=4，x=-13，计算 x 的 二进制原码和补码

原码：x = 1,1101 补码：2^(4+1) - 13 = 100000 - 1101 = 10011

4. 例子 3：假设 x=-7,计算 x 的二进制原码和补码

   补码：2^(4+1) - 7 = 100000 - 0111 = 11001

5. 例子 4：如果 x=-1, 计算 x 的二进制原码和补码

   补码：2^(4+1) - 1 = 100000 - 0001 = 11111

注意：**在补码操作计算中，还是使用了减法**，有没有办法在计算过程中不涉及到减法操作的呢？

### 4.5 二进制的反码表示法

1. 引进补码的目的

   - 减法运算复杂，希望找到使用正数替代负数的方法
   - 使用加法代替减法操作，从而消除减法（但是在计算补码的过程中，还是使用了减法）

2. 反码的目的

   - 找出原码和补码之间的规律，消除转换过程中的减法

3. 反码的定义：

   对于 x, 位数为 n，

   如果 0 <= x < 2^n，那么它的反码是 x;

   如果 -2^n <= x < 0，那么它的反码是 x + 2^(n+1) -1

4. 例子 1：x= -13,计算 x 的二进制原码和反码

   原码 = x = 1,1101

   反码 = 2^(4+1) - 1 - 13 = 011111 - 1101 = 1,0010

5. 例子 2：x=-7, 计算 x 的二进制原码和反码

   原码 = x = 1,0111

   反码 = 2^(4+1) - 1 - 7 = 011111 0 -111 = 1,1000

| 十进制 | 原码   | 补码   | 反码   |
| ------ | ------ | ------ | ------ |
| 13     | 0,1101 | 0,1101 | 0,1101 |
| -13    | 1,1101 | 1,0011 | 1,0010 |
| -7     | 1,0111 | 1,1001 | 1,1000 |
| -1     | 1,0001 | 1,1111 | 1,1110 |

从上图可以看到的规律如下

- 负数的反码等于原码除符号位外按位取反
- 负数的补码等于反码+1

### 4.6 小数的二进制补码表示法

1. 二进制小数的补码

   如果 0<= x <1, 那么 x 的补码为 x

   如果 -1<=x<0，那么 x 的补码为 2+x

2. 例子 1：x= 9/16，计算 x 的二进制原码和反码和补码

   x 的原码为 0,0.1001

   x 的反码为 0,0.1001

   x 的补码为 0,0.1001

3. 例子 2：x= -11/32，计算 x 的二进制原码和反码和补码

   x 的原码为 1,0.01011

   x 的反码为 1,1.10100

   x 的补码为 1,1.10101

### 4.7 定点数与浮点数

#### 4.7.1 定点数的表示方法

- 小数点固定在某个位置的数称之为定点数

- 如果不是纯小数，也不是纯整数，那就需要 **乘以比例因子以满足定点数保存格式**

- 纯小数如下

  | 数值    | 符号位 | 数值位 |
  | :------ | ------ | ------ |
  | 0.1011  | 0      | 1011   |
  | -0.1011 | 1      | 1011   |

- 纯整数表示如下

  | 数值  | 符号位 | 数值位 |
  | ----- | ------ | ------ |
  | 1011  | 0      | 1011   |
  | -1011 | 1      | 1011   |

- 均不是上述情况时候，需要乘以比例因子以满足定点数保存格式

  | 数值  | 符号位 | 数值位 |
  | ----- | ------ | ------ |
  | 10.01 |        |        |
  | 101.1 |        |        |

#### 4.7.2 浮点数的表示方法

1. 为什么有了定点数，还需要使用浮点数呢

   - 计算机处理的很大程度上不是纯小数或纯整数
   - 数据范围很大，定点数难以表达

2. 浮点数的表示格式

   - 科学计数法

     - 123450000000 = 1.2345 \* 10^11，其中 1.2345 是尾数，10 是基数，11 是阶码

     - 对于任意的浮点数都可以表示为：N = S \* r^j 其中 S 是尾数，r 是基数，j 是阶码

     - 所以使用这种方式存储时候，需要存储：阶码符号位、阶码数值位、尾数符号位、尾数数值位，其中 尾数规定使用纯小数

     - 比如：

       11.0101 = 0.110101 \* 2^10

       11.0101 = 0.0110101 \* 2^11

       | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位(8 位) |
       | ---------- | ---------- | ---------- | ---------------- |
       | 0          | 10         | 0          | 11010100         |
       | 0          | 11         | 0          | 01101010         |

3. 浮点数的表示范围

   - 假设阶码数值取 m 位，尾数数值取 n 位

     - 阶码能够表示的最大值是 2^m - 1, 最小值为 -(2^m - 1)
     - 阶码表示范围：[ -(2^m - 1), 2^m - 1 ]
     - 尾数能够表示的最大值：1 - 2^(-n), 最小值为 2^(-n)
     - 尾数表示范围：[ 2^(-n), 1 - 2^(-n) ] 负数范围：[ -(1 - 2^(-n)), - 2^(-n), ] ，正数范围：[ 2^(-n), 1 - 2^(-n) ]

   - 下面以阶码占 3 位，尾数占 5 位(各包括 1 位符号位)为例，来讨论这个问题。图 2-1 给出了相应的规格化浮点数的数值表示范围。

   ![img](https://upload-images.jianshu.io/upload_images/525520-c101d21a0301f55f.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

   - 单精度浮点数

     > 使用 4 个字节，32 位来表达浮点数 float

   - 双精度浮点数

     > 使用 8 个字节，64 位来表达浮点数 double

4. 浮点数的规格化

   - 科学计数法：对于浮点数，要求**尾数规定使用纯小数**、**尾数最高位必须是 1**

     11.0101 = 0.110101 \* 2^10

     11.0101 = 0.0110101 \* 2^11 不符合规范

   - 例子 1：设定浮点数字长为 16 位，阶码为 5 位，尾数为 11 位，将十进制数 13/128 表示为二进制浮点数

     求原码：x = 0.0001101000

     浮点数规格化 x= 0.1101000 \* 2 ^ (-11)

   - 例子 2：设定浮点数字长为 16 位，阶码为 5 位，尾数为 11 位，将十进制数 -54 表示为二进制浮点数

     求原码：x = 1,1110110

     浮点数规格化：x = -0.110110 \* 2 ^ (110)

#### 4.7.3 定点数与浮点数的对比

- 当定点数与浮点数位数相同时候，**浮点数表示的范围更大**
- 当浮点数尾数为规格化数时，**浮点数的精度最高**
- 浮点数运算包括阶码和尾数，**浮点数的运算更为复杂**
- 浮点数在数的表示范围、精度、溢出处理、编程等方面均位于定点数
- 浮点数在数的运算规则、运算速度、硬件成本方面不如定点数

### 4.8 定点数的加减运算

#### 4.8.1 定点数的加法

> **数值位与符号位一同运算，并将符号位产生的进位自然丢掉**

1. 整数的加法

   > A[补] + B[补] = [ A+B ] [ 补 ] ( mod2^(n+1) )

2. 小数的加法

   > A[补] + B[补] = [ A+B ] [ 补 ] ( mod2 )

3. 例子 1：A= -10000110, B = 001101, 求 A+B

   A[补] = 1,001110

   B[补] = B[原] = 0,001101

   A[补] + B[补] = （A+B）[补] = 1,011011

   A+B= -100101

4. 例子 2：A=-0.1010010, B = 0.0110100, 求 A+B

   A[补] = 1,1.0101110

   B[补] = B[原] = 0,0.0110100

   A[补]+B[补] = (A+B)[补] = 1.0.1100010

   A+B = -0.0011110

5. 例子 3：A=-10010000，B=-01010000，求 A+B

   A[补] = 1,01110000

   B[补] = 1,101110000

   A[补] + B[补] = (A+B) [补] = 1,00100000

   A + B = -11100000

   A = -144, B = -80

   A + B = -224

6. 例子 4：A = -10010000, B = -1101000, 求 A+B

   A[补] = 1,01110000

   B[补] = 1,00110000

   A[补] + B[补] = (A+B) [补] = 0,10100000

   A + B = 10100000

   A = -144, B = -208, A + B = 160 ： 注意：这里两个负数相加，结果为正数，因为发生了溢出。

7. 如何判断溢出

   - 双符号位判断法：**单符号位表示变为双符号位：0=> 00 , 1 => 11**

     双符号位产生的进位丢弃

     结果的双符号位不同则表示溢出

8. 例子 4：A= -10010000， B = -11010000, 求 A + B

   A[补] = 1,01110000

   B[补] = 1,00110000

   A[补] + B[补] = (A+B) [补] = 1,010100000 (相加后符号位进位，需要舍去一位，这里是舍去后的结果，并且注意：双符号位(首位为 10)不同，表示溢出)

#### 4.8.2 定点数的减法

1. 整数的减法

   > A[补] - B[补] = A + (-B ) [ 补 ] ( mod2^(n+1) )

2. 小数的减法

   > A[补] - B[补] = A + (-B ) [ 补 ] ( mod2 )

**-B[补]等于 B[补]连同符号位按位取反，末位加一**

B[补] = 1,0010101

-B[补] = 0,1101011

3. 例子 5：A= 11001000，B= -00110100，求 A - B

   A[补] = A[原] = 0,11001000

   B[补] = 1,11001100

   (-B)[补] = 0,00110100

   A + (-B)[补] = 0,11111100

   A - B = 111111100

### 4.9 浮点数的加减法运算

1. 对阶

   - 浮点数尾数运算简单
   - 浮点数位数实际小数位与阶码有关
   - 阶码按小阶看齐大阶的原则
   - 对阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算

   ![img](https://i.loli.net/2018/10/28/5bd5bb1a49c09.png#shadow)

2. 尾数相加

   > 完成对阶后，将两浮点数的尾数部分相加，方法与定点小数加法相同

3. 规格化处理

   ![img](https://i.loli.net/2018/10/28/5bd5bbdcc67ef.png#shadow)

   对右移的两种情况做一下特殊说明：10,110 -> 11,011
   01,110 -> 00,111

4. 舍入操作

   - 0 舍 1 入法：二进制的四舍五入，注意可能会发生溢出

5. 检查阶码是否溢出

   - 浮点运算主要通过阶码的双符号位判断是否溢出
   - 如果规格化后，阶码双符号位不一致，则认为是溢出

【参考文档】

[浮点数加减运算](https://wmathor.com/index.php/archives/1091/)

### 4.10 浮点数的乘除法运算

1. 乘法：阶码相乘，尾数求积
2. 除法：阶码相减，尾数求商
3. 步骤
   1. 阶码运算
   2. 尾数运算
   3. 尾数规格化
   4. 舍入
   5. 溢出判断

【参考文档】

[浮点数的乘除法运算](https://blog.csdn.net/qq_47114658/article/details/111599175)

## 5 计算机组成原理实践

### 5.1 章节导学

1. 实现双向链表：
   1. 实现 node 类
   2. 实现 DoubleLinkedList 类：pop 方法、append(node)方法、append_front(node)方法、remove(node)方法
2. 实现置换算法：
   1. 先进先出算法
      - 把高速缓存看做是一个先进先出的队列
      - 优先替换是最先进入队列的字块
   2. 最近最少使用算法 LRU
      - 优先淘汰一段时间内没有使用的字块
      - 有多种实现方法，一般使用双向链表
      - 把当前访问节点置于链表前面（保证链表头部节点是最近使用的）
   3. 最不经常使用算法 LFU
      - 优先淘汰最不经常使用的字块
      - 需要额外的空间记录字块的使用频率
   4. 实现置换算法：
      1. 实现 Cache 类
         - get(key) 方法：返回 value 或者 -1
         - put(key ,value) 方法

### 5.2 双向链表的原理与实践

1. 单向链表：

   > 每一个节点都有下一个节点的地址或者引用

   节点 1 =》 节点 2 =》 节点 3 =》 节点 4 =》 节点 5

2. 双向链表

   > 每一个节点都有上一个节点和下一个节点的地址或者引用

   节点 1 《=》节点 2《=》节点 3《=》节点 4《=》节点 5

3. 对于双向链表：

   - 可以快速找到一个节点的下一个节点
   - 可以快速找到一个节点的上一个节点
   - 可以快速去掉表中的某一个节点

4. 实现双向链表

   1. 实现链表节点

      > 可以存放 key-value 数据, 因此具有 key: value 的属性，并且有上一个节点的引用、下一个节点的引用

   2. 实现双向链表

      > 包括的功能：弹出头部节点、弹出尾部节点、往头部增加节点、往尾部增加节点、删除任意节点、增加任意节点

### 5.3 实践 FIFO 缓存置换算法

FIFO: 先进先出算法

### 5.4 实践 LRU 缓存置换算法

- 每次使用，把使用的节点放到链表最前面；
- 淘汰缓存时候，把链表尾部的节点淘汰

### 5.5 实现 LFU 缓存置换算法

每一个节点需要一个标记，来记录使用的频率

淘汰缓存时候，把使用频率最小的淘汰

问题：可能存在相同频率的情况，这时应该淘汰哪个节点呢？相同频率的节点放入另一个双向链表中，然后同频率节点按 FIFO 算法淘汰

## 6 操作系统之基础篇

### 6.1 本章知识概要与学习计划

#### 6.1.1 操作系统的演进

1. 无操作系统
   - 人工操作
   - 用户独占
   - CPU 等待人工操作
   - 资源利用率低
2. 批处理系统
   - 无序等待人工操作
   - 批量输入任务
   - 资源利用率提升
   - 多道程序设计
3. 分时系统
   - 人机交互
   - 多用户共享
   - 及时调试程序
   - 资源利用率提升
4. 多道程序设计
   - 早期批处理系统只能一次处理一个任务
   - 多道程序设计使得批处理系统可以一次处理多个任务
   - 多道程序设计是指在计算机内存中同时存放多个程序
   - 多道程序设计在计算机的管理程序之下相互穿插运行
   - **对多道程序的管理是操作系统的重要功能**
5. 对多道程序的管理
   - 进程管理
   - 存储管理
   - 作业管理
   - 文件管理
   - 设备管理

### 6.2 操作系统概览

### 6.2.1 what & why

#### 6.2.1.1 **What**

> 管理软件、提供用户交互的软件系统

- 操作系统是管理计算机硬件和软件资源的**计算机程序**
- 管理配置内存、决定资源提供供需顺序、控制输入输出设备等
- 操作系统提供让用户和系统交互的**操作界面**
- 操作系统的种类是多种多样的，不局限于计算机
- 从手机到超级计算机，操作系统可简单也可复杂
- 在不同的设备上，操作系统可向用户呈现多种操作手段
- 常见的操作系统种类：Android、Ios、Windows、Linux、MacOs、华为鸿蒙

#### 6.2.1.2 **Why**：

- 我们不可能直接操作计算机硬件
- 设备种类繁多复杂，需要统一界面
- 操作系统的简易性使得更多人能够使用计算机

### 6.2.2 操作系统的基本功能

1. 操作系统统一管理着计算机资源
   - 处理器资源
   - 存储器资源
   - IO 设备资源
   - 文件资源
2. 操作系统实现了对计算机资源的抽象
   - 用户无需面向硬件接口编程
   - IO 设备管理软件，提供读写接口
   - 文件管理软件，提供操作文件接口
3. 操作系统提供了用户与计算机之间的接口
   - 图像窗口形式
   - 命令形式
   - 系统调用形式

### 6.2.3 操作系统相关概念

1. 并发性

   > 什么是并行，什么是并发

   - 并行是指两个或者多个事件可以在**同一时刻**发生
   - 并发是指两个或者多个事件可以在**同一时间间隔**发生

2. 共享性

   - 共享性表现为操作系统中的资源可供多个并发的程序共同使用
   - 这种共享使用的形式称之为资源共享
   - 多个程序可以同时使用主存资源
   - 资源共享根据属性可以分为两种方式
     - 互为共享形式
       - 当资源被程序 A 占用时，其他想使用的话只能等待
       - 只有进程 A 使用完成以后，其他进程才可以使用该资源
     - 同时访问形式
       - 某种资源在一段时间内被并发地被多个程序访问
       - 这种”同时“是宏观的，从宏观去看该资源可以被同时访问

3. 虚拟性

   - 虚拟性表现为把一个**物理实体**转变为若干个**逻辑实体**
   - 物理实体是真实存在的，逻辑实体是虚拟的
   - 虚拟的技术主要分为**时分复用技术**和**空分复用技术**
   - 时分复用技术：
     - 资源在时间上进行复用，不同程序并发使用
     - 多道程序分时使用计算机的硬件资源
     - 提高资源的利用率
     - 它又分为
       - 虚拟处理器技术
         - 借助多道程序设计技术
         - 为每个程序建立进程
         - 为买个程序分时复用处理器
       - 虚拟设备技术
         - 物理设备虚拟为多个逻辑设备
         - 每个程序占用一个逻辑设备
         - 多个程序通过逻辑设备并发访问
   - 空分复用技术
     - 充分复用技术用来实现虚拟磁盘、虚拟内存等
     - 提高资源的利用率，提升编程效率
     - 它又分为
       - 虚拟磁盘技术
         - 物理磁盘虚拟为逻辑磁盘
         - C、D、E 等逻辑盘
         - 使用起来更加安全、方便
       - 虚拟内存技术
         - 在逻辑上扩大程序的存储容量
         - 使用比实际内存更大的容量
         - 大大提升编程效率

4. 异步性

   - 在多道程序环境下，允许多个进程并发执行
   - 进程在使用资源时可能需要等待或放弃
   - 过程的执行并不是一气呵成，而是以走走停停的形式推进

### 6.3 进程管理之进程实体

#### 6.3.1 为什么需要进程

- 在没有配置 OS 之前，资源属于当前运行的程序
- 配置 OS 之后，引入**多道程序设计**的概念
- 合理的隔离资源、运行环境，提升资源利用率

因此可以说

- 进程是系统进行资源分配和调度的基本单位
- 进程作为程序独立运行的载体保障程序正常执行
- 进程的存在使得操作系统资源的利用率大幅度提升

#### 6.3.2 进程的实体

1. 主存中的进程形态

   > 分为：进程标识符、处理机状态、进程调度信息、程序控制信息

   - 标识符：唯一标记一个进程，用于区别其他进程
   - 状态：标记进程的进程状态，如：运行态
   - 优先级
   - 程序计数器：程序即将被执行的下一条指令的地址
   - 内存指针：程序代码、进程数据相关指针
   - 上下文数据：进程执行时处理器存储的数据
   - IO 状态信息：被进程 IO 操作所占用的文件列表
   - 记账信息：使用处理器时间、时钟数总和等

2. 进程控制块 PCB：

   - 用于描述和控制进程运行的通用数据结构
   - 记录进程当前状态和控制进程运行的全部信息
   - PCB 的使得进程是能够独立运行的基本单位
   - PCB 是操作系统进行调度经常会被读取的信息
   - PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内

3. 进程与线程

   > 一个进程可以有多个线程

   - 进程 process：
     - 进程是系统进行资源分配和调度的基本单位
     - 一个进程可以并发多个线程，每个线程执行不同的任务
   - 线程 thread：
     - 线程是操作系统进行运行调度的最小单位
     - 包含在进程之中，是进程中实际运行工作的单位

4. 区分

   |          | 进程               | 线程                 |
   | :------- | ------------------ | -------------------- |
   | 资源     | 资源分配的基本单位 | 不拥有资源           |
   | 调度     | 独立调度的基本单位 | 独立调度的最小单位   |
   | 系统开销 | 进程系统开销大     | 线程系统开销小       |
   | 通信     | 进程 PIC           | 读写同一进程数据通信 |

### 6.4 进程管理之五状态模型

#### 6.4.1 就绪

- 当进程被分配到除 CPU 以外所有必要的资源后
- 只要在获得 CPU 的使用权，就可以立即执行
- 其他资源都准备好、只差 CPU 资源的状态为**就绪状态**
- 在一个 系统中多个处于就绪状态的进程通常排成一个队列（叫做就绪队列，（会有一个或者多个就绪进程））

#### 6.4.2 执行

- 进程获得 CPU，其程序正在执行 称为执行状态
- 在单处理机中，在某个时刻只能有一个进程是处于执行状态

#### 6.4.3 阻塞

- 进程因某种原因：其他设备未就绪而无法继续执行
- 从而放弃 CPU 的状态称为阻塞状态
- 同样会有一个阻塞队列（会有一个或者多个阻塞进程）

#### 6.4.4 创建

> 创建进程时拥有 PCB，但是其他资源尚未就绪的状态称为创建状态
>
> 操作系统 提供 fork 函数接口创建进程

1. 分配 PCB
2. 插入就绪队列

#### 6.4.5 终止

> 进程结束由系统清理或者归还 PCB 的状态称为终止状态

1. 系统清理
2. PCB 归还

### 6.5 进程管理之进程同步

#### 6.5.1 为什么需要进程间同步

1. 生产者-消费者问题

   > 有一群生产者进程在生产产品，并将这些产品提供给了消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的的缓冲池，生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。

   单从生产者程序或者消费者程序去看是没有问题的，单两者并发执行时就可能出差错

2. 哲学家进餐问题

   > 有 5 个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有 5 个碗和 5 支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两支筷子，只有两支筷子都被他拿到的时候就能进餐，进餐完毕之后，放下左右筷子继续思考
   >
   > 拿起左边筷子，拿起右边筷子，进餐

3. - 根源问题是：彼此相互之间没有通信
   - 如果生产者通知消费者我已经完成一件生产
   - 哲学家向旁边哲学家说我要进餐了

   > 对竞争资源在多进程间进行使用次序的协调
   >
   > 使得并发执行的多个进程之间可以有效使用资源和相互合作

#### 6.5.2 进程间同步的原则

1. 临界资源：

   > 临街资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时候，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

2. 原则

   - 空闲让进：资源无占用，允许使用
   - 忙则等待：资源有占用，请求进程等待
   - 有限等待：保证有限等待时间能够使用资源
   - 让权等待：等待时，进程需要让出 CPU

3. 进程同步的方法

   - 消息队列
   - 共享存储
   - 信号量

#### 6.5.3 线程同步

进程的线程共享进程资源，那么当多个线程并发使用进程资源时，会发生什么呢？

因此，进程内多线程也需要同步

线程同步的方法

- 互斥量
- 读写锁
- 自旋锁
- 条件变量

### 6.6 Linux 的进程管理

#### 6.6.1 Linux 进程的相关概念

1. 进程的类型

   - 前台进程
     - 前台进程就是具有终端，可以和用户交互的进程
   - 后台进程

     > 将需要执行的命令以 & 符号结束

     - 与前台进程相对，没有占用终端的就是后台进程
     - 后台程序基本上不用和用户交互，优先级比前台进程低

   - 守护进程

     - 守护进程（daemon）是特殊的后台进程
     - 很多守护进程在系统引导的时候启动，一直运行直到系统关闭
     - Linux 有很多典型的守护进程
     - 进程名字以 d 结尾的一般都是守护进程：crond、httpd、sshd、mysqld

2. 进程的标记

   - 进程 ID

     - 进程 ID 是进程的唯一标记，每个进程拥有不同的 ID
     - 进程 ID 表现为一个非负整数，最大值由操作系统限定
     - 操作系统提供 frok 函数接口创建进程
     - 父子进程关系可以通过 pstree 命令查看
     - ID 为 0 的进程为 idle 进程，是系统创建的第一个进程
     - ID 为 1 的进程为 lnit 进程，是 0 号进程的子进程，完成系统初始化
     - lnit 进程是所有用户进程的祖先进程

   - 进程的状态 标记

     | 状态符号 | 状态说明                                                |
     | -------- | ------------------------------------------------------- |
     | R        | TASK_RUNNING, 进程正处于运行状态                        |
     | S        | TASK_INTERRUPTIBLE, 进程正处于睡眠状态                  |
     | D        | TASK_UNINTERRUPTIBLE, 进程正在处于 IO 等待的睡眠时间    |
     | T        | TASK_STOPPED, 进程正处于暂停状态                        |
     | Z        | TASK_DEAD or EXIT_ZOMBIE 进程正处于推出状态，或僵尸状态 |

#### 6.6.2 操作 Linux 进程的相关命令

1. ps 命令
   - 常用于显示当前进程的状态
   - 通常配合 aux 参数或者 ef 参数和 grep 命令检索特定进程
2. top 命令
3. kill 命令
   - kill 命令发送指定信号给进程
   - kill -l 可以查看操作系统支持的信号
   - 只有(SIGKILL 9) 信号可以无条件终止进程，其他信号进程有权忽略

### 6.7 作业管理之进程调度

#### 6.7.1 进程调度概述

> 进程调度是指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权

- 保留旧进程的运行信息，请出旧进程（收拾包袱）
- 选择新进程，准备运行环境并分配 CPU（新进驻）

1. 几种机制概念

   - 就绪队列的排队机制
     - 将就绪进程按照一定的方式排列成队，以便调度程序可以最快找到就绪进程
   - 选择运行进程的委派机制

     - 调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它

   - 新老进程的上下文切换机制
     - 保存当前进程的上下文信息，装入被委派执行进程的运行上下文

2. 问题：进行进程调度时候，老进程还没有执行完成，该怎么办？按照老进程有没有执行完成可以分为两大类

   - 非抢占式的调度
   - 处理器一旦分配给某个进程，就让该进程一直使用下去
   - 调度程序不以任何原因抢占正在被使用的处理器
   - 直到进程完成工作或因为 IO 阻塞才会让出处理器
   - 抢占式的调度
     - 允许调度程序以一定的策略暂停当前运行的进程
     - 保存好旧进程的山下文信息，分配处理器给新进程

3. 区别

   | 类型     | 抢占式调度       | 非抢占式调度       |
   | -------- | ---------------- | ------------------ |
   | 系统开销 | 频繁切换，开销大 | 切换次数少，开销小 |
   | 公平性   | 相对公平         | 不公平             |
   | 应用     | 通用系统         | 专用系统           |

#### 6.7.2 进程调度算法

1. 先来先服务调度算法
2. 短进程优先调度算法
   - 调度程序优先选择就绪队列中估计运行时间最短的进程
   - 短进程优先调度算法不利于长作业进程的执行
3. 高优先权调度算法
   - 进程附带优先权，调度程序优化选择权重更高的进程
   - 高优先权优先调度算法使得紧迫的任务可以优先处理
4. 时间片轮转调度算法
   - 按照先来先服务的原则排列就绪进程
   - 每次从队列头部取出待执行进程，分配一个时间片执行
   - 是相对公平的调度算法，但是不能保证及时响应用户

### 6.8 作业管理之死锁

> 死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推荐下去。此时称系统处于死锁状态或者系统产生了死锁，这些永远在互相等待的进程称为死锁进程

#### 6.8.1 死锁的产生

1. 竞争资源
   - 共享资源数量不满足各个进程需求
   - 各个进程之间发生资源竞争导致死锁
   - 死锁的
2. 进程调度顺序不当
3. 死锁的四个必要条件
   - 互斥条件
     - 进程对资源的使用是排他性的使用
     - 某资源只能由一个进程使用，其他进程需要使用只能等待
   - 请求保持条件
     - 进程至少保持一个资源，又提出新的资源请求
     - 新资源被占用，请求被阻塞
     - 被阻塞的进程不释放自己保持的资源
   - 不可剥夺条件
     - 进程获得的资源在未完成使用前不能被剥夺
     - 获得的资源只能由进程自身释放
   - 环路等待条件
     - 发生死锁时，必然存在进程-资源环形链

#### 6.8.2 死锁的处理

1. 预防死锁的方法

   > 上一节死锁有四个必要条件，那么破坏其中之一 就可以

   - 摒弃请求保持条案
     - 系统规定进程运行之前，一次性申请所有需要的资源
     - 进程在运行期间不会提出资源请求，从而摒弃请求保持条件
   - 摒弃不可剥夺条件
     - 当一个进程请求新的资源得不到满足时，必须释放占有的资源
     - 进程运行时占有的资源可以被释放，意味着可以被剥夺
   - 摒弃环路等待条件
     - 可用资源线性排序，申请必须依照递增申请
     - 线性申请不再形成环路，从而摒弃了环路等待条件

2. 银行家算法

   - 是一个可操作的著名的避免死锁的算法
   - 以银行借贷系统分配策略为基础的算法
   - 假如
     - 客户申请的贷款是有限的，每次申请都需要声明最大资金量
     - 银行家在能够满足贷款时，都应该给用户贷款
     - 客户在使用贷款后，能够及时归还贷款
     - 需要几个结构: 已分配资源表、所需资源表、可分配资源表、还需分配资源表（所需资源表 - 已分配资源表）

### 6.9 存储管理之内存分配与回收

> 早期计算机编程并不需要过多的存储管理
>
> 随着计算机和程序越来越复杂，存储管理成为必要

1. 目的
   - 确保计算机有足够的内存处理数据
   - 确保程序可以从可用内存中获取一部分内存使用
   - 确保程序可以归还使用后的内存以供其他程序使用

#### 6.9.1 内存分配的过程

1. 单一连续分配
   - 单一连续分配是最简单的内存分配方式
   - 只能在单用户、单进程的操作系统中使用
2. 固定分区分配
   - 固定分区分配是支持多道程序的最简单存储分配方式
   - 内存空间被划分为若干固定大小的区域
   - 每个分区只提供一个程序使用，互不干扰
3. 动态分区分配
   - 根据进程实际需要，动态分配内存空间
   - 相关数据结构、分配算法
   - 涉及的数据结构
     - 动态分区空闲表数据结构
     - 动态分区空闲链数据结构
   - 动态分区分配算法
     - 首次适应算法（FF 算法）
       - 内存分配时从开始顺序查找适合内存区
       - 若没有合适的空闲区，则该次分配失败
       - 每次从头部开始，使得头部地址空间不断被划分
     - 最佳适应算法（BF 算法）
       - 最佳适应算法要求空闲区链表按照容量大小排序
       - 遍历空闲区链表找到最佳合适空闲区
     - 快速适应算法（QF 算法）
       - 快速适应算法要求有多个空闲区链表
       - 每个空闲区链表存储一种容量的空闲区

#### 6.9.2 内存回收的过程

1. 需要回收的区域与一块空闲区是连接在一起的，并且位于空闲区的后面
   - 不需要新建空闲链表节点
   - 只需要把回收区前面的空闲区容量增大为包括回收区的容量即可
2. 需要回收的区域与一块空闲区是连接在一起的，并且位于空闲区的前面
   - 将回收区与空闲区合并
   - 新的空闲区使用回收区的地址
3. 需要回收的区域位于两块空闲区之间的
   - 将两块空闲区和回收区进行合并
   - 新的空闲区使用最前面的空闲区的地址作为新的地址
4. 单一的回收区，没有链接任何空闲区
   - 为回收区创建新的空闲节点
   - 插入到相应的空闲区链表中去

### 6.10 存储管理之段页式存储管理

> 操作系统是如何管理进程的空间的呢？

#### 6.10.1 页式存储管理

> 字块是相对物理设备的定义
>
> 页面则是相对逻辑空间的定义

- 将进程逻辑空间等分成若干个大小的页面
- 相应的把物理内存空间分成与页面大小的物理块
- 以页面为单位把进程空间装进物理内存中分散的物理块
- 页面大小应该适中，过大难以分配，过小内存碎片过多
- 页面大小通常是 512B - 8k

> 页表记录进程逻辑空间与物理空间的映射

- 现代计算机系统中，可以支持非常大的逻辑地址空间(2^32 - 2^64) ，这样，页表就变得非常大，要占用非常大的内存空间，如 具有 32 位逻辑地址空间的分页系统，规定页面大小为 4kb, 则在每个进程页表中的页表项可达 1M（2^20 个），如果每个页表项占有 1Byte, 故每个进程仅仅页表就要占用 1MB 的内存空间
- 将进程逻辑空间等分成若干大小的页面
- 相应的把物理内存空间分成与页面大小的物理块
- 以页面为单位把进程空间装进物理内存中分散的物理块
- 注意：如果有一段连续的逻辑分布在多个页面中，将大大降低执行效率

#### 6.10.2 段式存储管理

- 将进程逻辑空间划分为若干段（非等分）
- 段的长度由连续逻辑的长度决定
- 主函数 MAIN、子程序端 X、子函数 Y 等

注意：段式存储和页式存储都离散地管理了进程的逻辑空间，

- 页是物理单位，段是逻辑单位
- 分页是为了合理利用空间，分段是满足用户要求
- 页大小由硬件固定，段长度可动态变化
- 页表信息是一维的，段表信息是二维的

#### 6.10.3 段页式存储管理

- 分页可以有效提高内存利用率(虽说存在页内碎片)
- 分段可以更好满足用户需求
- 两者结合，形成段页式存储管理
- 先将逻辑空间按段式管理分成若干端
- 再把段内空间按页式管理等分为若干页

### 6.11 存储管理之虚拟内存

> 问题：一个游戏十几个 G, 物理内存只有 4G, 那么这个游戏是怎么运行起来的？

#### 6.11.1 虚拟内存概述

- 有些进程实际需要的内存很大，超过物理内存的容量
- 多道程序设计，使得每个进程可用物理内存更加稀缺
- 不可能无限增加物理内存，物理内存总有不够的时候
- 虚拟内存是操作系统内存管理的关键技术
- 使得多道程序设计和大程序运行成为现实
- 把程序使用内存划分，将部分暂时不使用的内存放置在辅存

#### 6.11.2 程序的局部性原理

> 局部性原理是指 CPU 访问存储器时，无论是存取指令还是读取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。

- 程序运行时，无需全部装入内存，装载部分即可
- 如果访问页不在内存，则发出缺页中断，发起页面置换
- 从用户层面看，程序拥有很大的空间，即是虚拟内存
- 虚拟内存实际就是对物理内存的补充，速度接近于内存，成本接近于辅存。

#### 6.11.3 虚拟内存的置换算法

- 先进先出算法（FIFO）
- 最不经常使用算法（LFU）
- 最近最少使用算法（LRU）

其次

- 替换策略发生在 Cache-主存层次、主存-辅存层次
- Cache-主存层次的替换策略主要是为了解决**速度问题**
- 主存-辅存层次主要是为了解决**容量问题**

### 6.12 Linux 的存储管理

#### 6.12.1 Buddy 内存管理算法

> 目的是努力让内存分配与相邻内存合并并能快速进行

- buddy 算法是经典的内存管理算法
- 算法基于计算机处理二进制的优势具有极高的效率
- 算法主要是为了解决**内存外碎片**的问题
- 页内碎片
  - 内部碎片是已经被分配出去(能够明确指出属于哪个进程)的内存空间大于请求所需的内存空间。不能被利用的内存空间就是内部碎片
- 页外碎片
  - 外部碎片是指还没有分配出去（不属于任何进程），但是由于大小而无法分配给申请内存空间的新进程的内存空闲块
- 内存分配原则
  - 向上取整数为 2 的幂大小：如果申请 70k 的内存，那就分配 128k 的内存；如果申请 129k 的内存，就分配 256 的内存；...
- 伙伴系统
  - 伙伴指的是内存中的伙伴
  - 一片连续内存的伙伴是相邻的另一片大小一样的连续内存
- 算法的具体流程
  - 创建一系列的空闲块链表，每一种都是 2 的幂
  - xxx

#### 6.12.2 Linux 交换空间

- 交换空间(Swap)是磁盘的一个分区
- Linux 物理内存饱满时，会把一些内存交换至 Swap 空间
- Swap 空间是初始化系统时候配置的
- 冷启动内存依赖
- 系统睡眠依赖
- 大进程空间依赖
- Swap 空间 VS 虚拟内存
  - Swap 空间存在于磁盘，虚拟内存存在于磁盘
  - Swap 空间与主存发生置换，虚拟内存与主存发生置换
  - Swap 空间是操作系统概念，虚拟内存是进程概念
  - Swap 空间解决系统物理内不足的问题，虚拟内存解决进程物理内存不足的问题

### 6.13 操作系统的文件管理

#### 6.13.1 文件的逻辑结构

1. 逻辑结构的文件类型

   - 有结构文件：文本文件 、文档、媒体文件

     - 文件内容由定长记录和可变长记录租场
     - 定长记录存储文件格式、文件描述等结构化数据项
     - 可变长记录存储文件具体内容

   - 无结构文件：二进制文件、链接库
     - 也成为流式文件
     - 文件内容以字节为单位

2. 顺序文件

   - 顺序文件是指按照顺序存放在存储介质中的文件
   - 磁带的存储特性使得磁带文件只能存储顺序文件
   - 顺序文件时所有逻辑文件当中存储效率最高的
   - 问题：顺序文件的增删改？这时候是很没有效率的

3. 索引文件

   - 可变长文件不适合顺序文件格式存储
   - 索引文件时为了解决可变长文件存储而发明的一种文件格式
   - 索引文件需要配合**索引表**完成存储的操作

#### 6.13.2 辅存的存储空间分配

1. 辅存的分配方式

   - 连续分配

     - 顺序读取文件内容非常容易，速度很快
     - 对存储要求高，要求满足容量的连续存储空间

   - 链接分配

     > 链接分配可以将文件存储在离散的盘块中
     >
     > 需要额外的存储空间存储文件的盘块链接顺序

     - 隐式链接分配
       - 隐式分配的下一个链接指向存储在当前盘块内
       - 隐式分配适合顺序访问，随机访问效率很低
       - 可靠性差，任何一个连接出问题都影响整个文件
     - 显式链接分配
       - FILE Allcation Table
       - 不支持高效的直接存储(FAT 记录项多)
       - 检索时 FAT 表占用较大的存储空间（需要将整个 FAT 加载到内存）
       - 把文件的所有盘块集中存储(索引)
       - 读取某个文件时，将文件索引读取进内存即可

   - 索引分配

     - 每个文件拥有一个索引块，记录所有盘块信息
     - 索引分配方式支持直接访问盘块
     - 文件较大时，索引分配方式觉有明显优势

2. 存储空间管理

   - 空闲表
     - 空闲盘区的分配与内存分配类似
     - 首次适应算法、循环适应算法等
     - 回收过程也与内存回收类似
   - 空闲链表
     - 空闲链表法把所有空闲盘区组成一个空闲链表
     - 每隔链表节点存储空闲盘块和空闲的数目
   - 位示图
     - 位示图维护成本很低
     - 位示图可以非常容易找到空闲盘块
     - 位示图使用 0/1 比特位，占用空间很小

#### 6.13.3 目录管理

1. 目录树
   - 任何文件或者目录都只有唯一路径

### 6.14 Linux 文件的基本操作

#### 6.14.1 Linux 目录

1. 根目录：/bin, /etc/ /home /usr /opt /proc /dev /mnt /lib /var ...

   | 目录  | 描述                                                                                                                                                                                                                                                                                                                                                                  |
   | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | /bin  | bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。                                                                                                                                                                                                                                                                                                 |
   | /etc  | etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。                                                                                                                                                                                                                                                                                 |
   | /home | 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。                                                                                                                                                                                                                                               |
   | /usr  | usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。                                                                                                                                                                                                             |
   | /opt  | opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。                                                                                                                                                                                                                                    |
   | /proc | proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br/>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： |
   | /root | 该目录为系统管理员，也称作超级权限者的用户主目录。                                                                                                                                                                                                                                                                                                                    |
   | /sbin | s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。                                                                                                                                                                                                                                             |
   | /dev  | dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。                                                                                                                                                                                                                                                    |
   | /mnt  | 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。                                                                                                                                                                                                                                             |

2. 相对路径

3. 绝对路径

#### 6.14.2 Linux 文件常用操作

- （目录/文件）创建、删除、读取、写入

#### 6.14.3 Linux 文件类型

- 套接字
- 普通文件
- 目录文件
- 符号链接
- 设备文件
- FIFO

### 6.15 Linux 的文件系统

#### 6.15.1 文件系统

> FAT、NTFS、EXT2/3/4

1. FAT：File Allocation Table
   - FAT16、FAT32 等，微软 DOS/Windows 使用的文件系统
   - 使用一张表保存盘块的信息
2. NTFS: New Technology File System
   - WindowNT 环境的文件系统
   - NTFS 对 FAT 进行了改进，取代了旧的文件系统
3. EXT Extended File system 扩展文件系统
   - Linux 的文件系统
   - EXT2/3/4：数字表示第几代

#### 6.15.2 Ext 文件系统

- Boot Sector: 启动扇区，安装开机管理程序
- Block Group: 块组，存储数据的实际位置
- Inode Table
  - 存放文件 Inode 的地方
  - 每一个文件(目录)都有一个 lnode
  - 是每一个文件(目录)的 索引节点
- Inode 存放以下信息
  - 索引节点编号
  - 文件类型
  - 文件权限
  - 文件物理地址
  - 文件长度
  - 文件链接计数
  - 文件存放时间
  - 文件状态
  - 访问计数
  - 链接指针
  - ...
  - 文件名不是存放在 Inode 节点上的，而是存放在目录的 Inode 节点
  - 列出目录文件的时候无需加载文件的 Inode
- Inode bitmap
  - Inode 的位示图
  - 记录已经分配的 Inode 和 未分配的 Inode
- Data Block
  - Data Block 是存放文件内容的地方
  - 每一个 block 都有唯一的编号
  - 文件的 block 记录在文件的 Inode 上
- Block bitmap
  - 功能与 Inode bitmap 类似
  - 记录 Data block 的使用情况
- Superblock
  - 记录整个文件系统相关信息的地方
  - Block 和 Inode 的使用情况
  - 时间信息、控制信息等

### 6.16 操作系统的设备管理

#### 6.16.1 广义的 IO 设备

> 对 CPU 而言，凡是对 CPU 进行数据输入的都是输入设备
>
> 对 CPU 而言，凡是 CPU 进行数据输出的都是输出设备

1. 按使用特性分类
   - 存储设备：U 盘、内存、磁盘等
   - 交互 IO 设备：键盘、鼠标、显示器等
2. 按信息交换的单位分类
   - 块设备：磁盘、SD 卡
   - 字符设备：打印机、Shell 终端
3. 按设备的共享属性分类
   - 独占设备
   - 共享设备
   - 虚拟设备
4. 按传输速率分类
   - 低速设备
   - 中速设备
   - 高速设备

#### 6.16.2 IO 设备的缓冲区

> CPU 与 IO 设备的速率不匹配问题

- 减少 CPU 处理 IO 请求的频率
- 提高 CPU 与 IO 设备之间的并行性

#### 6.16.3 SPOOLing 技术

- 是关于慢速字符设备如何与计算机主机交换信息的一种技术
- 利用高速共享设备将低速的独享设备模拟为高速的共享设备
- 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备

### 6.17 操作系统基础篇专项练习题 39 道

### 6.18 专项练习题答案揭晓与解析

### 6.19 请回答操作系统是如何启动的？

## 7 操作系统之提升篇

### 7.1 本章节知识点概要与学习计划

1. 线程同步
2. 进程同步
3. 既是重要的理论知识，也是重要的实践知识
4. 笔试面试、开发高性能服务等都非常有用

### 7.2 线程同步之互斥量

- 两个线程的指令交叉执行
- 互斥量可以保证先后执行
- 原子性
  - 原子性是指一系列操作不可被中断的特性
  - 这一系列操作要么全部执行完成，要么全部没有执行
  - 不存在部分执行部分未执行的情况
- 互斥量是最简单的线程同步的方法
- 互斥量（互斥锁），处于两态之一的变量 ：解锁和加锁
- 两个状态可以保证资源访问的串行
- 操作系统直接提供了互斥量的 API
- 开发者可以直接使用 API 完成资源的加载、解锁操作
- pthread_mutex_t

### 7.3 线程同步之自旋锁

> 死循环等待锁被释放

- 自旋锁也是一种多线程同步的变量
- 使用自旋锁的线程会反复检查锁变量是否可用
- 自旋锁不会让出 CPU，是一种**忙等待**状态
- 自旋锁避免了进程或线程上下文切换的开销
- 操作系统内部很多地方使用的是自旋锁
- 自旋锁不适合在单核 CPU 使用
- pthread_spinlock_t

### 7.4 线程同步之读写锁

- 读写锁是一种特殊的自旋锁
- 允许多个读者同时访问资源以提高性能
- 对于读写操作则是互斥的
- pthread_rwlock_t

### 7.5 线程同步之条件变量

- 缓冲区小于等于 0 时，不允许消费者消费，消费者必须等待
- 缓冲区满时，不允许生产者往缓冲区生产，生产者必须等待
- 当生产者生产一个产品时，唤醒可能等待的消费者
- 当消费者消费一个产品时，唤醒可能等待的生产者
- 条件变量是一种相对复杂的线程同步方法
- 条件变量允许线程睡眠，直到满足某种条件
- 当满足条件时，可以向该线程发送信号，通知唤醒

### 7.6 线程同步方法总结

- 互斥量、自旋锁、读写锁
- 条件变量：加锁保护条件变量、等待条件满足被唤醒、解锁

| 同步方法 | 描述                                                 |
| -------- | ---------------------------------------------------- |
| 互斥锁   | 最简单的一种线程同步方法，会阻塞线程                 |
| 自旋锁   | 避免切换的一种线程同步方法，属于忙等到               |
| 读写锁   | 为读多写少的资源设计的线程同步方法，可以显著提高性能 |
| 条件变量 | 相对复杂的一种线程同步方法，有更灵活的使用场景       |

### 7.7 使用 fork 系统调用创建进程

- Fork 系统调用是用于创建进程的
- fork 创建的进程初始化状态与父进程一样
- 系统会为 fork 进程分配新的资源
- Fork 系统调用无参数
- Fork 会返回两次，分别返回 子进程 id 和 0
- 返回子进程 id 的是父进程，返回 0 的是子进程

### 7.8 进程同步之共享内存

- 在某种程度上，多进程是共同使用物理内存的
- 由于操作系统的进程管理，进程间的内存空间是独立的
- 进程默认是不能访问进程空间之外的内存空间的
- 共享存储允许不相关的进程访问同一片物理内存
- 共享内存是两个进程之间共享和传递数据最快的方式
- 共享内存未提供同步机制，需要借助其他机制管理访问
- 步骤：申请共享内存=》连接到进程空间=》使用共享内存=》脱离进程空间&删除
- 共享存储是两个进程之间共享和传递数据最快的一种方式
- 共享内存未提供同步机制，需要借助其他机制管理访问
- 共享内存是高性能后台开发中最常用的进程同步方式

### 7.9 进程同步之 Unix 域套接字

- 域套接字是一种高级的进程间通信的方法
- Unix 域套接字可以用于同一机器进程间通信
- 套接字(socket) 原是网络通信中使用的术语
- Unix 系统提供的域套接字提供了网络套接字类似的功能
- 服务端使用步骤
  - 创建套接字=》绑定套接字=》监听套接字=》接收&处理信息
- 客户端使用步骤
  - 创建套接字=》链接套接字=》发送信息
- 提供了单击简单可靠的进程通信同步服务
- 只能在单击使用，不能跨机器使用

### 7.10 请拓展调研进程间通信还有那些方法

## 8 操作系统实践

### 8.1 本章节知识概要与学习计划

了解 Python 的同步原语 =》 实现线程安全的队列=》实现基本任务对象=》了解线程池=》实现任务处理线程=》实现任务处理线程池=》实现异步任务处理对象

### 8.2 Python 同步原语

#### 8.2.1 互斥量

#### 8.2.2 条件变量

### 8.3 实现线程安全的队列 Queue

- 队列用于存放多个元素，是存放各种元素的“池”
  - 实现线程安全的队列
    - 获取当前队列元素数量
    - 往队列放入元素
    - 从队列取出元素
- 队列可能有多个线程同时操作，因此需要保证线程安全
  - 多个线程同时访问队列元素时候，为了保证多个线程获取的串行，需要使用“锁”保护队列
  - 队列元素为空时获取队列元素，阻塞，等待队列不为空 =》 使用条件变量等待队列元素

### 8.4 实现基本任务对象 Task

### 8.5 线程池简介

### 8.6 实现任务处理线程 ProcessThread

### 8.7 实现任务处理线程池 Pool

### 8.8 编写测试用例

### 8.9 实现异步任务处理 AsyncTask

## 9 计算机网络之概述篇

### 9.1 本章节知识概要与学习计划

#### 9.1.1 什么是计算机网络

> 计算机网络主要由一些通用的、可编程的硬件互链而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增长的应用。

- 计算机网络不仅仅是软件概念，还包含了硬件设备
- 计算机网络不仅仅是信息通信，还可以支持广泛的应用

#### 9.1.2 计算机网络的分类

- 网络的作用范围分类

  - 广域网 WAN

  - 城域网 MAN

  - 局域网 LAN

  - | 分类   | 英文                    | 范围           | 区域       |
    | ------ | ----------------------- | -------------- | ---------- |
    | 广域网 | WAN：Wide Area Network  | 几十到几千公里 | 跨省、跨国 |
    | 城域网 | MAN：Metro Area Network | 5KM-50Km       | 城市间     |
    | 局域网 | LAN：Local Area Network | 1km 以内       | 地区内     |

- 网络的使用者分类

  - 公用网络
  - 专用网络

#### 9.1.3 本章内容概览

1. 计算机网络概述
   - 发展历史、层次结构
   - 网络拓扑、性能指标
2. 物理层
   - 物理层概述
3. 数据链路层
   - 数据链局层概述、差错监测
   - 最大传输单元 MTU、以太网协议

### 9.2 计算机网络的发展简史

#### 9.2.1 互联网的发展历史

1. 第一阶段：单个网络 ARPANET

   - 交换机

2. 第二阶段：三级结构互联网

   - 主干网 + 地区网 + 校园网

3. 第三阶段：多层次 ISP 互联网：

   - Internet Service Provider 网络服务提供商

   - 中国电信、中国移动、中国联通等
   - 网络结构：主干 ISP + 地区 ISP + 公司/ 校园 / 家庭 / 其他的

#### 9.2.2 中国互联网的发展简史

1. 1908 年开始互联网实验
2. 1989 年第一个公共网络建立运行
3. 1994 年接入国际互联网
4. 规模较大的公共网络
   - 中国电信互联网 CHINANET
   - 中国联通互联网 UNINET
   - 中国移动互联网 CMNET
   - 中国教育与科研计算机网 CERNET
   - 中国科学技术网 CSTNET
5. 民间的互联网
   - 1996 年 张朝阳创建搜狐
   - 1997 年，丁磊创建网易
   - 1998 年，王志东创建新浪
   - 1998 年，马化腾、张志东创建腾讯
   - 1999 年，马云创建阿里巴巴
   - 2000 年，李彦宏创建百度
   - ....

### 9.3 层次结构设计的基本原则

#### 9.3.1 层次结构设计的基本原则

> 为什么要使用层次结构设计？
>
> 计算机网络需要解决的问题：保证数据通路顺畅、识别目的计算机、目的计算机状态、数据是否错误等
>
> 分层实现不同的功能，所以采用层次结构设计

1. 网络应用数据：视频、文件、游戏
2. 数据可靠通信：数据错误、重复
3. 物理网络接入：光电等物理特性

设计的基本原则

- 各层之间是相互独立的
- 每一层要有足够的灵活性
- 各层之间完全解耦

#### 9.3.2 OSI 七层模型

1. 七层模型

   1. 应用层：为计算机用户提供接口和服务
   2. 表示层：数据处理（编码解码、加密解密等
   3. 会话层：管理（建立、维护、重连）通信会话
   4. 传输层：管理端到端的通信链接
   5. 网络层：数据路由（决定数据在网络的路径）
   6. 数据链路层：管理响铃节点之间的数据通信
   7. 物理层：数据通信的光电物理特性

2. 特性

   - OSI 欲成为全球计算机都遵循的特性

   - OSI 在市场化过程中困难重重，TCP/IP 在全球范围内成功运行

   - OSI 最终并没有成为广为使用的标准模型

3. 为什么没有被市场完全接受，原因如下：

   - OSI 的专家缺乏实际经验

   - OSI 标准制定周期过长，按照 OSI 标准生产的设备无法及时进入市场
   - OSI 模型设计的并不合理，一些功能在多层中重复出现

#### 9.3.3 TCP/IP 四层模型

1. 四层模型
   1. 应用层：映射 OSI 中的应用层、表示层、会话层，主要是 HTTP/FTP/...等协议
   2. 传输层：映射 OSI 的 传输层，主要是 TCP/UCP 协议等
   3. 网络层：映射 OSI 的网络层，主要是 IP/ICMP 协议等
   4. 网络接口层：映射 OSI 的数据链路层、物理层，主要是 Ethernet/ARP/RARP 协议等
2. 实际应用

### 9.4 现代互联网的网络拓扑

#### 9.4.1 边缘部分

1. 边缘部分：家庭
   - 终端机器：电脑、智能家电、手机 =》 路由器 =》 网关 =》 地区 ISP
2. 边缘部分：企业：
   - 终端 =》 就近的路由器 =》就近的内网网关 =》 统一网管 =》 地区 ISP

#### 9.4.2 核心部分

主干 ISP

树状结构

客户-服务器（C/S）模式

对等链接（P2P）模式

### 9.5 计算机网络的性能指标

1. 速率

   - Bps = bit/s

2. 时延

   - 发送时延：

     发送时延 = 数据长度(bit) / 发送速率（受限于计算机网卡）（bit/s）

   - 传播时延

     传播时延 = 传输路径距离 / 传播速率（受限于传输介质）（bit/s）

   - 排队时延

     - 数据包在网络设备中等待被处理的时间

   - 处理时延

     - 数据包到达设备或者目的机器被处理所需要的时间

   - 总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延

3. 往返时间 RTT

   - RTT: Route-Trip Time 是评估网络质量的一项重要指标
   - RTT 表示的是数据报文在端到端通信中的来回一次的时间
   - 通常使用 ping 命令来查看 RTT

### 9.6 物理层概述

#### 9.6.1 物理层的作用

1. 物理层的作用
   - 链接不同的物理设备
   - 传输比特流
2. 介质
   1. 双绞线
      1. 无屏蔽双绞线
      2. 屏蔽双绞线
   2. 同轴电缆
   3. 光纤
   4. 红外线、无线、激光
3. 比特流
4. 物理特性
   1. 机械特性
   2. 电气特性
   3. 功能特性
   4. 过程特性

#### 9.6.2 信道的基本概念

- 信道是往一个方向传送信息的媒体
- 一条通信电路包含一个接收信道和一个发送信道
- 问题：发送和接收会不会冲突？冲突了怎么办？
  - 单工通信信道
    - 只能一个方向通信，没有反方向反馈的信道
    - 有线电视、无线电视收音机等等
  - 半双工通信通道
    - 双方都可以发送和接收信息
    - 不能双方同时发送，也不能同时接收
  - 全双工通信通道
    - 双方都可以发送和接收信息

#### 9.6.3 分用-复用技术

- 频分复用
- 时分复用
- 波分复用
- 码分复用

### 9.7 数据链路层概述

1. 要解决的问题
   - 封装成帧
     - 帧 是数据链路层数据的基本单位
     - 发送端在网络层的一段数据前后添加特定标记形成 帧
     - 接收端根据前后特定标记识别出 帧
     - 物理层不管你 帧 不帧
     - 帧首部和尾部是特定的控制字符（特定比特流）
   - 透明传输
     - 透明 在计算机领域是非常重要的一个术语
     - 一种实际存在的事物却又看起来不存在一样
     - 即是控制字符在帧数据中，但是要当做不存在的去处理
     - 编程语言中 \ 一般为转义字符
     - \n \t 等控制字符
   - 差错检测
     - 物理层只管传输比特流，无法控制是否出错
     - 数据链路层负责起“差错监测”的工作

### 9.8【 讨论题】在数据链路层和物理层中工作的设备都有哪些？

### 9.9 数据链路层的差错监测

#### 9.9.1 奇偶校验码

#### 9.9.2 循环冗余校验码 CRC

- 一种根据传输或保存的数据而**产生固定位数校验码**的方法
- **检测** 数据传输或者保存后可能出现的错误
- 生成的数字计算出来并且附加到数据后面
- 模 2 除法
  - 模 2 除法是二进制下的除法
  - 与算术除法类似，但除法不错位，实际是“异或”操作
- 步骤
  - 选定一个用于校验的多项式 G(x),并在数据尾部添加 r 个 0
  - 将添加 r 个 0 后的数据，使用模 2 除法 除以 多项式的位串
  - 得到的余数填充在原数据 r 个 0 的位置得到可校验的位串
- CRC 的错误检测能力与位串的阶数 r 有关
- 数据链路层只进行数据的检测，不进行纠正

### 9.10 最大传输单元 MTU

1. MTU

   - 最大传输单元 MTU：maximum transmission Unit

   - 数据链路层的数据帧也不是无限大的

   - 数据帧过大或者过小都会影响传播的效率

2. 路径 MTU

   - 路径 MTU 由链路中 MTU 的最小值决定

### 9.11 以太网协议详解

> 问题：路由器怎么知道 A 要发送给谁

#### 9.11.1 MAC 地址

- MAC 地址（物理地址、硬件地址）
- 每一个设备都拥有唯一的 MAC 地址
- MAC 地址共 48 位，使用十六进制表示

#### 9.11.2 以太网协议

- 以太网是一种使用广泛的局域网技术
- 以太网是一种应用于数据链路层的协议
- 使用以太网可以完成**相邻设备**的数据帧传输
- 步骤
  - A 通过网卡发出数据帧
  - 数据帧到达路由器，路由器取出前 6 字节
  - 路由器匹配 MAC 地址列表，找到对应的网络接口
  - 路由器往该网络接口发送数据帧

### 9.12 计算机网络概述篇专项练习题 19 道&面试常考题分享

### 9.13 专项练习题答案揭晓与解析

## 10 计算机网络之网络层篇

### 10.1 章节导学

### 10.2 ip 协议详解

#### 10.2.1 虚拟互连网络

- 实际的计算机网络是错综复杂的
- 物理设备通过使用 IP 协议，屏蔽了物理网络之间的差异
- 当网路中的主机使用 IP 协议连接时，则无需关注网络细节

#### 10.2.2 IP 协议

- IP 协议使得复杂的实际网络变为一个虚拟互链的网络

- IP 协议使得网络蹭层可以屏蔽底层细节而专注网络层的数据转发

- IP 协议解决了在虚拟网络中数据传输路径的问题

- IP 地址长度分为 32 位，常分为 4 个 8 位

- IP 地址常使用点分十进制来表示（0~255.0~255.0~255.0~255）

- 信息如下

- <table>     
    <tr>         
      <th>4位版本</th>
      <th>4位首部长度</th>
      <th>8位服务类型(TOS)</th>     
      <th colspan="2">16位总长度（字节）</th>   
    </tr>     
    <tr>         
      <td colspan="3">16位标识</td>
      <td>3位标志</td>
      <td>13位偏移</td>     
    </tr>     
    <tr>         
      <td>8位生存时间（TTL）</td>
      <td>8位协议</td>
      <td colspan="2">16位首部校验和</td>  
    </tr>     
    <tr>         
      <td colspan="5">32位源IP地址</td>、   
    </tr> 
    <tr>         
      <td colspan="5">32位目的IP地址</td>   
    </tr>
    <tr>         
      <td colspan="5">选项options(若有)</td>   
    </tr>
    <tr>         
      <td colspan="5">IP数据</td>   
    </tr>
  </table>

- 版本：占 4 位，指的是 IP 协议的版本，通信双方的版本必须一致，当前主流版本是 4，即 IPV4, 也有 IPV6

- 首部位长度：占 4 位，最大数值为 15，表示的是 IP 首部长度，单位是 32 位字（4 个字节），也即是 IP 首部最大长度为 60 字节

- 总长度：占 16 位，最大数值为 65535，表示的是 IP 数据包总长度（IP 首部+IP 数据）

- TTL：占 8 位，表明 IP 数据报文在网络中的寿命，每经过一个设备，TTL 减 1，当 TTL=0 时，网络设备必须丢弃该报文

- 协议：占 8 位，表明 IP 数据所携带的具体数据是什么协议的（如 TCP、UDP 等）

- 源 IP 地址

- 目的 IP 地址

### 10.3 ip 协议的转发流程

- 逐跳 hop-by-hop

#### 10.3.1 路由表简介

- 计算机或者路由器都拥有路由表

#### 10.3.2 IP 协议的转发流程

1. 步骤

   - A 发布目的地为 C 的 IP 数据包，查询路由表发现下一跳为 E

   - A 将数据报发送给 E

   - E 查询路由表发现下一跳为 F，将数据包发送给 F

   - F 查询路由表发现目的地 C 直接链接，将数据包发送给 C
   - ...

2. 特点

   - 数据帧的每一跳的 MAC 地址都在变化
   - IP 数据报每一跳的 IP 地址始终不变

### 10.4 arp 协议与 rarp 协议

- (R)ARP 协议是 TCP/IP 协议栈里面最基础的协议
- ARP 和 RARP 的操作对程序员是透明的
- 理解（R）ARP 协议有助于理解网络分层的细节

- ARP: address resolution protocol 地址解析协议
- ARP 缓存表
  - ARP 缓存表缓存有 IP 地址和 MAC 地址的映射关系
  - ARP 缓存表没有缓存 IP 地址和 MAC 地址的映射关系
  - ARP 缓存表是 ARP 协议和 RARP 协议运行的关键
  - ARP 缓存表缓存了 IP 地址到硬件地址之间的映射关系
  - ARP 缓存表中的记录并不是永久有效的，有一定的期限
- RARP: Reverse Address Resolution Protocol 逆地址解析协议

### 10.5 IP 地址的子网划分

#### 10.5.1 分类的 IP 地址

1. 特殊的主机号

   - 主机号全 0 表示当前网络段，不可分配为特定主机
   - 主机号为全 1 表示广播地址，向当前网络段所有主机发消息

2. 特殊的网络号

   - A 类地址网络段全 0（00000000）表示特殊网络
   - A 类地址网络段后 7 位全 1（01111111:127）表示回环地址
   - B 类地址网络段（10000000.00000000:128.0）是不可使用的
   - C 类地址网络段（192.0.0）是不可使用的

3. 127.0.0.1

   127.0.0.1 通常被称为本地回环地址（loopback address），不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在 Windows 操作系统中也有相似的定义，所以通常在安装网卡前就可以 ping 通这个本地回环地址，一般都会用来检查本地网络协议、基本数据接口等是否是正常的

#### 10.5.2 划分子网

1. 子网掩码
   - 子网掩码和 IP 地址一样，都是 32 位
   - 子网掩码由连续的 1 和连续的 0 组成
   - 某一个子网的子网掩码具备网络号位数个连续的 1

#### 10.5.3 无分类编址 CIDR

- CIDR 中没有 A B C 类网络号和子网划分的概念
- CIDR 将网络前缀相同的 IP 地址称为一个 CIDR 地址块
- 斜线记法

### 10.6 网络地址转换 nat 技术

1. 原因：
   - IPV4 最多只有 40+亿个 IP 地址
   - 早起 IP 地址的不合理规划导致 IP 号浪费
2. 类型
   - 内网地址
     - 内部机构使用
     - 避免与外网地址重复
   - 外网地址
     - 全球范围使用
     - 全球公网唯一
3. 网络地址转换 NAT：Network Address Translation
   - NAT 技术用于多个主机通过一个共有 IP 访问互联网的私有网络中
   - NAT 减缓了 IP 地址的消耗，但是增加了网络通信的复杂度

### 10.7 ICMP 协议详解

1. 网络控制报文协议（Internet Control Message Protocol）
   - ICMP 协议可以报告错误信息或者异常情况

### 10.8 icmp 协议的应用

#### 10.8.1 Ping 应用

- ping 回环地址 127.0.0.1
- Ping 网关地址
- Ping 远端地址

#### 10.8.2 Traceroute 应用

- Traceroute 可以探测 IP 数据报在网络中走过的路径
- TTL：占 8 位，表明 IP 数据报文在网络中的寿命，每经过一个设备，TTL 减 1，当 TTl=0 时，网络设备必读丢弃该报文

### 10.9 网络层的路由概述

1. 路由算法的本质

   - 下一跳地址是怎么来的
   - 下一跳地址是唯一的吗？
   - 下一跳地址是最佳的吗？
   - 路由器那么多，他们是怎么协同工作的？

   > 需要一个好的算法去解决这些事情

2. 路由算法实际上是图论的算法，实际上，路由算法比图论的算法更复杂

3. 特点

   - 算法是**正确**的、**完整**的
   - 算法在计算上应该尽可能的**简单**
   - 算法可以**适应网络中的变化**
   - 算法是**稳定**的和**公平**的
   - 互联网的规模是非常大的
   - 互联网环境是非常复杂的

4. 对互联网进行划分

   - 自治系统：Automomous system
     - 一个自治系统 AS 是处于一个管理机构下的网络设备群
     - AS 内部网络自行管理，AS 对外提供一个或者多个出(入)口
     - 自治系统内部的路由的协议称为：内部网关协议（RIP、OSPF）
     - 自治系统外部路由的协议称为：外部网关协议（BGP）

### 10.10 内部网关路由协议之 rip 协议

#### 10.10.1 距离矢量（DV）算法

- 每一个节点都使用两个向量 Di 和 Si
- Di 描述的是当前节点到别的节点的距离
- Si 描述的是当前节点到别的节点的下一节点
- 每一个节点与相邻的节点交换向量 Di 和 Si 的信息
- **每一个节点根据交换的信息更新自己的节点信息**

#### 10.10.2 RIP 协议的过程

- RIP：Routing information protocol 协议
- RIP 协议是使用 DV 算法的一种路由协议
- RIP 协议把网络中的跳数 hop 作为 DV 算法的距离
- RIP 协议每隔 30s 交换一次路由信息
- RIP 协议认为跳数 > 15 的路由则为不可达路由

1. 特点
   - Rip 协议：实现简单，开销很小
   - RIP 协议：限制了网络的规模
   - RIP 协议：“坏消息传的慢”，更新收敛时间过长

### 10.11 dijkstra（迪杰斯特拉）算法

- Dijkstra 算法是著名的图算法
- Dijkstra 算法解决有权图从一个节点到其他节点的最短路径问题
- 以起始点为中心，向外层层扩散

### 10.12 内部网关路由协议之 OSPF 协议

#### 10.12.1 链路状态（LS）协议

特点

- 向所有的路由器发送消息：一传十、十传百，并且只和相邻的路由器交互消息
- 消息描述该路由器与相邻路由器的链路状态：距离、时延、贷款。。。
- 只有链路状态发生变化时，才发送更新消息：每隔 30s 交互路由信息

#### 10.12.2 OSPF 协议的过程

- OSPF：Open Shortest Path First 开放最短路径优先

- OSPF 协议的核心是 Dijkstra 算法

- 特征如下

  - 向所有的路由器发送消息：获得网络中的所有消息=》网络中的完整拓扑
    - 也成为链路状态数据库
    - 链路状态数据库是全网一致的
  - 消息描述该路由器与相邻路由器的**链路状态**
  - 只有链路状态发生变化时，才发送更新消息
    - 减少了数据的交换，更快收敛

- 五种消息类型

  - 问候消息（hello）
  - 链路状态数据库描述信息
  - 链路状态请求消息
  - 链路状态更新消息
  - 链路状态确认消息

- 过程

  - 路由器接入网络 =》 路由器向邻居发出问候消息 =》与邻居交流链路状态数据库 =》 广播和更新未知路由

- 比较

  | RIP 协议                 | OSPF 协议                        |
  | ------------------------ | -------------------------------- |
  | 丛邻居看网络             | 整个网络的拓扑                   |
  | 在路由器之间累加距离     | Dijkstra 算法计算最短路径        |
  | 频繁、周期更新，收敛很慢 | 状态变化更新，收敛很快           |
  | 路由间拷贝路由信息       | 路由间传递链路状态，自行计算路径 |

### 10.13 外部网关路由协议之 BGP 协议

1. BGP
   - BGP：border gateway protocol 边际网关协议
   - BGP 协议是运行在 AS 之间的一种协议
2. 原因：
   - 互联网的规模很大
   - AS 内部使用不同的路由协议
   - AS 之间需要考虑除网络特性以外的一些因素（政治、安全。。。）
   - BGP 协议能够找到一条到达目的比较好的路由
3. BGP 发言人（speaker）
   - BGP 并不关心内部网络拓扑
   - AS 之间通过 BGP 发言人交流信息
   - BGP Speaker 可以人为配置策略

## 11 计算机网络之传输层

## 12 计算机网络之应用层篇

## 13 计算机网络实践

## 14 课程精髓终结
