# 编程必备基础

> 计算机组成原理+操作系统+计算机网络
>
> 计算机基础——更适合程序员的编程必备基础知识
>
> 文科生都能听懂学会／比大学课程学习体验更好／更贴近实际工作内容
>
> 60% 理论 + 30% 实践 + 10% 习题

## 1. 导论

### 1.1 计算机系必须专业课

计算机组成原理+操作系统+计算机网络 +（数据结构）

### 1.2 课程的目的

- 帮助大家形成计算机知识的结构体系
- 帮助大家理解计算机底层原理
- 帮助大家在工作实践中借鉴其中的优秀设计

### 1.3 学习这门可课程的原因

#### 1.3.1 互联网公司笔/面试逃不开的知识点

- 通过面试/笔试去考察同学的计算机基础知识
- 不是为了应付面试和笔试
- 关注自身方面技能的提升

#### 1.3.2 填补内容稀缺，补全短板

- 大家往往喜欢从项目入手，容易忽略后台和底层基础
- 线上关于基础知识的综合课程甚少

### 1.4 课程特点：

#### 1.4.1 内容扎实、夯实基础

- 课程内容是大学计算机系里面最重要的科目
- 目的是帮助大家夯实计算机基础知识

#### 1.4.2 知行合一、结合实践

- 为了避免学习过程的枯燥，课程加入了丰富的实践内容
  - 实践内容：缓存置换算法、线程池/异步任务、网络嗅探工具、也会穿插一些小实践

#### 1.4.3 内容重组、贴近实际

- 对内容进行了重组，突出重点，更加符合实际需求
  - 比如计算机组成原理部分，会摒弃硬件内容，专注软件逻辑与理论

#### 1.4.4 图解丰富、帮助理解

- 课程 PPT 做了很多非常多的工作，丰富的图解帮助内容的理解

### 1.5 环境说明

- Linux 环境：VMWare WorkStation + Linux 虚拟机
- 编程语言：C++, Phython

## 2. 计算机组成原理：概述篇

### 2.1 章节导学

- 计算机的发展简史
- 计算机的分类
- 计算机的体系结构
- 计算机的层次与编程语言
- 计算机的计算单位
- 计算机的字符与编码集

### 2.2 计算机发展简史

#### 2.2.1 计算机发展的四个阶段

1. 1946-1957 年：第一阶段，电子管计算机
2. 1957-1964 年：第二阶段，晶体管计算机
3. 1964-1980 年：第三阶段：集成电路计算机
4. 1980- 现 在：第四阶段：超大规模集成电路计算机

##### 2.2.1.1 第一个阶段：电子管计算机

电子管如图

<img src="https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/iiM3Ef.png" alt="image" style="zoom:50%;" />

1. 第二次世界大战是电子管计算机产生的催化剂：英国为了解密德国海军的密文

2. 计算机：埃尼亚克（ENIAC）

   - 出现的其他原因：

     - 战争使用了飞机和火箭
     - 打得准则需要计算射击参数
     - 射击参数需要几千次运算才能计算出来：（没有计算机前，需要人手算）

   - 内部构造
     - 18000 多个电子管
     - 运行耗电量 150 千瓦
     - 重量达 30 吨，占地 1500 平方英尺

3. 这个时期电子计算机的特点

   - 集成度小，占用空间大
   - 功耗高，运行速度相对慢
   - 操作复杂，更换程序时候需要重新接线

##### 2.2.1.2 第二个阶段：晶体管计算机

晶体管如图

<img src="https://pic.baike.soso.com/ugc/baikepic2/11234/cut-20180402112439-1223140248_jpg_2197_1464_388950.jpg/800" alt="image" style="zoom:70%;" />

1.  促使其发生的原因：贝尔实验室的三个科学家发明了晶体管

2.  著名的晶体管计算机：TX-0（诞生于 MIT 林肯实验室）、PDP-1（4k 内存，每秒可执行 200,000 指令，配备 512\*512 的显示器）

3.  这个时期电子计算机的特点

    - 集成度相对较高，空间占用相对较小

    - 功耗相对较低，运行速度较快

    - 操作相对简单，交互更加方便

##### 2.2.1.3 第三个阶段：集成电路计算机

集成电路计算机

<img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164654747-1929671686.png" alt="image" style="zoom:50%;" />

1. 促使其发生的原因：德州仪器的工程师发明了集成电路(IC)
2. 这时候计算机的特点
   - 计算机变得更小
   - 功耗变得更低
   - 计算速度变得更快
   - 此时：计算机具备了进入千家万户的条件
3. 这时候产生了操作系统
   - IBM 有两款计算机 7094、1401 卖的非常好，但是它们**主打功能不同**、**相互无法兼容**、**不愿意投入两组人力**，IBM 为了解决这个问题，推出了兼容的产品 System/360：它就是操作系统的雏形

##### 2.2.1.4 第四个阶段：超大规模集成电路计算机

1. 这时候计算机的特点
   - 一个芯片集成了上百万的晶体管
   - 速度更快，体积更小，价格更低，更能被大众接受
   - 用途丰富：文本处理、表格处理、高交互的游戏与应用
2. 不得不提的乔布斯
   - Apple 和 Apple 二代

##### 2.2.1.5 第五个阶段：未来的计算机(畅想篇)

###### 2.2.1.5.1 生物计算机

1. 以蛋白质分子作为主要原材料
2. 这时候计算机的特点
   - 提交小，效率高
   - 不易损坏，生物级别的自动修复
   - 不受信号干扰，无热损耗

###### 2.2.1.5.2 量子计算机

1. 遵循量子力学的物理计算机
2. 目前的研究成果
   - 2013 年 5 月，谷歌和 NASA 发布 D-Wave Two
   - 2017 年 5 月，中国科学院宣布制造出光量子计算机
   - 2019 年 1 月，IBM 展示了世界首款商业化量子计算机
   - 腾讯在 2017 年就组建了量子实验室
   - 阿里巴巴在 2017 年成立了达摩院
   -

#### 2.2.2 微型计算机的发展历史

> 主要从计算机发展历史的第三个阶段以后开始

1. 受限于性能：单核 CPU

<img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164748407-2075696834.png" alt="image" style="zoom:50%;" />

2. 关于 CPU 的性能，有一个著名的定律——**摩尔定律：集成电路的性能，每 18~24 个月就会提升一倍**。进入 21 世纪后，随着芯片的发展，芯片里面的电路越来越复杂，越来越密集，并且热损耗也越来越高，我们没有办法解决这样的问题，因此，该定律慢慢失效了。

3. 受限于单核 CPU 的性能瓶颈，于是发展出了多核 CPU。

 <img src="https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909164808683-1865841507.png" alt="image" style="zoom:50%;" />

#### 2.2.3 参考文档

[计算机发展历史](https://www.cnblogs.com/jvStarBlog/p/11941499.html)

### 2.3 计算机的分类

#### 2.3.1 超级计算机

1. 特点
   - 功能最强、运算速度最快、存储容量最大的计算机
   - 多用于国家高科技领域和尖端技术研究
   - 标记它们的运算速度的单位是 TFlop/s（1TFlop/s=每秒一万亿次浮点计算）
2. 截至 2018 年 11 月，全世界超级计算机排名前三的见下图。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190909171618101-1832074648.png)

为什么神威太湖之光的处理器个数远超 Summit，但算力还没有 Summit 高呢？这是因为神威太湖之光采用的全部是拥有自主知识产权的国产芯片。

3. 截至 2018 年 11 月，中国范围内排名前三的超级计算机

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a517b9cfa5294f85a4ad7989a771b612~tplv-k3u1fbpfcp-watermark.image?)

#### 2.3.2 大型计算机

- 又称为大型机、大型主机、主机等
- 具有高性能、可处理大量数据与复杂的运算
- 在大型机市场领域，IBM 占据着很大的份额
- 不得不提，去 IOE 行动：I 指 IBM(服务器提供商)、O 指 Oracle(数据库软件提供商)、E 指 EMC(存储设备提供商)。去 IOE 行动是阿里巴巴在 2008 年提出的概念，因为 IOE 代表了高维护费用的存储系统，并且也不够灵活，伸缩性弱

#### 2.3.3 迷你计算机(服务器)

> 迷你计算机，也称为小型机、普通服务器，具备不错的算力，可以完成较复杂的运算。它不像之前的超级计算机和大型计算机，很多公司（像华为、浪潮、联想等）都可以制造。现代背景下，很多公司已经将传统的大型机替换成了普通服务器，成为大规模企业计算的中枢。云服务厂商（比如阿里云、腾讯云等），也是使用普通服务器来构建自己的云服务和数据中心的。

1. 特点
   - 也被称为小型机，普通服务器
   - 不需要特殊的空调场所
   - 具备不错的算力，可以完成较复杂的运算

#### 2.3.4 工作站

> 工作站是高端的通用微型计算机，提供比个人计算机更强大的性能，类似于普通台式电脑，体积较大，但性能强劲，主要用于图像处理、动画设计、计算机辅助设计及制造 CAD/CAM 等领域。

- 高端的通用型微型计算机，提供比个人计算机更强到的性能
- 类似于普通台式电脑，体积较大，但性能强劲

#### 2.3.5 微型计算机

- 又被称为个人计算机，是最普通的一类计算机，分为：台式机、笔记本电脑、一体机
- 麻雀虽小，五脏俱全：从构成的本质上来讲，个人计算机与前面的分类无异

#### 参考文档

[计算机分类 ](https://www.cnblogs.com/jvStarBlog/p/11941502.html)

### 2.4 计算机的体系与结构

#### 2.4.1 冯诺依曼体系

> 指将程序指令和数据一起存储的计算机设计概念结构

1. 早期计算机仅固定用途程序，如果要完成其他功能需要更改结构，重新设计电路。结果就比较坑爹（不能先打游戏然后再写代码）
2. 后来把程序存储起来并设计通用电路，这样就是**存储程序指令设计通用电路**

所以，冯诺依曼体系有以下特点

- 必须有一个存储器
- 必须有一个控制器
- 必须有一个运算器
- 必须有输入设备
- 必须有输出设备

现代计算机都是冯诺依曼机。

由冯诺依曼体系所指导完成的计算机，必须有以下的几点功能：

- 能够把需要的程序和数据送至计算机中（由输入设备完成）
- 能够长期记忆程序、数据、中间结果及最终运算结果的能力（由存储器完成）
- 能够具备算术、逻辑运算和数据传送等数据加工处理的能力（由运算器、控制器完成）
- 能够按照要求将处理结果输出给用户（由输出设备完成）

冯诺依曼体系结构示意图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092431310-1662319731.png)

Tips: 我们可以看到，存储器和 CPU 是分开的，这就导致一个问题(**冯诺依曼瓶颈**)：CPU 和存储器速率之间的问题无法调和。因为 CPU 是高速运算的，处理速率极快，而存储器没有 CPU 快，到 CPU 的数据传输速度慢，这会导致 CPU 经常空转等待数据传输，这样子是非常浪费资源的

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092442177-174994148.png)

既然我们都知道了冯诺依曼体系存在的性能瓶颈，那么，如何解决呢？

#### 2.4.2 现代计算机的结构

现代计算机在冯诺依曼体系结构基础上进行了修改，**解决了 CPU 和存储设备之间的性能差异问题**。下面是现代计算机的结构示意图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910092451833-1194541326.png)

可以看到，跟前面不一样的是，运算器、控制器和存储器组成了现代计算机的 CPU。

存储器，从广义上，可以理解为存储数据的介质，包括磁带和硬盘。但是，这里的存储器主要是指围绕 CPU 的高速设备，包括寄存器和内存。现代计算机的结构，可以理解为以存储器为核心的结构。

关于存储器，还有很多需要理解的知识，我们会在后续文章里详细介绍。

#### 参考文档

[计算机体系与结构 ](https://www.cnblogs.com/jvStarBlog/p/11941506.html)

### 2.5 计算机的层次与编程语言

#### 2.5.1 程序翻译与程序解释

> 计算机是无法直接理解人类语言的，它只认识 01010101...这样的比特位，因此，我们需要进行程序翻译或程序解析，把人类语言翻译或解析成计算机所能理解的语言。
>
> 那么程序翻译和程序解析这两者之间有什么区别和联系呢？为了理解问题，我们引入两个语言，一个是较为高级的计算机语言——L1，另一个是较为低级的计算机语言——L0，我们接下来会使用这两个语言作为例子来理解什么是程序翻译，什么是程序解析。

##### 2.5.1.1 **程序翻译**

> 假设我们现在使用较为高级的计算机语言 L1 来进行程序的逻辑描述，也就是说我们使用 L1 来编写程序，那么这个由 L1 编写的程序是怎么样执行的呢？当然了，它不是直接执行的，而是在执行的时候生成一个逻辑等价的由低级语言 L0 组成的程序，这个 L0 是计算机实际执行的语言，那么由 L1 生成 L0 这个过程，我们称之为程序翻译，用于生成 L0 的工具叫编译器。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110418469-625827110.png)

##### 2.5.1.2 **程序解析**

> 同样的，假如我们使用 L1 来进行程序的逻辑描述，那么这个由 L1 编写的程序是怎样执行的呢？为了执行 L1，我们还需要使用 L0 实现另外一个程序，这个程序把 L1 程序作为输入来进行执行，每一句 L1 程序会在 L0 所实现的程序里面进行等价的转换，然后执行，这就是程序的解析，其中，使用 L0 实现的程序叫做解释器。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110459678-684415321.png)

##### 2.5.1.3 两者的总结

简要的总结程序翻译和程序解析：

1. 对于前面的两个例子而言，计算机执行的指令都是 L0
2. 翻译过程生成新的 L0 程序，解释过程不生成新的 L0 程序
3. 解释过程由 L0 编写的解释器去解释 L1 程序

理解了程序翻译和程序解释，我们来看下常见的编程语言，哪些语言是翻译型语言，哪些是解释型语言，如下图：

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110523773-543959654.png)

对于常见的，我们还有 Java 和 C#，它们又属于哪种语言呢？其实，严格的来说，它们既不属于翻译型语言，也不属于解释型语言，它们是属于**翻译+解释型**语言。

如何理解翻译+解释型语言呢？以 Java 程序的运行过程为例，Java 程序首先会被编译器编译成 JVM 字节码，然后会通过解释器解释成机器码，从而被计算机执行。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110537130-675156249.png)

#### 2.5.2 计算机的层次与编程语言

1. 按层次来划分计算机系统的话，我们可以划分成七个层次(分层的目的是为了便于理解)

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110546659-1074892489.png)

2. 下面逐一介绍每一层。

   - **硬件逻辑层**：主要由门电路、触发器等逻辑电路组成，属于电子工程的领域，这里就不展开介绍了。
   - **微程序机器层**：编程语言主要是微指令集，微指令所组成的微程序直接交由硬件执行，主要是由生产硬件的公司的程序员来编写的。
   - **传统机器层**：编程语言主要是 CPU 指令集（机器指令），和硬件是直接相关的，程序员所用机器指令编写的程序可以交由微程序直接进行解析，而这里提到的指令集，存储在 CPU 内部，对 CPU 的运算进行指导和优化，拥有指令集，CPU 就可以有效地运行。我们知道，CPU 的制造商分为 AMD 和 Intel 两大阵营，那么这两大厂商生产的 CPU 最大的区别是——指令集不同，Intel 的 CPU 所使用的指令集不适合 AMD 的 CPU，同样的，AMD 的 CPU 所使用的指令集也不适合 Intel。除了不同厂商以后，同一个厂商也可以生产不同指令集的 CPU，即不同架构的 CPU 使用不同的 CPU 指令集。

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190910110608700-1159855373.png)

   - **操作系统层**：操作系统，一方面，**向上提供了简易的操作界面，使得用户能够容易地操作计算机**；同时，**向下对接了指令系统，管理硬件资源**。操作系统对用户程序所使用机器的各种资源进行管理和分配，包括 CPU、存储器等等，比如说，当一个用户程序需要运行的时候，首先由操作系统将其加载到内存中，这就需要操作系统首先为其分配内存空间来进行存储。再比如说，某一个程序需要使用某一个输出设备进行结果输出的时候，需要操作系统为其提供该设备的控制权。由此可见，**操作系统是在软件和硬件之间的适配层**。
   - **汇编语言层**：编程语言是**汇编语言**，汇编语言可以**翻译**成可直接执行的机器语言，完成这个翻译过程的程序就是汇编器。从这一层开始，它们所使用的编程语言就是人类比较容易理解的语言了。
   - **高级语言层**：编程语言就是为广大程序员所接受的高级语言，种类非常多，有几百种，常见的编程语言有 Python、Java、C/C++、Golang 等。
   - **应用层**：计算机针对某种用途而设计的应用，像 Word、Excel 等。

#### 参考文档

[计算机层次与编程语言 ](https://www.cnblogs.com/jvStarBlog/p/11941513.html)

### 2.6 计算机的计算单位

#### 2.6.1 容量单位

在日常生活中，我们常说，200M 的光盘、8G 的内存、2T 的硬盘，这里的 M、G、T 就是容量单位，那么它们各自代表着什么含义以及它们之间是如何换算的呢？

在**计算机的物理层面，用高低电平记录信息，高电平代表 1，低电平代表 0，计算机只认识 0 和 1 两种状态**，这里的 0 或 1 我们就称为一个 bit（比特位），但是 0/1 能够表示的内容太少了，需要更大的容量表示方法，因此人们用 8 个比特位来表示一个字节（byte），一个字节等于八个比特位。随着计算机的发展，存储容量越来越大，用字节来表示容量也显得很不方便了，于是，出现了更高的容量单位。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190911215426335-1924506467.png)

上图是现在常见常使用的计算机容量单位，可以看到，1Byte=8bit，1KB=1024Byte，1MB=1024KB ... ...

#### 2.6.2 速度单位

这部分内容包括：网络速度和 CPU 频率

##### 2.6.2.1 **网络速度**

装宽带的时候，我们常说 50M 宽带、100M 宽带，这里的 M 不是容量单位，而是网络速度——带宽，单位是 Mbps(兆位/秒)，前面只是省略了 bps。

比如电信拉的是 100M 光纤，测试峰值速度只有 12M 每秒？为什么呢？因为网络常用单位是 Mbps,

100M/s = 100Mbps = 100Mbit/s

100Mbit/s = (100/8)MB/s = 12.5MB/s

##### 2.6.2.2 **CPU 频率**

CPU 的速度一般体现为 CPU 的时钟频率，也称为主频，单位为赫兹（Hz），是评定 CPU 性能的重要指标，主流 CPU 的时钟频率都在 2GHz 以上。

赫兹是国际单位制中频率的单位，是每秒中的周期性变动重复次数的计量，当用来描述计算机的 CPU 时，表达的是高低电平每秒钟变换的次数，主频越高，一个时钟周期里面完成的指令数也越多，2GHz，就是说每秒高低电平变换 20 亿次。

#### 参考文档

[计算机的计量单位 ](https://www.cnblogs.com/jvStarBlog/p/11941519.html)

### 2.7 计算机的字符与编码集

#### 2.7.1 字符编码集的历史

##### 2.7.1.1 **ASCII**

- 使用 7 个 bits 就可以完全表示 ASCII 码
- 包含 95 个可打印字符
- 33 个不可打印字符(包含控制字符)
- 33+95 = 128 = 2^7

对于 ASCII 码，相信大家在平时的学习、工作中都有所了解。

ASCII 码，英文全称为：American Standard Code for Information Interchange，翻译过来就是：美国信息交换标准代码，是我们平常常用的一种编码。那它是怎么来的呢？

在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示 1 和 0），例如，像 a、b、c、d 这样的 52 个字母（包括大写）以及 0、1 等数字还有一些常用的符号（例如\*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），假如，对于字符 a，比尔盖茨想用 0001 来表示，而乔布斯想用 0010 来表示，那么他们在沟通交流的时候谁都无法理解对方的语言。因此，为了计算机能够互相通信而不造成混乱，就必须使用相同的编码规则，于是美国有关的标准化组织就出台了 ASCII 编码，统一规定了上述常用符号用哪些二进制数来表示。

标准 ASCII 码也叫基础 ASCII 码，使用**7 个比特位来表示所有的大写和小写字母**，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，共定义了 128（2 的 7 次方）个**字符**。

下面我们通过一张表来了解部分 ASCII 码。

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190913123734332-549719122.png)

表中列出了常见字符的 ASCII 码，如：字母 a 表示为 01100001、字符（不是数字哦~）1 表示为 00110001... ...

在计算机的早期，ASCII 码就能满足特定人群的使用了，但是，随着计算机的发展以及计算机的普遍性，ASCII 码逐渐不能满足人们的使用需求，比如一些数学符号以及一些国家的符号都无法表示。于是，人们对 ASCII 码进行了扩充，用 8 个比特位来表示一个字符，这就是拓展的 ASCII 码，拓展的 ASCII 码能表示 256 个字符。

##### 2.7.1.2 **Extended ASCII 码**

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190913123806096-1094066395.png)

这里面包括了常见的数学运算符、带音标的欧洲字符以及其他常用符号、表格符号等。使用了拓展的 ASCII 码极大的补充了原来的码表，使得计算机能表达的内容越来越丰富。

##### 2.7.1.3 **字符编码集的国际化**

随着计算机的进一步发展，越来越多的国家加入到了使用计算机的行列中，对字符编码集的要求也越来越高。对于欧洲、中亚、东亚、拉丁美洲等国家来说，它们的语言丰富多样，体系不一样，不以有限字符为组合，尤其以中国、韩国、日本等的语言最为复杂，ASCII 码表根本无法表达这些语言，这就迫切需要使用新的编码集，也就是字符编码集的国际化。

#### 2.7.2 中文编码集

##### 2.7.2.1**GB2312**

GB2312 是 1980 年制定的中国汉字编码国家标准，是我国最早最完备的一个编码集，一共收录了 7445 个字符，包括 6763 个汉字和 682 个其他字符，一个汉字占用两个字节。

##### 2.7.2.2 **GBK**

由于 GB2312 不符合国际标准，中国的科学家在 1995 年推出了第二套完备的编码集——GBK，GBK 向下兼容 GB2312，向上支持国际 ISO 标准，收录了 21003 个汉字，支持全部中日韩汉字。

GB2312 和 GBK 都是比较完备的编码集，但是，它们只是一个本地化的编码，在中国使用是没问题的，但要跨国使用就有问题了。举个例子，一个中国人开发了一个网站，一个外国友人访问了这个网站，如果他们本地没有安装 GB2312 编码集或 GBK 编码集的话， 那么他们在访问网站网页的时候看到的会是乱码。因此，就需要一个全球统一的编码规范。

##### 2.7.2.3 **Unicode**

为了统一所有文字的编码，Unicode 应运而生。Unicode 是一个兼容全球的字符集，定义了世界通用的符号集，可以表达全世界所有的文字和字符。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

我们平时用的 UTF-8 是其中一个编码规则，它以字节为单位对 Unicode 进行编码，平常写代码的时候都是推荐使用 UTF-8 编码。中文 Windows 操作系统默认使用 GBK 编码，因此，使用 IDE 编程时通常要设置成 UTF-8 编码。

#### 参考文档

[计算机的字符与编码集 ](https://www.cnblogs.com/jvStarBlog/p/11941521.html)

## 3. 计算机组成原理之组成篇

### 3.1 章节导学

1. 冯诺依曼计算机

   | 冯诺依曼计算机的组成部分 | 计算机硬件                          |
   | ------------------------ | ----------------------------------- |
   | 输入设备                 | 鼠标、键盘                          |
   | 输出设备                 | 显示器                              |
   | 存储器                   | CPU、内存、硬盘                     |
   | 运算器                   | CPU                                 |
   | 控制器                   | CPU、主板、显卡、声卡、电源、网卡等 |

2. 章节组成部分

   | 计算机的总线与 IO 设备 | 计算机的总线                                           | 计算机的输入与输出设备             |
   | ---------------------- | ------------------------------------------------------ | ---------------------------------- |
   | 计算机的存储器         | 计算机的存储器概览、<br />计算机的主存储器与辅助存储器 | 计算机的高速存储器                 |
   | 计算机的 CPU           | 计算机的指令系统、<br />计算机的控制器                 | 计算机的运算器、<br />指令执行过程 |

### 3.2 计算机的总线

#### 3.2.1 总线的概述

##### 3.2.1.1 总线的概述（是什么、什么用）

总线（bus），是用于连接计算机中各种功能部件（如 CPU、内存、输入、输出设备），并在它们之间传送数据的公用线路或通路，主机的各个部件通过总线相连接，外部设备（如 U 盘、移动硬盘）通过相应的接口再与总线相连接，从而形成计算机硬件系统。

USB: Universal Serial Bus, 通用串行总线

PCI 总线、ISA 总线、Thunderbolt 总线。。。

- 提供了对外连接的接口
- 不同设备可以通过 USB 接口进行连接
- 链接的标准，促使外围设备接口的统一

![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022558360-281209348.png)

##### 3.2.1.2 总线的分类

1. 片内总线

   > **片内总线**，它是 CPU 内部的信息传输线，连接着控制器、运算器等部件，使用片内总线可以简化 CPU 内部的电路结构。
   >
   > 可以说是高集成度芯片内部的信息传输线

   - 芯片内部的总线
   - 寄存器与寄存器之间
   - 寄存器与控制器、运算器之间

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022613781-667181403.png)

2. 系统总线

   > **系统总线**，它是连接 CPU、主存、硬盘、IO 设备、USB 插槽、PCI 插槽等计算机组件的一条信息传输线。

   - 数据总线：一般与 CPU 位数相同(32 位、64 位)
     - 双向传输各个部件的数据信息
     - 数据总线的位数（总线宽度）是数据总线的重要参数
   - 地址总线：指定源数据或目的数据在内存中的地址，地址总线位数=n, 寻址范围：0-2^n
     - 指定源数据或目的数据在内存中的地址
     - 地址总线的位数与存储单元有关
   - 控制总线：
     - 控制总线是用来发出各种控制信号的传输线
     - 控制信号经由控制总线从一个组件发给另外一个组件
     - 控制总线可以监视不同组件之间的状态(就绪/未就绪)

   ![img](https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022625463-433149755.png)

#### 3.2.2 总线的仲裁

##### 3.2.2.1 为什么需要总线的仲裁

> 链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
> 来源：牛客网
>
> 为了解决多个主设备同时竞争总线控制权，必须具有总线仲裁部件，以某种方式选择其中一个主设备作为总线的下一次主方。对多个主设备提出的占用总线请求，一般采用优先级或公平策略进行仲裁。 按照总线仲裁电路的位置不同，仲裁方式分为集中式仲裁和分布式仲裁两类。

比如：当主存需要和硬盘、IO 设备进行数据交互等，当硬盘或者 IO 设备都准备就绪时候，总线应该由硬盘使用还是 IO 设备使用，这时候就需要一个第三方的仲裁器进行裁决

##### 3.2.2.1 总线仲裁的方法

> 总线的仲裁是为了解决总线使用权的冲突问题

###### 3.2.2.1.1 链式查询：

> 链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
> 来源：牛客网
>
> 链式查询方式的主要特点：总线授权信号 BG 串行地从一个 I/O 接口传送到下一个 I/O 接口。假如 BG 到达的接口无总线请求，则继续往下查询；假如 BG 到达的接口有总线请求， BG 信号便不再往下查询，该 I/O 接口获得了总线控制权。离\*\*\*仲裁器最近的设备具有最高优先级，通过接口的优先级排队电路来实现。
>
> 链式查询方式的优点 : 只用很少几根线就能按一定优先次序实现总线仲裁，很容易扩充设备。
>
> 链式查询方式的缺点 : 对询问链的电路故障很敏感，如果第 i 个设备的接口中有关链的电路有故障，那么第 i 个以后的设备都不能进行工作。查询链的优先级是固定的，如果优先级高的设备出现频繁的请求时，优先级较低的设备可能长期不能使用总线。

###### 3.2.2.1.2 计时器定时查询

- 仲裁控制器对设备编号并使用计数器累计计数
- 接收到仲裁信号后，往所有设备发出计数值
- 计数值与设备编号一致则获得总线使用权

链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
来源：牛客网

总线上的任一设备要求使用总线时，通过 BR 线发出总线请求。\*\*\*仲裁器接到请求信号以后，在 BS 线为“ 0 ”的情况下让计数器开始计数，计数值通过一组地址线发向各设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址相一致时，该设备 置“ 1 ” BS 线，获得了总线使用权，此时中止计数查询。

每次计数可以从“ 0 ”开始，也可以从中止点开始。如果从“ 0 ”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。

计数器的初值也可用程序来设置，这可以方便地改变优先次序，但这种灵活性是以增加线数为代价的。

##### 3.2.2.1.3 独立请求

- 每个设备均有总线独立链接仲裁器
- 设备可单独向仲裁器发送请求和接收请求
- 当同时收到多个请求信号，仲裁器有权按优先级分配使用权

链接：https://www.nowcoder.com/questionTerminal/087e9bf84acf4c5eab01b0924d8b09ce
来源：牛客网

每一个共享总线的设备均有一对总线请求线 BRi 和总线授权线 BGi 。当设备要求使用总线时，便发出该设备的请求信号。\*\*\*仲裁器中的排队电路决定首先响应哪个设备的请求，给设备以授权信号 BGi 。

独立请求方式的优点：响应时间快，确定优先响应的设备所花费的时间少，用不着一个设备接一个设备地查询。其次，对优先次序的控制相当灵活，可以预先固定也可以通过程序来改变优先次序；还可以用屏蔽 ( 禁止 ) 某个请求的办法，不响应来自无效设备的请求。

#### 参考文档

[计算机的总线](https://www.cnblogs.com/jvStarBlog/p/11941522.html)

### 3.3 计算机的输入输出设备

#### 3.3.1 常见的输入输出设备

1. 常见的输入设备：
   - 字符输入设备
     - 键盘：薄膜键盘、机械键盘(黑轴，红轴，青轴，茶轴)、电容键盘
     - 鼠标
     - 数位板：输入板和压感笔、常用于绘画设计创作
     - 扫描仪：将图形信息转换为数字信号
   - 图像输出设备：
     - 显示器：CRT 显示器、液晶显示器
     - 打印机
     - 投影仪

#### 3.3.2 输入输出接口的通用设计

1. 如果要设计输入输出接口，需要完成什么工作
   - 读取数据、向设备发送数据、设备有没有被占用、设备是否已经链接、设备是否已经启动
2. 主要有：
   - 数据线：
     - 是 I/O 设备与主机之间进行数据交换的传送线
     - 单向传输数据线
     - 双向传输数据线
   - 状态线
     - IO 设备状态向主机报告的信号线
     - 查询设备是否已经正常链接并就绪
     - 查询设备是否已经被占用
   - 命令线
     - CPU 向设备发送命令的信号线
     - 发送读写信号
     - 发送启动禁止信号
   - 设备选择线
     - 主机选择 I/O 设备进行操作的信号线
     - 对连在总线上的设备进行选择

#### 3.3.3 CPU 与 IO 设备的通信

> CPU 速度与 IO 设备速度不一致

1. 程序中断：提供低速设备通知 CPU 的一种异步的方式；CPU 可以高速运转同时兼顾低俗设备的响应
   - 当外围 IO 设备就绪时，向 CPU 发出中断信号
   - CPU 有专门的电路响应中断信号
2. DMA(直接存储器访问)：当主存与 IO 设备交换信息时，不需要中断 CPU，可以提高 CPU 的效率
   - DMA 直接连接主存与 IO 设备
   - DMA 工作时不需要 CPU 的参与
   - 硬盘里、显卡都有这种设备

### 3.4 计算机存储器概览

#### 3.4.1 存储器的分类

1. 按照存储介质来分类
   - 半导体存储器：内存、U 盘、固态硬盘
   - 磁存储器：磁带、磁盘
2. 按照存取方式分类
   - 随机存储器 RAM: 可以随机读取、与位置无关
   - 串行存储器：与位置有关、按顺序查找
   - 只读存储器 ROM：只读不写

#### 3.4.2 存储器的层次结构

1. 读写速度：5200 转、7200 转，越快越好
2. 存储容量：2T、4T，越大越好
3. 价格：越便宜越好

所以用一个单位来衡量这几个结构标准的性价比，叫做位价(每比特位价格)=<容量+价格

可以划分为：

- 缓存：速度快、位价高
- 主存：速度适中、位价适中
- 缓存：速度慢、位价低

**主存-缓存层次**：是在主存之外增加辅助存储器（磁盘、SD 卡、U 盘等），目的是解决主存容量不足的问题。假设我们运行一个超大型游戏，而内存通常只有 8G，此时，就可以把游戏当前使用的数据加载到内存中，把不使用的数据放在辅存中

- 原理：局部性原理
- 实现：在 CPU 与主存之间增加一层速度快(容量小)的 Cache，主存之外增加辅助存储器（磁盘、SD 卡、U 盘等）
- 目的：解决主存速度不足的问题

**局部性原理**：是指 CPU 访问存储器时，无论是**存取指令**还是**存取数据**，所访问的存储单元都**趋于聚集在一个较小的连续区域中**

#### 参考文档

[存储器 ](https://www.cnblogs.com/jvStarBlog/p/11941524.html)

### 3.5 计算机的主存储器与辅助存储器

> 为什么计算机断电时候，内存数据会丢失
>
> 计算机断电时候，磁盘数据不会丢失

#### 3.5.1 主存储器---内存

- RAM：随机存取储器，Random Access Memory.
- RAM: 通过电容存储数据，必须隔一段时间刷新一次
- 如果掉电，那么一段时间后丢失所有数据

#### 3.5.2 辅助存储区----硬盘

1. 特点

- 表面是可磁化的硬磁特性材料
- 移动磁头径向运动读取磁道信息

2. 算法有：

- 先来先服务算法
  - 按顺序访问进程的磁道读写需求
- 最短寻道时间优先
  - 与磁头当前位置有关
  - 优先访问离磁头最近的磁道
- 扫描算法（电梯算法）
  - 每次只往一个方向移动
  - 到达一个方向需要服务的尽头再反方向移动
- 循环扫描算法
  - 读取只能往一个方向移动
  - 到达一个方向的尽头，就又回到起点重新开始

### 3.6 计算机的高速缓存

回顾一下:

1. 存储器的层次结构: 高速缓存位于 CPU 与 主存之间的，是为了解决 CPU 与主存的速度不匹配的问题。

#### 3.6.1 高速缓存的工作原理

1. 字：是指存放在一个存储单元中的二进制代码组合，一个字有 32 位
2. 字块：存储在连续的存储单元中而被看作是一个单元的一组字 ，一个字块共 B 个字
3. 主存共 M 个字块：B _ M = 主存总字数，B _ M \* 32 = 主存总容量(bits)
4. 字的地址包含两个部分：前 m 位表示制定字块的地址，后 b 位制定字在字块中的地址，所以：2^m = M, 2^b = B

> CPU 需要的数据在缓存里
>
> CPU 需要的数据不在缓存里
>
> 不在缓存的数据需要去主存中拿
>
> 这里就产生了一个指标

- 命中率是衡量缓存的重要性能指标
- 理论上 CPU 每次都能从告诉缓存取数据的时候，命中率为 1
- 命中率的计算公式：访问主存次数为 N(m), 访问 Cache 次数为 N(c),那么命中率 h = N(c) / (N(c)+N(m))
- 访问效率 e:
  - 假设访问主存时间为 t(m), 访问缓存时间为 t(c), 访问 Cache-主存系统的平均时间为：t(a) = h _ t(c) + (1 - h) _ t(m)
  - 访问效率 e = t(c)/t(a) = t(c) / (h* t(c) + (1-h) * t(m) )

1. 假设 CPU 在执行某段程序时，共访问了 Cache 命中 2000 次，访问主存 50 次，已知 Cache 的存取时间为 50ns, 主存的存取时间为 200ns, 求 Cache-主存系统的命中率、访问效率和平均访问时间
   - 访问效率 e = t(c)/t(a) = t(c) / (h* t(c) + (1-h) * t(m) ) = 50/(0.97 _ 50 + (1-0.97) _ 200 ) = 0.917 = 91.7%
   - 命中率 h =
   - 平均访问时间 t(a) = 0.97 _ 50 + (1-0.97)_ 200 = 54.5 ns

#### 3.6.2 高速缓存的替换策略

> 高速缓存的替换时机：当 CPU 需要的数据不存在高速缓存中时候，就需要从主存载入所需数据

- 随机算法
- 先进先出算法（FIFO）
  - 把高速缓存看做是一个先进先出的队列
  - 优先替换最先进入的字块
- 最不经常使用算法(LFU)
  - 优先淘汰最不经常使用的字块
  - 需要额外的空间记录字块的使用频率
- 最近最少使用算法(LRU)
  - 优先淘汰一段时间内没有使用的字块
  - 有多种实现方法，一般使用双向链表
  - 把当前访问节点置于链表前面（保证链表头部节点是最近使用的）

### 3.7 计算机的指令系统

#### 3.7.1 机器指令的形式

机器指令主要由两部分组成：操作码、地址码

- 操作码指明指令所要完成的操作

- 操作码的位数反映了机器的操作种类
- 地址码直接给出操作或者操作数的地址
- 分三地址指令、二地址指令和一地址指令、零地址指令（在机器指令中无地址码，空操作、停机操作、中断返回操作等）

#### 3.7.2 机器指令的操作类型

1. 数据传输

   - 寄存器之间、寄存器与存储单元、存储单元之间传送

   - 数据读写、交换地址数据、清零置一等操作

2. 算数操作类型：

   - 操作数之间的加减乘除运算
   - 操作数的与或非等逻辑位运算

3. 移位操作

   - 数据左移(乘 2)、数据右移动(除 2)
   - 完成数据在算术逻辑单元的必要操作

4. 控制指令：

   - 等待指令、停机指令、空操作指令、中断指令等

#### 3.7.3 机器指令的寻址方式

1. 指令寻址方式

   - 顺序寻址
   - 跳跃寻址

2. 数据寻址方式

   - 立即寻址：直接获取操作数、无需访问存储器
   - 直接寻址：直接给出操作数在主存的地址、寻找操作数简单、无需计算数据地址
   - 间接寻址：指令地址码给出的是操作数地址的地址、需要访问一次或者多次主存来获取操作数

3. 对比

   | 寻址方式 | 优点             | 缺点                         |
   | -------- | ---------------- | ---------------------------- |
   | 立即寻址 | 速度快           | 地址码位数限制操作数表示范围 |
   | 直接寻址 | 寻找操作数简单   | 地址码位数限制操作数寻址范围 |
   | 间接寻址 | 操作数寻址范围大 | 速度较慢                     |

### 3.8 计算机的控制器

> 控制器是协调和控制计算机运行的
>
> 主要构成部分有：程序计数器、时许发生器、指令译码器、各种寄存器（指令寄存器、主存地址寄存器、主存数据寄存器、通用寄存器）、总线

1. 程序计数器
   - 程序计数器用来存储下一条指令的地址
   - 循环从程序计数器中拿出指令
   - 当指令被拿出时，指向下一条指令
2. 时序发生器
   - 电气工程领域，用于发送时许脉冲
   - CPU 依据不同的时序脉冲有节奏的进行工作
   - 可以理解为 CPU 的节拍器
3. 指令译码器
   - 指令译码器是控制器的主要部件之一
   - 计算机指令是由操作码和地址码组成
   - 翻译操作码对应的操作以及控制传输地址码对应的数据
4. 指令寄存器
   - 指令寄存器也是控制器的主要部件之一
   - 从主存或者高速缓存取计算机指令
5. 主存地址寄存器
   - 保存当前 CPU 正要访问的内存单元的地址
6. 主存数据寄存器
   - 保存当前 CPU 正要读取或写的主存数据
7. 通用寄存器
   - 用于暂时存放或传送数据或者指令
   - 可以保存 ALU 的运算中间结果
   - 容量比一般专用寄存器要大

### 3.9 计算机的运算器

> 运算器是用来进行数据运算加工的
>
> 主要组成部分有：数据缓存器、ALU、通用寄存器、状态字寄存器、总线

1. 数据缓存器
   - 分为输入缓存和输出缓存
   - 输入缓存暂时存放外设送过来的数据
   - 输出缓存暂时存放送往外设的数据
2. ALU:
   - ALU：算术逻辑单元，是运算器的主要组成
   - 常见的位运算：左右移动、与或非等
   - 算术运算: 加减乘除等
3. 状态字寄存器
   - 存放运算状态: 条件码、进位、溢出、结果正负等
   - 存放运算控制信息：调试跟踪标记位、允许中断位等
4. 通用寄存器
   - 用于暂时存放或传送数据或指令
   - 可保存 ALU 的运算中间结果
   - 容量比一般专用寄存器要大

### 3.10 计算机指令的执行过程

#### 3.10.1 指令执行过程

> 步骤：取指令 =》 分析指令 =》 执行指令
>
> 涉及的设备：数据缓存器、指令缓存器、寄存器、数据缓存器、状态字寄存器、程序计数器、指令译码器、时序发生器、指令寄存器

1. 取指令：从缓存中取出指令，送到指令寄存器
2. 分析指令：指令译码器译码，发出控制信号，程序计时器+1
3. 执行指令：装载数据到寄存器，ALU 处理数据，记录运算状态，送出计算结果

上述过程中，在取指令或者分析指令时候，主要是控制器在进行工作；在执行指令时候，主要是由运算器进行工作的。所以说，运算器和控制器不是同时工作的，这样就导致 CPU 的综合利用率并不高。具体解决看下节内容

#### 3.10.2 CPU 的流水线设计

- 类似工厂的装配线
- 工厂的装配线使得多个产品可以同时被加工
- 在同一时刻，不同产品均位于不同的加工阶段

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8edd8057fddf41f59e58576963ce20d6~tplv-k3u1fbpfcp-watermark.image?)

假设执行 m 条指令，取指令、分析指令、执行指令所需时间一致并且都是 t

串行执行需要时间 T1 = 3t \* m

流水线执行 m 条指令需要时间：T2 = t \* (m+2)

H = T2 / T1 = t _ (m+2) / (3t _ m) = 1/3 + 1 / (3 _ m) = 1/3 + 1/ (3 _ m)

## 4 计算机组成原理之计算篇

### 4.1 章节导学

1. 进制运算的基本知识

   进制运算的基础、

2. 二进制数据的表示方式

   有符号数与无符号数、二进制的补码表示法、二进制的反码表示法、小数的二进制补码表示

3. 二进制数据的运算

   定点数与浮点数、定点数的加减法运算、浮点数的加减法运算、浮点数的乘除法运算

### 4.2 进制运算的基础

#### 4.2.1 进制的概述

1. 进制的定义

   - 进位制是一种计数方式，亦称进位计数法或位值记数法
   - 有限种数字符号来表示无限的数值
   - 使用的数字符号的数目称为这种进位制的基数或底数

2. 常见的进制

   > 计算机喜欢二进制，但是二进制表达太长了
   >
   > 使用大进制位可以解决这个问题
   >
   > 八进制、十六进制满足 2 的 n 次方的要求

   - 二进制：
   - 十进制
   - 八进制：
   - 十六进制：0-9、A、B、C、D、E、F
   - 二十进制：玛雅文明的玛雅数字、因努伊特的因努伊特数字
   - 六十进制：时间、坐标、角度等量化数据

#### 4.2.2 二进制运算的基础

- 正整数 N，基数为 r:

  1024 = 1 _ 10^3 + 0 _ 10^2 + 2*10^1 + 4 * 10^0 （基数是 10）

- （整数）二进制转换十进制的方法：按权展开法

- （整数）十进制转换二进制：重复相除法

- （小数）二进制转换十进制：按权展开法

  0.11001 = 1 _ 2^-1 + 1 _ 2^-2 + 1 \* 2^-5 = 0.78125 = 25/32

- (小数)十进制转换二进制：重复相乘法

### 4.3 有符号数与无符号数

> 上面都是整数或者小数，那么负数怎么办呢，使用 0 表示正数，使用 1 表示负数
>
> +237 = 011101101
>
> -237 = 111101101
>
> 那么怎么判断是数字位还是符号位呢？那我们约定把符号位放在数字位的最前面

原码表示法

1. 特点

   - 使用 0 表示正数、1 表示负数

   - 规定符号位位于数值第一位

   - 表达简单明了，是人类最容易理解的表示法

2. 缺点

   - 0 只有两种表示方法：00、10
   - 原码表示法运算非常复杂，特别是两个操作数符号不同的时候：判断两个操作数绝对值大小、使用绝对值大的数减去绝对值小的数、对于符号值，以绝对值大的为准

所以我们需要找到具有以下特点的其他方法

- 希望可以找到不同符号操作数更加简单的运算方法
- 希望找到使用正数代替负数的方法
- 使用加法操作代替减法操作，从而消除减法

### 4.4 二进制的补码表示法

1. 补码的定义：

对于 x, 位数为 n，

如果 0 <= x < 2^n，那么它的补码是 x;

如果 -2^n <= x < 0，那么它的补码是 x + 2^(n+1)

2. 例子 1：n=4，x=13，计算 x 的 二进制原码和补码

   原码 ：x = 0,1101 补码： x = 01101

3. 例子 2：n=4，x=-13，计算 x 的 二进制原码和补码

原码：x = 1,1101 补码：2^(4+1) - 13 = 100000 - 1101 = 10011

4. 例子 3：假设 x=-7,计算 x 的二进制原码和补码

   补码：2^(4+1) - 7 = 100000 - 0111 = 11001

5. 例子 4：如果 x=-1, 计算 x 的二进制原码和补码

   补码：2^(4+1) - 1 = 100000 - 0001 = 11111

注意：**在补码操作计算中，还是使用了减法**，有没有办法在计算过程中不涉及到减法操作的呢？

### 4.5 二进制的反码表示法

1. 引进补码的目的

   - 减法运算复杂，希望找到使用正数替代负数的方法
   - 使用加法代替减法操作，从而消除减法（但是在计算补码的过程中，还是使用了减法）

2. 反码的目的

   - 找出原码和补码之间的规律，消除转换过程中的减法

3. 反码的定义：

   对于 x, 位数为 n，

   如果 0 <= x < 2^n，那么它的反码是 x;

   如果 -2^n <= x < 0，那么它的反码是 x + 2^(n+1) -1

4. 例子 1：x= -13,计算 x 的二进制原码和反码

   原码 = x = 1,1101

   反码 = 2^(4+1) - 1 - 13 = 011111 - 1101 = 1,0010

5. 例子 2：x=-7, 计算 x 的二进制原码和反码

   原码 = x = 1,0111

   反码 = 2^(4+1) - 1 - 7 = 011111 0 -111 = 1,1000

| 十进制 | 原码   | 补码   | 反码   |
| ------ | ------ | ------ | ------ |
| 13     | 0,1101 | 0,1101 | 0,1101 |
| -13    | 1,1101 | 1,0011 | 1,0010 |
| -7     | 1,0111 | 1,1001 | 1,1000 |
| -1     | 1,0001 | 1,1111 | 1,1110 |

从上图可以看到的规律如下

- 负数的反码等于原码除符号位外按位取反
- 负数的补码等于反码+1

### 4.6 小数的二进制补码表示法

1. 二进制小数的补码

   如果 0<= x <1, 那么 x 的补码为 x

   如果 -1<=x<0，那么 x 的补码为 2+x

2. 例子 1：x= 9/16，计算 x 的二进制原码和反码和补码

   x 的原码为 0,0.1001

   x 的反码为 0,0.1001

   x 的补码为 0,0.1001

3. 例子 2：x= -11/32，计算 x 的二进制原码和反码和补码

   x 的原码为 1,0.01011

   x 的反码为 1,1.10100

   x 的补码为 1,1.10101

### 4.7 定点数与浮点数

#### 4.7.1 定点数的表示方法

- 小数点固定在某个位置的数称之为定点数

- 如果不是纯小数，也不是纯整数，那就需要 **乘以比例因子以满足定点数保存格式**

- 纯小数如下

  | 数值    | 符号位 | 数值位 |
  | :------ | ------ | ------ |
  | 0.1011  | 0      | 1011   |
  | -0.1011 | 1      | 1011   |

- 纯整数表示如下

  | 数值  | 符号位 | 数值位 |
  | ----- | ------ | ------ |
  | 1011  | 0      | 1011   |
  | -1011 | 1      | 1011   |

- 均不是上述情况时候，需要乘以比例因子以满足定点数保存格式

  | 数值  | 符号位 | 数值位 |
  | ----- | ------ | ------ |
  | 10.01 |        |        |
  | 101.1 |        |        |

#### 4.7.2 浮点数的表示方法

1. 为什么有了定点数，还需要使用浮点数呢

   - 计算机处理的很大程度上不是纯小数或纯整数
   - 数据范围很大，定点数难以表达

2. 浮点数的表示格式

   - 科学计数法

     - 123450000000 = 1.2345 \* 10^11，其中 1.2345 是尾数，10 是基数，11 是阶码

     - 对于任意的浮点数都可以表示为：N = S \* r^j 其中 S 是尾数，r 是基数，j 是阶码

     - 所以使用这种方式存储时候，需要存储：阶码符号位、阶码数值位、尾数符号位、尾数数值位，其中 尾数规定使用纯小数

     - 比如：

       11.0101 = 0.110101 \* 2^10

       11.0101 = 0.0110101 \* 2^11

       | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位(8 位) |
       | ---------- | ---------- | ---------- | ---------------- |
       | 0          | 10         | 0          | 11010100         |
       | 0          | 11         | 0          | 01101010         |

3. 浮点数的表示范围

   - 假设阶码数值取 m 位，尾数数值取 n 位

     - 阶码能够表示的最大值是 2^m - 1, 最小值为 -(2^m - 1)
     - 阶码表示范围：[ -(2^m - 1), 2^m - 1 ]
     - 尾数能够表示的最大值：1 - 2^(-n), 最小值为 2^(-n)
     - 尾数表示范围：[ 2^(-n), 1 - 2^(-n) ] 负数范围：[ -(1 - 2^(-n)), - 2^(-n), ] ，正数范围：[ 2^(-n), 1 - 2^(-n) ]

   - 下面以阶码占 3 位，尾数占 5 位(各包括 1 位符号位)为例，来讨论这个问题。图 2-1 给出了相应的规格化浮点数的数值表示范围。

   ![img](https://upload-images.jianshu.io/upload_images/525520-c101d21a0301f55f.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

   - 单精度浮点数

     > 使用 4 个字节，32 位来表达浮点数 float

   - 双精度浮点数

     > 使用 8 个字节，64 位来表达浮点数 double

4. 浮点数的规格化

   - 科学计数法：对于浮点数，要求**尾数规定使用纯小数**、**尾数最高位必须是 1**

     11.0101 = 0.110101 \* 2^10

     11.0101 = 0.0110101 \* 2^11 不符合规范

   - 例子 1：设定浮点数字长为 16 位，阶码为 5 位，尾数为 11 位，将十进制数 13/128 表示为二进制浮点数

     求原码：x = 0.0001101000

     浮点数规格化 x= 0.1101000 \* 2 ^ (-11)

   - 例子 2：设定浮点数字长为 16 位，阶码为 5 位，尾数为 11 位，将十进制数 -54 表示为二进制浮点数

     求原码：x = 1,1110110

     浮点数规格化：x = -0.110110 \* 2 ^ (110)

#### 4.7.3 定点数与浮点数的对比

- 当定点数与浮点数位数相同时候，**浮点数表示的范围更大**
- 当浮点数尾数为规格化数时，**浮点数的精度最高**
- 浮点数运算包括阶码和尾数，**浮点数的运算更为复杂**
- 浮点数在数的表示范围、精度、溢出处理、编程等方面均位于定点数
- 浮点数在数的运算规则、运算速度、硬件成本方面不如定点数

### 4.8 定点数的加减运算

#### 4.8.1 定点数的加法

> **数值位与符号位一同运算，并将符号位产生的进位自然丢掉**

1. 整数的加法

   > A[补] + B[补] = [ A+B ] [ 补 ] ( mod2^(n+1) )

2. 小数的加法

   > A[补] + B[补] = [ A+B ] [ 补 ] ( mod2 )

3. 例子 1：A= -10000110, B = 001101, 求 A+B

   A[补] = 1,001110

   B[补] = B[原] = 0,001101

   A[补] + B[补] = （A+B）[补] = 1,011011

   A+B= -100101

4. 例子 2：A=-0.1010010, B = 0.0110100, 求 A+B

   A[补] = 1,1.0101110

   B[补] = B[原] = 0,0.0110100

   A[补]+B[补] = (A+B)[补] = 1.0.1100010

   A+B = -0.0011110

5. 例子 3：A=-10010000，B=-01010000，求 A+B

   A[补] = 1,01110000

   B[补] = 1,101110000

   A[补] + B[补] = (A+B) [补] = 1,00100000

   A + B = -11100000

   A = -144, B = -80

   A + B = -224

6. 例子 4：A = -10010000, B = -1101000, 求 A+B

   A[补] = 1,01110000

   B[补] = 1,00110000

   A[补] + B[补] = (A+B) [补] = 0,10100000

   A + B = 10100000

   A = -144, B = -208, A + B = 160 ： 注意：这里两个负数相加，结果为正数，因为发生了溢出。

7. 如何判断溢出

   - 双符号位判断法：**单符号位表示变为双符号位：0=> 00 , 1 => 11**

     双符号位产生的进位丢弃

     结果的双符号位不同则表示溢出

8. 例子 4：A= -10010000， B = -11010000, 求 A + B

   A[补] = 1,01110000

   B[补] = 1,00110000

   A[补] + B[补] = (A+B) [补] = 1,010100000 (相加后符号位进位，需要舍去一位，这里是舍去后的结果，并且注意：双符号位(首位为 10)不同，表示溢出)

#### 4.8.2 定点数的减法

1. 整数的减法

   > A[补] - B[补] = A + (-B ) [ 补 ] ( mod2^(n+1) )

2. 小数的减法

   > A[补] - B[补] = A + (-B ) [ 补 ] ( mod2 )

**-B[补]等于 B[补]连同符号位按位取反，末位加一**

B[补] = 1,0010101

-B[补] = 0,1101011

3. 例子 5：A= 11001000，B= -00110100，求 A - B

   A[补] = A[原] = 0,11001000

   B[补] = 1,11001100

   (-B)[补] = 0,00110100

   A + (-B)[补] = 0,11111100

   A - B = 111111100

### 4.9 浮点数的加减法运算

1. 对阶

   - 浮点数尾数运算简单
   - 浮点数位数实际小数位与阶码有关
   - 阶码按小阶看齐大阶的原则
   - 对阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算

   ![img](https://i.loli.net/2018/10/28/5bd5bb1a49c09.png#shadow)

2. 尾数相加

   > 完成对阶后，将两浮点数的尾数部分相加，方法与定点小数加法相同

3. 规格化处理

   ![img](https://i.loli.net/2018/10/28/5bd5bbdcc67ef.png#shadow)

   对右移的两种情况做一下特殊说明：10,110 -> 11,011
   01,110 -> 00,111

4. 舍入操作

   - 0 舍 1 入法：二进制的四舍五入，注意可能会发生溢出

5. 检查阶码是否溢出

   - 浮点运算主要通过阶码的双符号位判断是否溢出
   - 如果规格化后，阶码双符号位不一致，则认为是溢出

【参考文档】

[浮点数加减运算](https://wmathor.com/index.php/archives/1091/)

### 4.10 浮点数的乘除法运算

1. 乘法：阶码相乘，尾数求积
2. 除法：阶码相减，尾数求商
3. 步骤
   1. 阶码运算
   2. 尾数运算
   3. 尾数规格化
   4. 舍入
   5. 溢出判断

【参考文档】

[浮点数的乘除法运算](https://blog.csdn.net/qq_47114658/article/details/111599175)

## 5 计算机组成原理实践

### 5.1 章节导学

1. 实现双向链表：
   1. 实现 node 类
   2. 实现 DoubleLinkedList 类：pop 方法、append(node)方法、append_front(node)方法、remove(node)方法
2. 实现置换算法：
   1. 先进先出算法
      - 把高速缓存看做是一个先进先出的队列
      - 优先替换是最先进入队列的字块
   2. 最近最少使用算法 LRU
      - 优先淘汰一段时间内没有使用的字块
      - 有多种实现方法，一般使用双向链表
      - 把当前访问节点置于链表前面（保证链表头部节点是最近使用的）
   3. 最不经常使用算法 LFU
      - 优先淘汰最不经常使用的字块
      - 需要额外的空间记录字块的使用频率
   4. 实现置换算法：
      1. 实现 Cache 类
         - get(key) 方法：返回 value 或者 -1
         - put(key ,value) 方法

### 5.2 双向链表的原理与实践

1. 单向链表：

   > 每一个节点都有下一个节点的地址或者引用

   节点 1 =》 节点 2 =》 节点 3 =》 节点 4 =》 节点 5

2. 双向链表

   > 每一个节点都有上一个节点和下一个节点的地址或者引用

   节点 1 《=》节点 2《=》节点 3《=》节点 4《=》节点 5

3. 对于双向链表：

   - 可以快速找到一个节点的下一个节点
   - 可以快速找到一个节点的上一个节点
   - 可以快速去掉表中的某一个节点

4. 实现双向链表

   1. 实现链表节点

      > 可以存放 key-value 数据, 因此具有 key: value 的属性，并且有上一个节点的引用、下一个节点的引用

   2. 实现双向链表

      > 包括的功能：弹出头部节点、弹出尾部节点、往头部增加节点、往尾部增加节点、删除任意节点、增加任意节点

### 5.3 实践 FIFO 缓存置换算法

FIFO: 先进先出算法

### 5.4 实践 LRU 缓存置换算法

- 每次使用，把使用的节点放到链表最前面；
- 淘汰缓存时候，把链表尾部的节点淘汰

### 5.5 实现 LFU 缓存置换算法

每一个节点需要一个标记，来记录使用的频率

淘汰缓存时候，把使用频率最小的淘汰

问题：可能存在相同频率的情况，这时应该淘汰哪个节点呢？相同频率的节点放入另一个双向链表中，然后同频率节点按 FIFO 算法淘汰

## 6 操作系统之基础篇

### 6.1 本章知识概要与学习计划

#### 6.1.1 操作系统的演进

1. 无操作系统
   - 人工操作
   - 用户独占
   - CPU 等待人工操作
   - 资源利用率低
2. 批处理系统
   - 无序等待人工操作
   - 批量输入任务
   - 资源利用率提升
   - 多道程序设计
3. 分时系统
   - 人机交互
   - 多用户共享
   - 及时调试程序
   - 资源利用率提升
4. 多道程序设计
   - 早期批处理系统只能一次处理一个任务
   - 多道程序设计使得批处理系统可以一次处理多个任务
   - 多道程序设计是指在计算机内存中同时存放多个程序
   - 多道程序设计在计算机的管理程序之下相互穿插运行
   - **对多道程序的管理是操作系统的重要功能**
5. 对多道程序的管理
   - 进程管理
   - 存储管理
   - 作业管理
   - 文件管理
   - 设备管理

### 6.2 操作系统概览

### 6.2.1 what & why

#### 6.2.1.1 **What**

> 管理软件、提供用户交互的软件系统

- 操作系统是管理计算机硬件和软件资源的**计算机程序**
- 管理配置内存、决定资源提供供需顺序、控制输入输出设备等
- 操作系统提供让用户和系统交互的**操作界面**
- 操作系统的种类是多种多样的，不局限于计算机
- 从手机到超级计算机，操作系统可简单也可复杂
- 在不同的设备上，操作系统可向用户呈现多种操作手段
- 常见的操作系统种类：Android、Ios、Windows、Linux、MacOs、华为鸿蒙

#### 6.2.1.2 **Why**：

- 我们不可能直接操作计算机硬件
- 设备种类繁多复杂，需要统一界面
- 操作系统的简易性使得更多人能够使用计算机

### 6.2.2 操作系统的基本功能

1. 操作系统统一管理着计算机资源
   - 处理器资源
   - 存储器资源
   - IO 设备资源
   - 文件资源
2. 操作系统实现了对计算机资源的抽象
   - 用户无需面向硬件接口编程
   - IO 设备管理软件，提供读写接口
   - 文件管理软件，提供操作文件接口
3. 操作系统提供了用户与计算机之间的接口
   - 图像窗口形式
   - 命令形式
   - 系统调用形式

### 6.2.3 操作系统相关概念

1. 并发性

   > 什么是并行，什么是并发

   - 并行是指两个或者多个事件可以在**同一时刻**发生
   - 并发是指两个或者多个事件可以在**同一时间间隔**发生

2. 共享性

   - 共享性表现为操作系统中的资源可供多个并发的程序共同使用
   - 这种共享使用的形式称之为资源共享
   - 多个程序可以同时使用主存资源
   - 资源共享根据属性可以分为两种方式
     - 互为共享形式
       - 当资源被程序 A 占用时，其他想使用的话只能等待
       - 只有进程 A 使用完成以后，其他进程才可以使用该资源
     - 同时访问形式
       - 某种资源在一段时间内被并发地被多个程序访问
       - 这种”同时“是宏观的，从宏观去看该资源可以被同时访问

3. 虚拟性

   - 虚拟性表现为把一个**物理实体**转变为若干个**逻辑实体**
   - 物理实体是真实存在的，逻辑实体是虚拟的
   - 虚拟的技术主要分为**时分复用技术**和**空分复用技术**
   - 时分复用技术：
     - 资源在时间上进行复用，不同程序并发使用
     - 多道程序分时使用计算机的硬件资源
     - 提高资源的利用率
     - 它又分为
       - 虚拟处理器技术
         - 借助多道程序设计技术
         - 为每个程序建立进程
         - 为买个程序分时复用处理器
       - 虚拟设备技术
         - 物理设备虚拟为多个逻辑设备
         - 每个程序占用一个逻辑设备
         - 多个程序通过逻辑设备并发访问
   - 空分复用技术
     - 充分复用技术用来实现虚拟磁盘、虚拟内存等
     - 提高资源的利用率，提升编程效率
     - 它又分为
       - 虚拟磁盘技术
         - 物理磁盘虚拟为逻辑磁盘
         - C、D、E 等逻辑盘
         - 使用起来更加安全、方便
       - 虚拟内存技术
         - 在逻辑上扩大程序的存储容量
         - 使用比实际内存更大的容量
         - 大大提升编程效率

4. 异步性

   - 在多道程序环境下，允许多个进程并发执行
   - 进程在使用资源时可能需要等待或放弃
   - 过程的执行并不是一气呵成，而是以走走停停的形式推进

### 6.3 进程管理之进程实体

### 6.4 进程管理之五状态模型

### 6.5 进程管理之进程同步

### 6.6 Linux 的进程管理

### 6.7 作业管理之进程调度

### 6.8 作业管理之死锁

### 6.9 存储管理之内存分配与回收

### 6.10 存储管理之段页式存储管理

### 6.11 存储管理之虚拟内存

### 6.12 Linux 的存储管理

### 6.13 操作系统的文件管理

### 6.14 Linux 文件的基本操作

### 6.15 Linux 的文件系统

### 6.16 操作系统的设备管理

### 6.17 操作系统基础篇专项练习题 39 道

### 6.18 专项练习题答案揭晓与解析

### 6.19 请回答操作系统是如何启动的？

## 7 操作系统之提升篇

### 7.1 本章节知识点概要与学习计划

### 7.2 线程同步之互斥量

### 7.3 线程同步之自旋锁

### 7.4 线程同步之读写锁

### 7.5 线程同步之条件变量

### 7.6 线程同步方法总结

### 7.7 使用 fork 系统调用创建进程

### 7.8 进程同步之共享内存

### 7.9 进程同步之 Unix 域套接字

### 7.10 请拓展调研进程间通信还有那些方法

## 8 操作系统实践

### 8.1 本章节知识概要与学习计划

### 8.2 Python 同步原语

### 8.3 实现线程安全的队列 Queue

### 8.4 实现基本任务对象 Task

### 8.5 线程池简介

### 8.6 实现任务处理线程 ProcessThread

### 8.7 实现任务处理线程池 Pool

### 8.8 编写测试用例

### 8.9 实现异步任务处理 AsyncTask

## 9 计算机网络之概述篇

### 9.1 本章节知识概要与学习计划

### 9.2 计算机网络的发展简史

### 9.3 层次结构设计的基本原则

### 9.4 现代互联网的网络拓扑

### 9.5 计算机网络的性能指标

### 9.6 物理层概述

### 9.7 数据链路层概述

### 9.8【 讨论题】在数据链路层和物理层中工作的设备都有哪些？

### 9.9 数据链路层的差错监测

### 9.10 最大传输单元 MTU

### 9.11 以太网协议详解

### 9.12 计算机网络概述篇专项练习题 19 道&面试常考题分享

### 9.13 专项练习题答案揭晓与解析

## 10 计算机网络之网络层篇

## 11 计算机网络之传输层

## 12 计算机网络之应用层篇

## 13 计算机网络实践

## 14 课程精髓终结
