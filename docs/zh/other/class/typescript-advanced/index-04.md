# 04-TS 类易被忽视的重要技能，单件设计模式和相关技能深入

## 01：【单件设计模式理解】理解定义+定义陷阱（坑）

### 了解设计模式

设计模式通俗的讲，就是一种更好的编写代码方案，打个比喻：从上海到武汉，你可以选择做飞机，坐轮船，开车，骑摩托车等多种方式，把出行看成是编码，那么选择飞机相对就是一个更好选择的优化方案

### 常见设计模式概述

常见的设计模式有：**单件设计模式、简单工厂设计模式、工厂方法、抽象工厂设计模式、观察者设计模式、装饰器设计模式、代理设计模式、MVC、MVP、MVVW 架构设计模式**。本课程讲解单件设计模式，原因有两个：

1. 设计模式并非 Typescript 课程的重点，我们要把更多时间留给TS核心技能，
2. 单件设计模式短小精悍，能更好的帮助掌握 TS类，类的静态方法、类构造器、类对象。

### 单件设计模式的两种定义和定义中存在的陷阱

**简单定义1**：一个类对外有且仅有一个实例【只提供一个实例】这种编码方案就是单件设计模式

**完整定义1**：如果某个类始终只提供一个对象【实例】，并且在该类的内部提供了一个外部访问该对象的方法或者该对象属性，那么这种编写代码方案【就是设计模式】就是单件设计模式

**完整定义2**：如果一个类的任何外部通过访问类提供的某个方法或者某个属性始终只能获取该类的一个对象【实例】，但如果该类提供了多个外部可以访问的方法或者属性，那么外部就能访问到该类的多个不同的对象，但从实际开发来看，绝大多数情况下的应用场景，我们对外都只是提供一个唯一的可以访问的方法或者属性，这样就保证了实例为单个，类的这种编写代码的方案【就是设计模式】就是单件设计模式

哪一种定义对？

### 何时使用单件设计模式？

实际开发中，外部访问某个类的对象【实例】时，确保只能访问该类的唯一对象的才能保证逻辑的正确性。这时就应该使用单件设计模式了

### 前端领域单件设计模式的真实应用场景

**应用场景1**：比如 Vuex、React-Redux 中的全局状态管理容器 store 对象在整个项目被设计成唯一的对象【实例】，把 store 对象所在的类设计成单件设计模式模式将是最好的设计方案【当然也可以有其他替代方案】

**应用场景2**：一般前端项目需要进行客户端本地数据存储时，都会考虑 localStorage、localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取、修改同一份 localStorage 数据，那封装 localStorage 设计成一个单件模式类就再合适不过了【尽管也可以用其他方法，但依然存在问题，编码时我们会给同学们说明】

**应用场景3**：我们知道项目日志记录是一个项目中必不可少的环节，当我们为一个项目编写一个日志文件类，用来保存日志和阅读日志信息时，这个日志文件类可以有多种设计方案，但把类设计成单件模式就是最好的模式， 因为每次存储日志信息到日志文件上时都创建一个日志对象，这既没有必要，也很浪费内存空间

## 02：【单件设计模式应用】构建单件 localStorage 类（真实应用场景）

### 使用原生 localStorage 的弊端

```javascript
localStorage.setItem('count', '30')
const loginInfoObj = { username: '猪八戒', age: 23 }
localStorage.setItem('userInfo', JSON.stringify(loginInfoObj))
// 问题1：代码零散
// 问题2：可读性差，不能顾名思义
// 问题3：对后期的维护产生影响
let value = localStorage.getItem('userInfo')
if (value != null) {
  value = JSON.parse(value)
} else {
  value = null
}
```

### 构建单件 localStorage 类

> 这种模式也叫做懒汉式单件设计模式，延迟使用，使用时才创建

构建单件设计模式的步骤

1. 把构造器设置为私有的，不允许外部来创建类的实例【对象】
2. 至少应该提供一个外部私有的方法或者属性，外部可以通过这个方法属性来得到一个实例，所以应该把这个方法设置为静态方法
3. 外部调用第二步提供的静态方法来获取一个对象

```typescript
class MyLocalStorage {
  // 静态属性
  static instance: MyLocalStorage
  // 1. 把构造器设置为私有的，不允许外部来创建类的实例【对象】
  private constructor() {}
  // 2.提供一个外部私有的方法或者属性来得到一个对象实例
  // 1. 带 static 关键字的方法就是一个静态方法
  // 2. 静态方法和对象无关，外部的对象变量不能调用静态方法和静态属性
  // 3. 外部可以通过类名来调用
  public static getInstance() {
    if (!this.instance) {
      this.instance = new MyLocalStorage()
    }
    return this.instance
  }

  public setItem(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value))
  }
  public getItem(key: string) {
    const value = localStorage.getItem(key)
    return value != null ? JSON.parse(value) : null
  }
}

// 测试代码,需要变为 js 在 index.html 进行运行
const myLocalStorage = MyLocalStorage.getInstance()
myLocalStorage.setItem('userInfo', { username: '猪八戒', age: 23 })
const value = myLocalStorage.getItem('userInfo')
console.log(value)
```

## 03:【单件设计模式关联的深层技能】静态属性9大规则+静态方法

1. **懒汉式单件设计模式**：懒汉式单件设计模式是再你真正用到类的实例时才创建这个唯一的对象**

### 静态方法的特点

1. **外部如何调用TS 类的静态成员**

   > 类名直接调用静态成员，格式：类名.静态属性 类名.静态方法

2. **TS类的一个静态方法如何调用其他的静态成员**？

   >  使用 this 来获取静态成员

3. **静态方法是否可以访问类中原型对象上的方法或者对象属性【对象基本类型数据+对象引用属性】，反过来呢？**

   > 都不行

4. **对象变量是否可访问静态成员？**

   > 不能

5. **一个静态方法改变了某个静态属性，其他静态方法或者类外部任何地方访问这个属性都会发生变化**

6. **静态成员保存在内存那里？何时分配的内存空间呢？**

   > 任何一个 TS 类中的静态成员存储在内存的静态去，运行一个 TS 类，TS 首先会为静态成员开辟内存空间，静态成员的内存空间分配的时间要早于对象空间的分配，也就是任何一个对象创建之前TS 就已经为静态成员分配好了空间。但一个静态方法或者静态属性只会分配一个空间，只要当前服务器不重启或者控制台程序还没有结束之前【如果是开发期间的测试，一般用控制台】。那么静态方法或者静态属性一直存在内存空间，无论调用多少次这个静态方法，都是调用的同一块空间

   总结静态方法，两点：

   **总结1**：无论是否创建对象，创建多少个对象，是否调用该静态方法或者静态属性，TS 都会为这个静态方法或者静态属性分配内存空间，注意：静态成员和对象无关

   **总结2**：一旦为静态方法或者静态属性分配好空间，就一直保存在内存中，直到服务器重启或者控制台程序执行结束才会被释放、

   **彩蛋：new 一个 TS 类的方法可以吗？能在 TS 类外部使用 prototype 为 TS 类增加方法或者属性吗？**

   虽然在 JS 中可以 new 一个类【构造函数】内部定义的对象方法或者静态方法，但是 TS已经屏蔽了去 new 一个类中的方法【js可以，会当做一个构造函数】，TS 类可以访问 prototype 原型对象属性，但是可以重写已有的对象方法或者属性，但是无法再 prototype 原型对象属性增加新的方法或者属性，这么做，就是让我们只能在类的内部定义方法，防止回到 ES5 从前非面向类的对象写法

7. **静态方法或者静态属性和原型对象空间上的方法或者属性有何区别？**

   > 原型对象空间上的方法和属性是用来提供给类的所有对象变量公用的方法或者属性，没有对象和对象变量，原型上的属性和方法就没有了用武之地。而静态方法或者静态属性属于类，可以通过类直接访问。任何一个对象创建之前 TS 就已经为静态成员分配了空间，但一个静态方法或者静态属性只会分配一个空间，而每一个对象都有自己独立的空间

8. **静态方法是否可以接受一个对象变量类作为方法的参数？**

   >可以，静态方法内部不能通过 this 来访问对象属性和方法，但可以通过调用静态属性时把对象变量传递给静态方法来使用。比如我们把 js 的Object 构造函数想象成一个 TS 类【实际TS 类编译后的 js 文件中就变成了一个构造函数】，Obejct 类就拥有了大量的静态方法，例如 apply call bind keys 等，现在我们来关注静态方法是否可以接受对象变量作为方法的参数，我们可以以 Object.keys 方法为例【Object类的 keys 方法用来获取给定对象的自身可枚举属性组成的数组】。

   ```typescript
   // 我们可以把 Object 构造函数看成一个 Object 类，创建 Object 类的对象
   let obj = new Object({ username: '王五', age: 12 }) // 1
   let obj2 = { username: '王五', age: 12 } // 2  2是1 的简写
   // 把 obj 对象变量传递给keys 静态方法，obj 对象变量作为 keys 静态方法的参数
   Object.keys(obj)
   ```

9. **何时应该把一个方法定义成静态方法或者属性定义为静态属性呢？【应用】**

   > **应用1：单件设计模式是静态方法和静态属性很好的应用场景之一**。当外部不能创建对象，就只能借助类内部的静态方法来获取类的独享，这时肯定不能把这个方法定义成原型对象属性上的方法，只能定义为类的静态方法，因为如果定义成原型对象的方法，就会导致外部无法被访问，因为外部根本不能创建对象，也就无法访问原型对象属性上的方法，而静态方法要访问的属性就只能是静态属性了，这也是静态属性的应用时机。
   >
   > **应用2：当类中的某个方法没有任何必要使用任何对象属性时，而且使用了对象属性反而让这个方法的逻辑不正确，那既如此，就应该禁止这个方法访问任何对象属性和其他的对象方法，这时就应该把这个方法定义为静态方法**。例如：一个顾客类的购买方法【buy方法】中肯定要允许访问顾客姓名或者其他顾客微信这些对象属性，这样的方法我们就**需要定义在原型对象属性上**。但如果顾客类中的阅读顾客积分公告方法【readNotice方法】是针对全体顾客的公告方法，就应该定义为静态方法，方法内部就应该禁止出现任何具体的对象属性。如果在这样的方法中使用了顾客的某个属性，比如用了顾客姓名，那么这个方法逻辑就不正确【这个方法就会说：你让我向全体顾客展示公告，我要知道每个顾客姓名什么？】所以我们应该让这样的方法禁止访问对象属性和其他的对象方法，那就应该设置为静态方法
   >
   > **应用3**：当一个类中某个方法只有一个或者1-2个对象属性，而且更重要的是，你创建这个类的对象毫无意义，我们只需要使用这个类的一个或者多个方法就可以了，那么这个方法就应该定义为静态方法。常见的工具类中的方法通常都应该定义为静态方法。比如 StringUtil FileUtils等，我们以 FileUtil 为例进行讲解

   思考题：定义一个文件工具类【FileUtil】，编写一个读取文件方法【readFile方法】方便外部调用，那这样的方法应该定义为静态方法吗？

   答：定义在原型属性上和定义为静态方法似乎都可以，只要 readFile 方法获取到外部提供文件名就可以展开文件读写。请看下面两端代码，我们仔细比较后再来决定使用哪一种方案？

   ```typescript
   class FileUtil {
     // 从指定文件上把读取数据读出来打印在控制台或者页面上的静态方法
     public static readFile(readonly filename: string) {
       fs.readFile(filename, (err: any, data: any) => {
         console.log('fs.readFile', data.toString())
       })
     }
     // 把键盘输入的数据或者页面上获取的数据写入到指定文件上的静态方法
     public static writeFile(filename: string) {
       fs.writeFile(filename, '唐僧', function (err) {
         if (err) {
           console.log('写文件失败')
         } else {
           console.log('写文件成功')
         }
       })
     }
   }
   FileUtil.readFile('./log.txt')
   FileUtil.writeFile('./log.txt')
   
   // 实际应用中，读写一般都不在一个时间段，可能读功能完成后，过了几分钟，用户才在客户端执行写的方法，
   // 又过了一会，用户又在客户端执行了读的方法，但是我们知道静态方法实际上是一直保存在内存空间的，这样反复操作其实节省了大量反复创建和释放 FileUtil 对象的时间和对应的对象内存空间
   ```

   ```typescript
   class FileUtil {
     constructor(public filename: string) {}
     // 从指定文件上把读取数据读出来打印在控制台或者页面上的静态方法
     public readFile() {
       fs.readFile(this.filename, (err: any, data: any) => {
         console.log('fs.readFile', data.toString())
       })
     }
     // 把键盘输入的数据或者页面上获取的数据写入到指定文件上的静态方法
     public writeFile() {
       fs.writeFile(this.filename, '唐僧', function (err) {
         if (err) {
           console.log('写文件失败')
         } else {
           console.log('写文件成功')
         }
       })
     }
   }
   // 实际应用中，读写一般都不在一个时间段，可能读功能完成后，过了几分钟，用户才在客户端执行写的方法，
   // 又过了一会，用户又在客户端执行了读的方法，所以每次都要创建 FileUtil 对象
   // 这样反复创建和释放 FileUtil 对象，就浪费了大量反复创建和释放 FileUtil 对象的时间和对应的对象内存空间
   new FileUtil("./log.txt").readFile()
   new FileUtil("./log.txt").writeFile()
   ```

10. **对于第九项思考题中的关于使用静态属性和静态方法的解决方案绝对不能用在学生、顾客其他应用场景，那么就会导致三个比较严重的问题，以学生对象为例**

    1. 浪费了很多不必要的内存空间：运行一开始就为大量的静态属性和静态方法分配了内存空间【但很可能某个静态方法一直没有使用，白白的一直占着内存空间】
    2. 无法展示一个学生一个对象的直观效果，完全失去了对象来描述实体的优势
    3. 最严重的问题：属性值一变则都变

    所有的操作都在用一个静态方法空间来完成某种功能，一旦某个操作改变了静态方法中的某个值，比如改变了学生姓名，则其他操作访问到这个静态变量看到的结果全变了。

## 04:【单件设计模式其他实现】第二种实现方式+两种方式对比

### 饿汉式单件设计模式【编码实现】

> 饿汉式单件设计模式是无论你是否用到了对象【实例】，一开始就建立这个唯一的对象

```typescript
class MyLocalStorage {
  // 静态属性
  static instance: MyLocalStorage = new MyLocalStorage()
  //  把构造器设置为私有的，不允许外部来创建类的实例【对象】
  private constructor() {}
  public setItem(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value))
  }
  public getItem(key: string) {
    const value = localStorage.getItem(key)
    return value != null ? JSON.parse(value) : null
  }
}

// 测试代码
const myLocalStorage = MyLocalStorage.instance
myLocalStorage.setItem('userInfo', { username: '猪八戒', age: 23 })
const value = myLocalStorage.getItem('userInfo')
console.log(value)
```

