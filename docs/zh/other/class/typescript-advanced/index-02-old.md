# 02- 全栈思维全面深度掌握 TS 类 【 TS 技术根基】

## 01:【TS 类准备】TS 类底层根基，不一样的方式理解 JS 原型

### 为什么要用原型(好处)

> 原型上所有的方法和属性都可以被构造函数【实际开发原型主要是共享方法和所有实例公用引起属性】的实例共享，那么为什么要共享呢？先来看一个案例【先不管什么是原型】

### 没有使用原型会有什么问题？

> 总结问题：所有 QQUser 对象【也叫做 QQUser 实例】都有相同的好友属性，好友属性 commonfriends 英文表示，所有 QQUser 对象都有相同的 show 方法。但是我们发现每一个 QQUser 对象【也叫做 QQUser 实例】都单独分配一个 commonfriends 属性空间和 show 方法空间，导致了大量的空间浪费
>
> 答案：使用原型解决，解决了所有实例上的方法，还有所有实例上的共同属性都可以放到原型上去定义

## 02：【TS 类准备】TS 类底层根基，深入 JS 原型【不同以往的讲解，给你带去全新收】

```typescript
function QQUser(QQNo_, QQAge_, QQMark_) {
  this.QQNo = QQNo_ // QQ 号码
  this.QQAeg = QQAge_ // QQ 年龄
  this.QQMark = QQMark_ // QQ 标签
  this.commoneFriends = ['骑驴看海', '大漠上的英雄', '坚实的果子', '小草'] // 共同好友
  this.show = function () {
    console.log(
      `QQ号码：{this.QQNo},QQ龄: ${this.QQAge},QQ标注：${this.QQMark}`,
      console.log(`共同的好友是:${this.commoneFriends}`),
    )
  }
}

let QQZhangSan = new QQUser('张三', 15, '王阳明传人')
let QQLisi = new QQUser('李四', 10, '袁隆平的徒弟')
let QQLiuwu = new QQUser('刘武', 12, '飞起来的鸭子')

QQZhangSan.show()
```

## 03：【原型】深度透彻掌握原型 【为深度透彻掌握 TS 类，继承扎根】-1

### 认识函数 + 原型定义

1. 函数也是一个对象，当真正开始执行函数，执行环境【开发时为浏览器或者控制台】会为函数分配一个函数对象变量空间和函数对象空间，函数对象变量用函数名表示，存在栈空间中，函数对象空间是再堆中开辟的一个内存空间，这个空间中有一个默认的 prototype 属性，这个 prototype 属性就是一个原型对象属性【也叫做对象变量】

2. 函数和构造函数的区别

   > 当通过 new 函数（）时，此刻这个函数就是构造函数【日后会演变成 TS 类的构造器】

3. 定义：原型【prototype】是定义函数由 js 自动分配给函数的一个可以被所有构造函数实例对象变量共享的对象变量【也叫对象属性】

### 如何访问原型对象空间上的属性和方法

1. 构造函数所有实例对象都可以访问原型对象空间上的属性和方法【每一个实例都有默认的 proto 属性，这个 proto 属性指向原型对象空间】
2. 关于\_\_proto\_\_: new 在创建新对象的时候，会赋于新对象一个属性指向构造函数的 prototype 属性，这个属性就是 proto
3. 可以直接通过构造函数 .prototype 对象属性来访问原型对象空间上的属性和方法

## 04：【原型】深度透彻掌握原型 【为深度透彻掌握 TS 类，继承扎根】-2

## 05：【原型】深度透彻掌握原型 【为深度透彻掌握 TS 类，继承扎根】-3
