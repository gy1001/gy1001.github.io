接触了强缓存的“不善交际”，本文笔者将带大家认识“乐于沟通”的协商缓存。强缓存与协商缓存并不是两个相对独立的概念，两者其实有着密不可分的联系，从协商缓存的概念中我们便可略知一二。

> 协商缓存可以看作是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

由此可知，**浏览器启用协商缓存的前提是强缓存失效**，但是反过来强缓存失效并不一定导致浏览器启用协商缓存。下面我们来了解下协商缓存的生效流程。

## 协商缓存的生效流程

为了让大家更容易理解，笔者还是用流程图的方式来进行介绍，如下图所示：

![协商缓存生效流程.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea9a25261da4d33a2e3bc9765f9e2fb~tplv-k3u1fbpfcp-watermark.image?)

图中，我们先经历了一段强缓存的失效流程：浏览器发起 HTTP 请求后浏览器缓存发现该请求的资源失效，便将其**缓存标识**返回给浏览器，于是浏览器携带该缓存标识向服务器发起 HTTP 请求，之后服务器根据该标识判断这个资源其实没有更新过，最终返回 `304` 给浏览器，浏览器收到无更新的响应后便转向浏览器缓存获取数据。

以上步骤阐述了关于协商缓存生效的流程，其经历了一次浏览器与服务器协商的过程，并最终返回 304 未更新来达到读取缓存的目的，我们可以通过下方更为生动的对话来理解协商缓存不同流程间的关系：

```
小白：小黑，你几岁了？
小黑：小白，我18岁了。

- - - - - - - - - - - - - - - - - - - - - - - -

小白：小黑 ，你几岁了？我猜你18岁了。
小黑：靠，你知道还问我？（304）

- - - - - - - - - - - - - - - - - - - - - - - -

小白：小黑 ，你几岁了？我猜你18岁了。
小黑：小白 ，我19岁了。（200）
```

从上至下小白与小黑的对话分别代表了浏览器与服务器间进行第一次数据请求、协商缓存生效及协商缓存失效的过程。

## 缓存标识 Last-Modified 与 ETag

除了强缓存失效外，浏览器判断是否要走协商缓存还得借助上述提到的缓存标识：`last-modified`、`eTag`，这两个首部字段我们在前面章节已经有所介绍，它们是服务器响应请求时返回的报头首部，如下图所示：

![20210831212257.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41afe7ef47664d47b7f4ac9df100f004~tplv-k3u1fbpfcp-watermark.image)

eTag 的优先级要高于 last-modified，当两者同时出现时，只有 eTag 会生效。只要有这两个缓存标识之一，在强缓存失效后浏览器便会携带它们向服务器发起请求，携带方式如下图请求头所示：


![20210930213501.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565fb2c410a14b60b7a796287134b949~tplv-k3u1fbpfcp-watermark.image)

其中 `if-modified-since` 对应 last-modified 的值，`if-none-match` 对应 eTag 的值。服务器根据优先级高的缓存标识的值进行判断。

倘若 eTag 对应的 if-none-match 不存在，那么服务器会将 last-modified 对应的 if-modified-since 的时间值与服务器该资源的最后修改时间进行对比，最后判断是否走协商缓存。

**那么 last-modified 有会什么弊端？服务器进行对比时一定精准吗？**

last-modified 是一个时间，最小单位为秒，试想一下，如果资源的修改时间非常快，快到毫秒级别，那么服务器会误认为该资源仍然是没有修改的，这便导致了资源无法在浏览器及时更新的现象。

另外还有一种情况，比如服务器资源确实被编辑了，但是其实资源的实质内容并没有被修改，那么服务器还是会返回最新的 last-modified 时间值，但是我们并不希望浏览器认为这个资源被修改而重新加载。

为了避免以上现象的发生，在特殊的场景下，我们便需要使用 eTag。

## ETag 原理及实现

那么相比 last-modified，eTag 到底有什么优势？回答这个问题前我们需要去了解 eTag 值的生成原理，而不同的后端语言对 eTag 有着多种处理方式，这里笔者将以 `node` 中下载量领先的 [etag](https://www.npmjs.com/package/etag) 包为例进行介绍。

eTag 包的源码十分简洁明了，其生成 eTag 值的方式有两种，**第一种方式：使用文件大小和修改时间**。

![20210901214458.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8db8ac2e6c744ca5bad20dcf5ea4f906~tplv-k3u1fbpfcp-watermark.image)

图中当判断所要处理的内容是文件 stats 对象时，将会采用上述方法生成 eTag 值，最后返回的值是由文件大小和文件最后一次修改时间组成的字符串。

而当内容非文件 stats 对象时，将采用**第二种方式：使用文件内容的 hash 值和内容长度**。

![20210901215128.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4412cc86d0ab49ff8ef65a12f9f5a6c8~tplv-k3u1fbpfcp-watermark.image)

图中方法通过对内容的 hash 转化和截取，最终返回内容长度与其 hash 值组合成的字符串。

通过上述方法生成的 eTag 也被称为**强 eTag 值**，其不论实体发生多么细微的变化都会改变它的值。那么与其对立的便是**弱 eTag 值**，在 eTag 包源码中我们可以发现通过传递第二个参数 `weak` 值为 `true` 时便可启用弱校验。

> 弱 ETag 值只适用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时会在字段值最开始处附加 W/。

```
ETag: W/"29322-09SpAhH3nXWd8KIVqB10hSSz66"
```

最终我们通过针对 eTag 原理及实现的分析，不难发现使用 eTag 服务器能够更加精准的分析资源的改变，同时浏览器也便能更加精准的控制缓存。


## 彩蛋：启发式缓存

在强缓存的介绍章节中，我们提到计算强缓存新鲜度的公式为：`缓存新鲜度 = max-age || (expires - date)`。

那么大家有没有想过如果响应报头中没有 max-age（s-maxage） 和 expires 这两个关键的字段值时，强缓存的新鲜度如何计算？

有读者可能会疑惑没有了强缓存的必要字段值，浏览器还会走强缓存吗？答案是肯定的。比如下方的响应报头：

```
date: Thu, 02 Sep 2021 13:28:56 GMT
age: 10467792
cache-control: public
last-modified: Mon, 26 Apr 2021 09:56:06 GMT
```

以上报头中没有用来确定强缓存过期时间的字段，这便无法使用上面提到的缓存新鲜度公式，虽然有与协商缓存相关的 `last-modified` 首部，但并不会走协商缓存，反而**浏览器会触发启发式缓存**。启发式缓存对于缓存新鲜度计算公式如下所示：

```
缓存新鲜度 = max(0,（date - last-modified)) * 10%
```

**根据响应报头中 date 与 last-modified 值之差与 0 取最大值后取其值的百分之十作为缓存时间。**

启发式缓存比较容易被忽视，不了解启发式缓存的读者可能会因为这种默认的缓存模式而掉入坑里，百思不得其解，但是一旦你了解了浏览器触发启发式缓存的机制，那么很多缓存问题便会迎刃而解。

最后，笔者继续抛出一个问题：**如果连 last-modified 都没有，缓存新鲜度为多少？**

这种情况其实非常少见，因为一个合理的资源必定是有合理的缓存首部的，但是万一服务器真的没有配置和返回怎么办，这个问题留给大家去思考下。

## 结语

本文从协商缓存出发，带领大家认识了它的生效流程与不同阶段，相比强缓存，协商缓存有着它特有的首部字段和校验机制，同样在前端缓存策略中发挥着重要的作用，同时其与强缓存也相辅相成，优势互补，共同组成了 HTTP 缓存。


