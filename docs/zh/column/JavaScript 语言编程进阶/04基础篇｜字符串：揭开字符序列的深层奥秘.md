**字符串（String）应该是 JavaScript 所有 8 种类型中最常见的一种**。我们经常会去组装、比较、截取、分解、搜索字符串，当然最常见的莫过于获取字符串长度。我相信大家都或多或少接触过下面这些需求：

1.  限制输入框中的内容长度，保证在具体的位置能够显示得下；
1.  拼接服务端的数据为一个阅读良好的提示语，展现给用户，比如“操作失败，错误码为XXX”；
1.  在固定格式中舍弃一部分信息，保留剩余内容，比如在身份证号中获取生日信息；
1.  在用户输入数据或者服务端数据中替换关键词，比如将“您`${0}`收入为`${1}`”的占位符 “`${}`” 替换成有效数据。

这些操作看似非常基础，但是这些年来受到 Unicode、Emoji 快速扩展，以及 ECMA262 规范新增 API 的影响之下，已经产生了很多在使用、认知上的误区，即便这些基础操作也可能产生错误的结果，比如文本经处理后产生乱码，又或者展示超出了显示区域。

要捋清字符串常用操作的关键点，减少处理出错的可能，首先我们要从认识其基本结构开始。

## 基本结构

简单来说，**字符串可以定义为以“字符”为基本单位的有序序列**。但是这里的字符却并不是我们直觉意义上能看到的一个文字符号，比如英文字母“A”，或者汉字“中”，亦或是标点符号“·”，而是一个叫做“**码元（Code Unit）** ”的东西，占据 16bit，即 2byte 空间。

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d9d7c8ad8b4404fae468edaac27c12e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

我们应该知道，无论什么数据在计算机内容中都是二进制的数字表示的，因此一个码元就是一个 16 位无符号整数，最大为 0xFFFF。这个数字是需要映射到可见的、有意义的文字符号的，这个映射关系本来是由字符集 Unicode 来负责的，比如数字 65 映射为大写英文字母“A”，数字 0x4E2D 映射为汉字“中”，数字 0x20BFF 映射为“𠯿”。但是，通常来说一个字符的 Unicode 编码值不适合用来直接存储和传输，原因包括：

1.  纠错问题，即便错了一二进制位，就会变成另一个合法的字符；
1.  前导问题，一个字符的编码值可能是另一个字符的前面一部分。

因此，Unicode 编码值会通过算法再次编码转换成另一个数字，来进行存储和传输。这个过程称为**字符编码**，我们常见的字符编码比如 GBK、GB2312、UTF-8 等等。这个编码过程虽然会浪费一部分空间，但是却拥有了一定的纠错能力，并且规避了前导问题，使得应用程序可以高效、无误地读取。

回到字符串的结构上来，JavaScript 的码元就是经过字符编码后的整数，只不过这个编码并不是我们耳熟能详的，而是一个叫做 `UTF-16` 的编码方案，这是历史原因造成的。相较于 UTF-8 编码后可能是 1byte、2byte、3byte、4byte 而言，大家注意，UTF-16 编码后只可能是 2byte 或 4byte 的。

下图展示了文字符号是如何转换成码元的过程：

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff6cca1ef064bc2815f43c4fa72b915~tplv-k3u1fbpfcp-watermark.image" alt="image.png"  /></p>

由于一个码元固定是 2byte 的，于是**一个 Unicode 字符在 JavaScript 字符串中可能占据 1 个码元，也可能占据 2 个**。

记住这个结论，它将给我们后面要讲到的很多字符串操作带来麻烦，首当其冲地，就是获取字符串长度。

## 获取长度

获取字符串长度最简便的方法莫过于访问其 length 属性：

```ts
"我爱学习ABC。".length // 8
```

拿到 length 的目的通常有下面两种：

1.  受到数据库的存储容量限制，推算占用字节数；
1.  推算可能的渲染宽度，做截断，避免显示不下。

先来看第一个问题，如何计算一个字符串的占用字节数呢？首先一个码元占用 2byte 这是固定的规则，我们只需要知道字符串含有几个码元即可。好在 length 的定义很清晰，就是码元的个数，一个码元 2 字节，最终字符串的内存占用就是 `length × 2byte`。下面这个例子中，字符串“我是中国人”占用 10 字节。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3a48f1bf75341ba9582a05023f1ffae~tplv-k3u1fbpfcp-watermark.image" alt="image.png"  /></p>

一个字符串最多包含$$2^{53}-1$$个码元，这也是 JavaScript 所能表示的最大整数，即 `Number.MAX_SAFE_INTEGER`。

再来看第二个问题，好多人都还在用 length 来推算文本在页面上的显示宽度。由于英文字母、标点符号和汉字的显示宽度明显不一样，因此有人做了改进，判断字符是否为汉字，如果是则算作两个英文字母的宽度。

显然这样的做法是非常粗糙的，英文字母本身也不是等宽的，再说汉字也不像字母文字那样符号数量是有限的，数以万计的汉字，再加上类似的韩文、日文，几乎没有完美的方法可以覆盖全面。即便只考虑常用汉字，那么也无法枚举其他语言，比如阿拉伯文。下图显示了不同字符的自身显示宽度，可见很难找到什么规律。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a62a8ecc7bf44dc88bfa888f3b6ebf0~tplv-k3u1fbpfcp-zoom-1.image" alt=""  /></p>

因此，**建议大家不要依赖 length 来推断显示宽度，视觉问题还得依赖 CSS 解决才更健壮**。如果你认为这些特殊字符不常见，不必考虑，那么我们看下面这个例子：

```ts
"🧑🏽‍🚒".length // 7
```

不同于他国文字，Emoji 在汉语环境中会常常被使用，来辅助表达语气、心境。很多人第一次看到上面的结果都会特别震惊，明明是一个字符，为什么 length 会等于 7 ？

我们先以更简单一点的例子入手，汉字“𠯿”的 length 等于 2，也是反直觉的：

```ts
"𠯿".length // 2
```

在上面一小节中，我们得出一个结论，Unicode 字符在 JavaScript 的 UTF-16 编码中，会占据 2byte 或者 4byte 空间，也即 1 码元或者 2 码元。而 length 反映的是码元的数量，所以“𠯿”就是占据 4byte 的那一种，在上一小节中我们已经看到了它经过 UTF-16 编码后是 0xD842DFFFF，就是 2 个码元。

Unicode 的编码区间是 0x0000～0x10FFFF，其范围是 1 码元所能表示范围（0x0000~0xFFFF）的 17 倍之多。因此，有相当多的字符在 JavaScript 中都必须编码成 2 码元才行。但是应该最多也就 2 码元了，刚刚那个 Emoji 返回的 7 是怎么回事呢？

其实这是由于 Emoji 的一个叫做“修饰序列（Modifier Sequence）”的功能造成的：在一个基础的 Emoji 编码后面，添加修饰符的编码，中间用 0x200D 来分隔，这样产生的一系列码元，只会显示成一个 Emoji 外观。

“🧑🏽‍🚒”实际是这样几个字符共同组成的：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9fedf43fe94fea87a44ec85ad9978c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

其中，第一个 Unicode 字符 0x1F9D1 占据了 2 个码元，这是一个女性面孔“🧑”，修饰符 0x1F3FD 代表一种深色皮肤，无法单独显示，也占据 2 个码元。紧跟着一个固定的 0x200D 分隔符，占 1 码元，后面还是一个占据 2 码元的修饰符 0x1F692，即“🚒”消防车。这样最后产生的就是一个深色皮肤的女消防员，共占据 7 个码元，14 字节。

修饰序列功能大大拓展了 Emoji 所能表示的范围，但是也进一步破坏了 length 与展示字符之间的关系，大家就更不要以 length 来推断文本的展示宽度了。

修饰序列和双码元字符共同作用，使得字符串对于字符位置的操作更敏感，如果不从正确的位置读取，那么很可能读取到的是无意义的字符碎片，几乎一切基于位置的字符串操作都会被影响到，典型的如字符串截取。

## 字符串截取

截取字符串可分为`截取单个字符`和`截取片段`，前者需要一个下标参数，后者需要 start 和 end 两个下标参数。

注意，这里的“截取”并非指修改原有字符串的字符序列。像很多高级语言一样，JavaScript 中的字符串也是不可变的，任何看似修改其内容的操作，无一例外都是拷贝返回新的字符串实例，比如 slice、replace 等等。我见过有人尝试这样去修改其中某个字符：

```ts
var str = "我在工作"
str[1] = "不"
console.log(str) // "我在工作"
```

结果是显而易见的。其实在 strict 模式下，上面的代码是会抛出异常的。


### 截取字符

先来看截取单个字符，如果把字符串看作是一个字符数组的话，那么一个下标就能唯一定位一个字符：

```ts
"我是中国人"[1] // "是"
```

不过，JavaScript 的字符串还提供了另外两个方法：charAt 和 at。这三种方法仅在细节上有差异：

1.  **数组下标**，如果参数在 `[0, length - 1]` 之外的，返回 undefined，如`"我是中国人"[5] === undefined`；
1.  **charAt 函数**，如果参数在 `[0, length - 1]` 之外的，返回空串，如`"我是中国人".charAt(5) === ""`；
1.  **at 函数**，如果序号是负数，则会加上字符串的 length 作为新的序号，如`"我是中国人".at(-1) === "人"`，但如果新序号不在有效范围之内（小于 0 或者大于 `length - 1`），则会返回 undefined

> 注意：at 函数还比较新，从 Chrome 92、Firefox 90，Safari 15.4 才开始支持。

以上这三种方法的参数都是指码元的位置，因此都会受到双码元的影响，比如我们想截取“𠯿a”中的“a”，由于前面为双码元，导致“a”处于第三个码元中，这时候无论你用上面哪种方法，传入下标 1 都不能得到“a”，只有传入 2 才可以：

```ts
"𠯿a"[2]        // "a"
"𠯿a".charAt(2) // "a"
"𠯿a".at(2)     // "a"
```

而你如果想得到双码元“𠯿”，那么上面任何方法都不能实现，因为它们都只能返回一个码元的内容，必须这样遍历：

```ts
Array.from("𠯿a")[0] // "𠯿"
[..."𠯿a"][0]        // "𠯿"
```

在有 Emoji 修饰序列的场景下，因为它不是一个 Unicode 整体，上述任何方法都无法工作：

```ts
Array.from("🧑🏾🎓a")[0] // "🧑"
[..."🧑🏾🎓a"][0]        // "🧑"
```

### 截取片段

再来看截取片段。ECMA262 提供了两个推荐使用的字符串截取函数：**substring** 和 **slice**，使用方式很类似，比较容易混淆。

它们的参数都是 `[startIndex, endIndex)`，注意是半开区间，区别在于：

1.  substring 允许 endIndex<startIndex，会自动交换这两个值，而 slice 不允许，会返回空串；

```ts
"我是中国人".substring(3, 2) // "中"
"我是中国人".slice(3, 2)     // ""
```

2.  substring 的参数如果是负数，会当作 0 处理，slice 对负数会加上字符串长度。

```ts
"我是中国人".substring(-2, -1) // ""
"我是中国人".slice(-2, -1)     // "国"
```

使用哪个取决于你的习惯，二者在能力上基本是等价的。它们同样也都会受到双码元和 Emoji 修饰序列的影响：

```ts
"🧑🏾🎓a".substring(0, 2) // "🧑"
"🧑🏾🎓a".slice(0, 2)     // "🧑"
"🧑🏾🎓a".substring(7)    // "a"
"🧑🏾🎓a".slice(7)        // "a"
```

如果你想通过截取的方式来实现省略号的效果，那么很有可能得到“莫名其妙”的结果：

```ts
"今天天气晴朗🧑🏾🎓！".slice(0, 9)  // "今天天气晴朗🧑\uD83C"
"今天天气晴朗🧑🏾🎓！".slice(0, 10) // "今天天气晴朗🧑🏾"
```

目前还没有特别好的简单办法来避免这种意外发生，只能根据修饰序列的规范去尽可能识别它，进而避免拆散它。

## 小结

可见，不仅仅是通过 length 获取字符串长度，还是用 charAt、at、substring、slice 截取字符串，所传入的参数都是指以**码元**为最小单位的元素位置，而不是 Unicode 字符的位置，更不是你看到的文字符号的位置。这一特点还作用于更多的字符串操作上，比如：

1.  用 charCodeAt、codePointAt 获取字符 Unicode 值；
1.  用 fromCharCode、fromCodePoint 来构造字符串；
1.  用 indexOf、lastIndexOf 来搜索子串；
1.  用 split 来分解字符串；
1.  用 >、< 来比较大小；
1.  用 match、search、replace 来匹配、搜索和替换子串。

可以说几乎全部字符串的操作都是基于码元结构的，在双码元字符、Emoji 修饰序列的影响下就形成了对三种不同字符概念的认知，一是码元字符，二是 Unicode 字符，三是可见的符号字符。大家需关注不同场合下的字符定义，以制定相应的应对之策。