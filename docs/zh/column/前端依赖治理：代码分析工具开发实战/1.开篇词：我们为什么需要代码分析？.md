随着互联网的发展，很多 Web 应用越来越复杂，前端开发也演变成几十人甚至上百人的多团队/多角色协同开发模式，随着代码量、仓库数量、依赖复杂度的增加，开发者遇到的挑战也越来越大。

这很好理解，如果把现代前端开发想象成是大型商场的日常管理，而我们恰好是它的管理者，那么会遇到哪些挑战呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/817d765e87ea4432a3d85548c21fd837~tplv-k3u1fbpfcp-zoom-1.image)

商场内有服装店、数码店、餐饮店、电影院等经营门店，也有物业管理处、安保、后勤等基础保障团队，各个门店日常的商业活动离不开基础的水电供应、WiFi 网络、日常清扫等服务，或者说经营门店`依赖`基础保障团队提供的服务。为了让`经营门店`与`基础保障团队`更好的配合，身为管理者的你制定了`经营规则`，但还是会发生很多意料之外的问题，比如：

1.  某个服装店在公共通道处放置打折活动的广告牌，影响了其它门店正常通行，后经举报才发现。
1.  某个数码店为了绕开商场每天最高用电限制，私自装电表，改变电力接入方式，搞一些小动作。
1.  物业管理处下发了最新的用水标准，但是很多餐饮店还是沿用旧标准，对此物业管理处并不知情。
1.  物业对具体门店 WiFi 使用情况缺乏了解，无法评估升级新的网络设备后对各个门店的具体影响。

  


`经营规则只能告诉门店应该做什么，但并不代表他们真的会按规则去做事`，一些门店甚至还会搞一些“小动作”。作为基础保障部门，缺乏对各个门店真实经营情况的了解，导致管理方案很难落地。

  


如何解决这些问题呢？身为管理者，需要`定时去收集、分析`各个经营门店对于基础设施的使用情况，及时`检查`它们对于经营规则的落地情况，这样才能更好地`了解并管控`经营门店，让整个商场有序经营，更好地服务消费者。

  


## 背景：复杂的现代前端架构

  


现代前端开发也会遇到类似的问题，以某电商 B 端 Web 应用架构为例，它由 `30+` 前端团队共计 `100+` 前端开发人员共同开发维护，是一个包含 `200+` 个代码仓库的微前端巨型应用（<mark>大型商场</mark>）。其中有负责 **基础项目**（主应用、基础框架、组件库、工具库）的基础架构团队（<mark>物业等基础保障团队</mark>），也有负责订单、广告、数据、商品、物流等具体子应用的业务开发团队（<mark>具体经营门店</mark>），上层依赖下层，双方通过 API 文档（<mark>经营规则</mark>）维系协同开发模式。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/061b2f1cd47143beb8f7cbfe9b4e37ff~tplv-k3u1fbpfcp-zoom-1.image)

  


## 问题：海量仓库的依赖治理难题

  


与商场管理者一样，作为前端架构师，面对 `200` 多个代码仓库的业务迭代（<mark>经营门店日常商业活动</mark>），也会存在很多治理难题，比如：

  


`问题一`：基础架构团队新出的 2.0 版本 UI 库在业务团队中推广时进度缓慢，不清楚业务团队对于 1.0 版本组件真实的调用情况，因此很难评估升级影响，只能同时兼容两个版本（<mark>物业无法评估升级新设备后对门店的影响</mark>） 。

`问题二`：基础架构团队不敢轻易修改，下线已有 API，因为不清楚哪些项目对它有依赖会受到影响，开发新 feature 时必须向后兼容，导致框架越发臃肿（<mark>物业缺乏经营门店对于基础设施使用情况的了解</mark>）。

`问题三`：A、B 应用项目直接使用 document.cookie 去设置 cookie，而非基础框架提供的带隔离 namespace 特性的 cookie API，导致 cookie 相互污染（<mark>服装店占用公共通道，影响其它门店</mark>）。

`问题四`：C 应用团队代码一直未更新必须升级的框架基础 API，发布 live 后因特定条件执行报错才被发现（<mark>餐饮店一直未落实新的用水标准</mark>）。

`问题五`：D 应用团队私自重写了基础项目的某个 API，基础架构团队对此并不知晓，通过线上报错才得以发现（<mark>数码店私改用电方式</mark>）。

  


## 原因：API 文档无法表述真实的依赖关系

  


API 文档只能告诉业务开发团队（`依赖调用方`）如何调用基础项目（`依赖提供方`）提供的 API，但并不能表述项目间真实的依赖关系。因为它无法告诉我们基础项目导出的 API 到底用在了哪些项目中，也无法告诉我们子应用项目是如何使用这些 API 的，所以无法避免`脏调用`和`骚操作`。
（`脏调用`不是指代码语法有问题，而是指依赖调用方代码中存在有问题的 API 调用，比如使用已下线 API，而`骚操作`是指代码中存在私自 Hack 基础 API 等行为）

  


基础项目（`依赖提供方`）对全部子应用代码中真实的 API 调用缺乏全局层面的了解，所以在升级重构时只能被动向后兼容，这让基础项目越来越臃肿，难以维护，已经到了必须治理的程度。

  


我们需要一套能够帮助我们`了解并管控`真实依赖关系的解决方案。

  


## 解决方案：前端代码分析工具

  


本课程学习的重点并不是探讨微前端如何解决某些具体问题，而是想设计一种 **工程化工具** 来帮助开发者了解并管控大型项目中的依赖关系，主动发现、检测、预防因依赖治理而产生的问题。

  


要想了解真实的依赖关系，最有效的做法是对全部子应用进行代码静态分析，对项目代码中的 API 调用进行定位 & 检测 & 统计，生成代码分析报告。


代码静态分析是指在不实际执行程序的情况下，对代码语义和行为进行分析。大家熟知的 ESLint，就是一款通过代码静态分析帮助开发者定位语法错误的工具，而我们要设计的代码分析工具则是通过分析 API 真实的调用情况来帮助开发者了解并管控依赖关系。

  


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bff8f545a69e4f1f81e95a0d84a18cd8~tplv-k3u1fbpfcp-zoom-1.image)

  


**分析工具的实现原理：**

  


通过扫描业务团队单个或全部项目，找出所有需要分析的代码文件（TS、Vue、JS），并依次将其解析为 AST ，然后遍历各级 AST 节点，按照分析指标对 API 调用进行定位/统计/标记等处理，等分析完所有文件后，整理输出分析结果。分析工具会以 npm 包形式管理，支持多种接入方式，可以快速集成到其它工具或服务中。

  


## 应用场景

  


### 1.“脏调用”拦截 & 评分告警

  


配合 git hook、gitlab CI 等工具，在业务开发团队 Work Flow 各个关键阶段触发代码分析任务，拦截包含“脏调用”的代码，防止其执行提交/合入操作，帮助开发者提前发现代码风险。

通过 gitlab CI 定时触发分析任务，对 API 调用进行评分，推送告警消息 or 分析报告给相关同学，推动业务团队主动修复缺陷。

  


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0b0f20cbff43ff81e956db1aceeaa7~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73bf00494fb14727b4b385a09d50682e~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c936c35589fc4d60b3d54549f87c4702~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2655c0fd0a664b52958ee01f61866a96~tplv-k3u1fbpfcp-zoom-1.image)

  


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7080e83885004c4caf26f7cd9c91d7e0~tplv-k3u1fbpfcp-zoom-1.image)

[单应用代码分析报告demo](https://liangxin199045.github.io/code-demo/)

  


### 2.全应用代码分析报告

  


全应用代码分析报告反映了基础项目 API 在全部业务项目中真实的调用情况，可以帮助基础架构团队优化 API 导出，减少冗余，评估 API 上/下线影响，把控重构进度等

  


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23df8bdccf87490dba549dc3df96f473~tplv-k3u1fbpfcp-zoom-1.image)

[全应用代码分析报告demo](https://liangxin199045.github.io/all-projects-analysis/)

  


例如通过上图所示代码分析报告，我们可以了解到 ：

1.  `app.localStorage.set` 这个黑名单 API 方法共有 6 处调用，其中一处调用位于 <mark>ProjectA</mark> 项目 src/pages/ 目录下 BasicSettings.vue 文件中的 [125](https://github.com/liangxin199045/project-app1/blob/main/src/pages/BasicSettings.vue#L125) 行。
2.  <mark>ProjectA</mark>，<mark>ProjectB</mark>，<mark>ProjectC</mark> 三个应用都引入了 `APIPromise` 这个类型 API，它属于高频调用 API。
3.  <mark>ProjectA</mark>，<mark>ProjectB</mark> 两个应用都引入了 `APPRequest` 这个 API，并且都通过 as 别名以 request 来使用。
4.  <mark>ProjectD</mark> 应用 在 src/services/ 目录下 connect.ts 文件中 的 [38](https://github.com/liangxin199045/project-app4/blob/main/src/services/connect.ts#L38) 行引入了 `FB.login` 这个黑名单方法 API。
5.  所有项目都没有引入基础框架提供的 `app.getThirdInfo API` ，可以评估一下它是否为 “鸡肋” API。


### 3.全应用代码分析平台

  


搭建代码分析平台，后端服务集成代码分析工具的分析能力，然后将代码分析结果定期整理，支持按各种检索条件查看项目的分析结果，支持查看选定时间段内某些 API 的调用趋势变化，生成趋势变化折线图，帮助基础架构团队跟踪具体 API 在业务项目中的调用趋势变化，把控重构进度。

  


查看 Project A 项目中 `app.localStorage.get` 这个 API 真实的调用及分布情况：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21ff5df868e4453f868fe5109260eba0~tplv-k3u1fbpfcp-zoom-1.image)

  


查看各个子应用项目的代码评分及分析详情：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7ff194d03143ec9a32e1d0d2e2a6eb~tplv-k3u1fbpfcp-zoom-1.image)

  


查看 `app.localStorage.set` 这个 API 在全应用中的调用趋势变化：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15c72f3576d44422a5047ccb21f15982~tplv-k3u1fbpfcp-zoom-1.image)

  


通过上图我们可以了解到 ：

  


基础项目准备下线 `app.localStorage.set` 这个黑名单 API ，各个业务团队接到通知后在 `2022.1-2022.6` 这半年来，已陆续在代码中去掉依赖此 API 的相关逻辑，因此该 API 在全部项目中的实际调用量从最初的 `131` 降到了 `5` ，剩余的这 `5` 处调用集中在 <mark>Project D</mark> 项目的 `3` 个 TS 文件中，预计 `7` 月底也可以完成改造，基础架构团队可以选择在 `8` 月份下线该 API，不会对业务造成影响。

## 作者介绍

iceman要早睡，前端技术专家，目前就职于某跨境电商公司，负责基础平台微前端架构设计，工程化体系建设等工作，前腾讯高级工程师，负责过手机QQ，腾讯文档，QQ小程序平台，腾讯云TRTC等项目开发工作，乐于分享，多项技术专利第一撰写人，擅长领域：前端工程化，音视频开发，3D渲染等。  


## 课程是如何设计的

课程共分为三个阶段：


### 基础知识阶段

`《一次搞懂 AST 抽象语法树》`：掌握 AST 相关基础知识，AST 可视化工具，为开发代码分析工具奠定基础。

`《从分析一段 TS 代码开始》`：学习通过程序脚本的方式分析 TS 代码，建立正向反馈，迈出代码分析的第一步。

  


### 具体实现阶段

`《架构设计 & 分析范式》`：学习设计分析工具的核心基础类，掌握依赖调用分析的通用方法论和分析范式。

`《扫描 & 解析 TS 文件》`：根据扫描源配置扫描文件目录下的 TS 文件，学习 TypeScript 编译原理。

`《分析 Import 节点》`：观察 Import 节点多种导入方式的 AST 特征，掌握分析 Import 节点的函数实现。

`《判定 API 调用》`：学会判定 API 调用，并排除干扰节点，掌握如何关联语义上下文，实现判定函数。

`《API 用途分析》`：学习自下而上分析模式，甄别各种用途场景 AST 特征，排除干扰场景，实现具体分析函数。

`《分析插件方案设计》`：设计插件模式、插件函数、插件管理等，实现主程序与插件程序的逻辑解耦。

`《Browser API 调用分析》`：掌握 Browser API 与 Import API 的区别，了解其判定原理，实现分析插件函数编写。

`《提取 Vue 文件中 TS 代码》`：学习 Vue 相关编译器，掌握提取 Vue 中 TS 片段的技术方案，实现相关函数。

`《整理分析数据》`：学习处理 Map 数据结构，设计评分插件，实现 API 标记处理等。

`《入口设计 & 发布 NPM 包》`：理解 CLI / API 两种模式的区别，完成入参校验逻辑，掌握如何调试，发布 NPM 包。

`《开发自定义分析插件》`：学习自定义分析插件开发流程，掌握如何开发分析插件，并向社区贡献插件代码。

### 应用场景阶段

`《“脏调用”拦截 & CI自动化分析》`：配合 git hook、gitlab CI，学习如何实现“脏调用”拦截，CI 自动化分析。

`《微前端业务全应用代码分析》`：学习全应用代码分析的实现方案，搭建代码分析平台，跟踪 API 调用趋势变化。

  


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2781df10df045a38898d160278e3760~tplv-k3u1fbpfcp-zoom-1.image)

  


最后我想说，想要解决大型 Web 应用依赖治理难题，代码分析是非常重要的，很多同学已经意识到了这一点，但对于代码静态分析领域的知识储备却比较少，很难独立开发针对特定分析目的的代码分析工具。

  


这本小册就是针对这一痛点，从依赖治理这个角度出发，由浅入深地讲解代码静态分析需要掌握的基础知识、通用能力，帮助开发者一步一步实现代码分析工具，同时帮助大家建立解决此类问题的通用方法论。

  


期待与你同行，让我们一起开启这段学习之旅吧！