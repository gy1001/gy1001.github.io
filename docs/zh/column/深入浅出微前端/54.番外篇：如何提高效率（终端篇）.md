前端开发会频繁的在终端中使用 Shell 命令，本课程主要分享一些常用的终端和 Shell 配置。

## 默认终端

Mac 系统默认的 Terminal 界面自定义设置功能较弱，无法进行分屏和会话管理，如下所示：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9de39d148eb411fa76c0f8169c51070~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1394&h=964&s=327250&e=png&a=1&b=fefdfd)
我们希望能够拥有一款强大的终端应用程序，可以在字体、背景和窗口上支持更多的定制选项，为此我们可以选择使用其它终端应用程序来代替 Mac 系统的 Terminal。

## iTerm2

[iTerm2](https://iterm2.com/index.html) 是一款免费的终端应用程序，它不仅支持分屏，而且支持丰富的自定义设置（背景、字体、主题色和窗口透明度等），以下是本课程的配置效果：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f769d77bb4d94ad3a8134eb2ee33e049~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560&h=1950&s=1026839&e=png&a=1&b=223338)
> 温馨提示：Mac 上的终端应用程序很多，包括 [Hyper](https://hyper.is/)、[Wrap](https://www.warp.dev/)、[Alacritty](https://github.com/alacritty/alacritty)、[Tabby](https://tabby.sh/)、[Rio](https://raphamorim.io/rio/) 等，如果不喜欢复杂的配置，那么可以从这些各具特色的终端应用程序中选择一款。

### iTerm2 Profiles

首次下载安装后的 iTerm2 如下所示，看起来几乎和 Mac 系统默认的 Terminal 没有差异：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e04ac0269d74843a3175175901253e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1394&h=1140&s=203073&e=png&a=1&b=000000)
我们可以通过 Profile 来进行自定义配置窗体的透明度、字体、主题颜色以及背景图等，让窗体变得更加舒适。首先我们可以通过 Profiles / Window 来设置窗体的透明度，其次我们可以通过 Profiles / Text 来调整字体大小，从而快速达到我们对于终端的基础体验诉求：
                                                                                                                                   
![屏幕录制2023-11-15 21.00.29.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7dc424abccb495c9c9e03486e4909a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2334&h=1272&s=1766142&e=gif&f=82&b=de4b0c)

也可以通过 Profiles / Window 设置窗体的背景图：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a84be397714314ac65edb0d8328053~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=973&h=279&s=175434&e=png&b=efe7e2)

除此之外，在 Profile 中我们可以通过 Colors 来配置 Iterm2 终端的主题色，但是手动配置效率较低：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf551b6e4a4488da525a05bc69591b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2080&h=1188&s=535437&e=png&a=1&b=f2eeec)
我们知道在 VS Code 中可以通过安装主题插件来一键配置主题，在 iTerm2 中我们也可以使用社区提供的主题配色方案 [iTerm2-Color-Schemes](https://github.com/mbadolato/iTerm2-Color-Schemes)，进入 [Iterm2-color-schemes 官网](https://iterm2colorschemes.com/) 下载主题包：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4ddfac18640465784df11b3c1091dfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1888&h=1716&s=877144&e=png&b=f3f2f2)

> 温馨提示：也可以通过 git 克隆仓库进行下载。

通过文档中说明的步骤进行主题包导入，解压下载的文件后找到 `schemes` 目录，进入后会发现各种主题的文件（所有主题文件都是 `.itermcolors` 后缀），这里可以全选导入也可以根据自己的喜好选择相应的主题进行导入：

![屏幕录制2023-11-16 20.36.47.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f583b07574974a92be63c7e8a9dd9010~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2334&h=1402&s=1078283&e=gif&f=59&b=f3edeb)

导入成功后可以进行主题选择和设置：

![屏幕录制2023-11-16 20.48.55.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90c8042c57e4f86a7fe0c0d2927c0ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2328&h=1062&s=656744&e=gif&f=23&b=ece3de)

### iTerm2 Window Arrangement

对于 Iterm2 而言，最核心的功能就是窗口分屏。由于窗口分屏需要更大的窗口空间，我们可以先通过 Profile / Window 设置默认打开的窗口大小：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3264fdab28d14c7fbc0db0b31b8663c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=579&s=146155&e=png&b=f4eeec)

接下来我们可以使用快捷键对终端进行水平（⇧⌘D）和垂直（⌘D）切分，从而可以更高效的进行多任务操作，如下所示：

![录屏2023-11-19 10.24.30.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b6a9548ba664a33b6be430d71abb840~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1516&h=1344&s=477592&e=gif&f=32&b=4c3529)

当然，如果我们希望打开的时候默认已经进行水平和垂直切分，从而可以更高效的进行多任务操作，那么可以对 iTerm2 进行 Window Arrangement 设置：

- 首先将当前切分好的窗口保存为新的 Arrangement，在菜单栏中选择 "Window" -> "Save Window Arrangement"（⇧⌘S）
- 在 General / Startup 中设置窗口启动时使用默认的 Arrangement（可以在 Arrangements 中新建多个，并设置默认的 Arrangement）
- 新开窗口打开默认的 Arrangement 需要使用 ⇧⌘R(Restore) 快捷键

![录屏2023-11-19 10.36.04.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71913d3668a449bb93103254622b1c69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2268&h=1474&s=3297639&e=gif&f=143&b=f78f28)

## zsh（Z Shell）

大家都知道 Shell 是命令行解释器，提供了用户和操作系统的交互界面。用户在 Shell 中输入命令，Shell 会解释这些命令并将它们传递给操作系统执行。实现 Shell 的工具有很多，我们可以在 Mac 中输入以下命令查看 Mac 系统支持哪些 Shell 实现，刚兴趣的同学可以了解一下这些 Shell 工具的特点：

``` bash
# 执行
cat /etc/shells

# 打印
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/dash
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
```

> 温馨提示：为什么 Mac 系统上会有这么多的 Shell 实现呢？早期的计算机没有图形界面，采用命令行来控制计算机，因此 Shell 是高度封装操作系统 API 的命令行工具，本质上和图形化应用程序调用系统 API 实现的功能是一样的，都是为了让用户可以操作系统运行。因此，可以将不同的 Shell 实现看做不同的应用程序。


Mac 使用 zsh 或 bash 作为默认的 Shell，[从 macOS Catalina 开始 Mac 使用 zsh 作为默认登录 Shell 和交互式 Shell](https://support.apple.com/zh-cn/HT208050)，可以通过以下命令查看当前系统使用的 Shell：

``` bash
# 执行
echo $SHELL
# 打印
/bin/zsh
```

[zsh (Z shell)](https://zsh.sourceforge.io/) 将 bash、ksh 以及 tcsh 等 Shell 工具的优势集成一体，提供了许多选项和插件，允许用户定制自己的 Shell 环境配置。zsh 还实现了 [POSIX Shell](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html) 标准，可以很好的兼容其它实现了 POSIX Shell 标准的 Shell 工具，例如 bash。除此之外，zsh 提供了强大的命令行编辑功能，例如拼写检查、智能提示、自定义提示符和自动补全等。

尽管 iTerm2 能在终端的窗体和字体上进行一些配置，但是无法提供更深层次的 Shell 配置，因此我们可以对 zsh 进行额外的配置，从而提升开发者对于 Shell 命令行的使用效率。

> 温馨提示：如果你不喜欢做一些复杂的配置，可以了解一下 [Fish Shell](https://fishshell.com/)，它对新手非常友好，语法简单且易于理解，具备强大的补全功能，并且拥有美观的界面，默认提供了输入和输出的信息高亮。需要注意的是，它不完全兼容 POSIX Shell 标准。


### Oh My Zsh 配置框架

zsh 功能强大的同时也提供了相对复杂的配置，这对于新手而言并不是特别友好。为此，社区出现了一个管理 zsh 配置的开源框架 [Oh My Zsh](https://github.com/ohmyzsh/ohmyzsh)，它提供了一套易于使用的配置以及大量的插件和主题，可以帮助新手更加友好的使用和定制 zsh。首先，我们可以根据官方的文档[进行安装](https://github.com/ohmyzsh/ohmyzsh#basic-installation)：

``` bash
# sh -c "echo Hello"，其中 -c 后面的字符串被视为要执行的 Shell 命令

# $(curl -fsSL https://xxx.sh) 是一个命令替换
# 它会先执行括号中的 curl 命令下载指定 URL 的 Shell 脚本内容，然后将下载的内容替换到原位置

# curl -fsSL https://xxx.sh 用来下载指定 URL 的内容
# -fsSL 参数是 curl 命令的选项
# -f(fail) 代表失败时不输出 HTTP 错误
# -s(silent) 代表静默模式
# -S(show-error) 代表在需要时显示错误
# -L(location) 代表如果服务器报告该页面已经移动到其他位置，则重新定向到新的位置

# 使用 curl 下载 install.sh，下载完成后使用 sh 执行下载的内容
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

执行成功的打印信息如下所示：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff9c194c8d4745769d43a832dc8633cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2434&h=1938&s=1380554&e=png&a=1&b=1f2f35)
> 温馨提示：安装过程中可能会遇到 xcode-select 出问题，可以重新安装官方的 [Command Line Tools for Xcode](https://developer.apple.com/download/all/?q=XCode) （需要登录 Apple ID） 或者安装 [Homebrew](https://brew.sh/) 包管理器（会间接安装 Command Line Tools）。

我们再来回顾一下安装之前的 iTerm2 界面：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39657527bbd94a5da13105d354047170~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2182&h=682&s=1528399&e=png&b=2f3535)

Oh My Zsh 安装成功后的 iTerm2 界面：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0bf67d93cbe44388fd0f1292096fcc5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2178&h=688&s=1499849&e=png&b=2f3435)

可以发现安装 Oh My Zsh 之后命令提示符变得更加简洁，不会占据大量的窗口位置，打印的信息也能够做到简单的高亮区分。


### Oh My Zsh 配置文件

在安装 Oh My Zsh 的过程中，我们可以重点关注一下几个打印信息，如下所示：

``` bash
# 寻找已经存在的 zsh 配置文件
Looking for an existing zsh config...
# 使用 Oh My Zsh 的模板文件进行 $HOME/.zshrc 的配置
Using the Oh My Zsh template file and adding it to /Users/zhuxiankang/.zshrc.
# 提示检查 .zshrc 配置文件进行插件、主题和其它选项配置
Before you scream Oh My Zsh! look over the `.zshrc` file to select plugins, themes, and options.
```

可以配合安装 Oh My Zsh 时执行的 [install.sh](https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh) 查看打印逻辑：

- `setup_ohmyzsh()`：克隆 Oh My Zsh 仓库的 master 分支到 $HOME/.oh-my-zsh 中
- `setup_zshrc()`：恢复或者生成 $HOME/.zshrc 配置文件
- `setup_shell()`：更改默认的登录 Shell 为 zsh 


``` sh
setup_ohmyzsh() {
  # Prevent the cloned repository from having insecure permissions. Failing to do
  # so causes compinit() calls to fail with "command not found: compdef" errors
  # for users with insecure umasks (e.g., "002", allowing group writability). Note
  # that this will be ignored under Cygwin by default, as Windows ACLs take
  # precedence over umasks except for filesystems mounted with option "noacl".
  umask g-w,o-w
  # 使用蓝色打印 Cloning Oh My Zsh...，结合安装 Oh My Zsh 的打印信息查看
  echo "${FMT_BLUE}Cloning Oh My Zsh...${FMT_RESET}"

  command_exists git || {
    fmt_error "git is not installed"
    exit 1
  }

  ostype=$(uname)
  if [ -z "${ostype%CYGWIN*}" ] && git --version | grep -Eq 'msysgit|windows'; then
    fmt_error "Windows/MSYS Git is not supported on Cygwin"
    fmt_error "Make sure the Cygwin git package is installed and is first on the $PATH"
    exit 1
  fi

  # Manual clone with git config options to support git < v1.7.2
  # 可以从完整的 install.sh 中查看 $ZSH 的值，一般情况下在 $HOME/.oh-my-zsh 中
  # $HOME 是系统的根目录，可以使用 echo $HOME 打印路径信息
  # 这里的 $REMOTE = https://github.com/ohmyzsh/ohmyzsh
  # $BRANCH = master
  
  # setup_ohmyzsh 的主要作用是将 oh-my-zsh 仓库的 master 分支克隆到 $HOME/.oh-my-zsh 中
  git init --quiet "$ZSH" && cd "$ZSH" \
  && git config core.eol lf \
  && git config core.autocrlf false \
  && git config fsck.zeroPaddedFilemode ignore \
  && git config fetch.fsck.zeroPaddedFilemode ignore \
  && git config receive.fsck.zeroPaddedFilemode ignore \
  && git config oh-my-zsh.remote origin \
  && git config oh-my-zsh.branch "$BRANCH" \
  && git remote add origin "$REMOTE" \
  && git fetch --depth=1 origin \
  && git checkout -b "$BRANCH" "origin/$BRANCH" || {
    [ ! -d "$ZSH" ] || {
      cd -
      rm -rf "$ZSH" 2>/dev/null
    }
    fmt_error "git clone of oh-my-zsh repo failed"
    exit 1
  }
  # Exit installation directory
  cd -

  echo
}

setup_zshrc() {
  # Keep most recent old .zshrc at .zshrc.pre-oh-my-zsh, and older ones
  # with datestamp of installation that moved them aside, so we never actually
  # destroy a user's original zshrc
  echo "${FMT_BLUE}Looking for an existing zsh config...${FMT_RESET}"
   
  # 检查是否存在旧的 .zshrc 文件。如果存在，并且用户选择保留，则跳过后续步骤
  # 如果存在 .zshrc.pre-oh-my-zsh 文件（即之前备份的 .zshrc 文件），则将其重命名并添加时间戳，以避免覆盖
  # 将现有的 .zshrc 文件备份为 .zshrc.pre-oh-my-zsh
  # Must use this exact name so uninstall.sh can find it
  OLD_ZSHRC="$zdot/.zshrc.pre-oh-my-zsh"
  if [ -f "$zdot/.zshrc" ] || [ -h "$zdot/.zshrc" ]; then
    # Skip this if the user doesn't want to replace an existing .zshrc
    if [ "$KEEP_ZSHRC" = yes ]; then
      echo "${FMT_YELLOW}Found ${zdot}/.zshrc.${FMT_RESET} ${FMT_GREEN}Keeping...${FMT_RESET}"
      return
    fi
    if [ -e "$OLD_ZSHRC" ]; then
      OLD_OLD_ZSHRC="${OLD_ZSHRC}-$(date +%Y-%m-%d_%H-%M-%S)"
      if [ -e "$OLD_OLD_ZSHRC" ]; then
        fmt_error "$OLD_OLD_ZSHRC exists. Can't back up ${OLD_ZSHRC}"
        fmt_error "re-run the installer again in a couple of seconds"
        exit 1
      fi
      mv "$OLD_ZSHRC" "${OLD_OLD_ZSHRC}"

      echo "${FMT_YELLOW}Found old .zshrc.pre-oh-my-zsh." \
        "${FMT_GREEN}Backing up to ${OLD_OLD_ZSHRC}${FMT_RESET}"
    fi
    echo "${FMT_YELLOW}Found ${zdot}/.zshrc.${FMT_RESET} ${FMT_GREEN}Backing up to ${OLD_ZSHRC}${FMT_RESET}"
    mv "$zdot/.zshrc" "$OLD_ZSHRC"
  fi
  
  # 如果不存在旧的 .zshrc 配置文件，则使用 Oh My Zsh 的模板配置
  echo "${FMT_GREEN}Using the Oh My Zsh template file and adding it to $zdot/.zshrc.${FMT_RESET}"

  # Modify $ZSH variable in .zshrc directory to use the literal $ZDOTDIR or $HOME
  omz="$ZSH"
  if [ -n "$ZDOTDIR" ] && [ "$ZDOTDIR" != "$HOME" ]; then
    omz=$(echo "$omz" | sed "s|^$ZDOTDIR/|$ZDOTDIR/|")
  fi
  omz=$(echo "$omz" | sed "s|^$HOME/|$HOME/|")

  # 使用 sed 工具修改了 zshrc.zsh-template 文件（文件路径在 $HOME/.oh-my-zsh/templates/zshrc.zsh-template）
  # 查找以 export ZSH= 开始的行，并将这些行的内容替换为 export ZSH="${omz}"
  # 并将 sed 命令的输出重定向到一个临时文件 .zshrc-omztem
  # 将临时文件 .zshrc-omztemp 重命名为 .zshrc，强制覆盖原来的 .zshrc 文件
  sed "s|^export ZSH=.*$|export ZSH="${omz}"|" "$ZSH/templates/zshrc.zsh-template" > "$zdot/.zshrc-omztemp"
  mv -f "$zdot/.zshrc-omztemp" "$zdot/.zshrc"

  echo
}

# 如果默认使用的登录 Shell 不是 zsh，则更改默认的 Shell 为 zsh
setup_shell() {
  # Skip setup if the user wants or stdin is closed (not running interactively).
  if [ "$CHSH" = no ]; then
    return
  fi

  # If this user's login shell is already "zsh", do not attempt to switch.
  if [ "$(basename -- "$SHELL")" = "zsh" ]; then
    return
  fi

  # If this platform doesn't provide a "chsh" command, bail out.
  if ! command_exists chsh; then
    cat <<EOF
I can't change your shell automatically because this system does not have chsh.
${FMT_BLUE}Please manually change your default shell to zsh${FMT_RESET}
EOF
    return
  fi

  echo "${FMT_BLUE}Time to change your default shell to zsh:${FMT_RESET}"

  # Prompt for user choice on changing the default login shell
  printf '%sDo you want to change your default shell to zsh? [Y/n]%s ' \
    "$FMT_YELLOW" "$FMT_RESET"
  read -r opt
  case $opt in
    y*|Y*|"") ;;
    n*|N*) echo "Shell change skipped."; return ;;
    *) echo "Invalid choice. Shell change skipped."; return ;;
  esac

  # Check if we're running on Termux
  case "$PREFIX" in
    *com.termux*) termux=true; zsh=zsh ;;
    *) termux=false ;;
  esac

  if [ "$termux" != true ]; then
    # Test for the right location of the "shells" file
    if [ -f /etc/shells ]; then
      shells_file=/etc/shells
    elif [ -f /usr/share/defaults/etc/shells ]; then # Solus OS
      shells_file=/usr/share/defaults/etc/shells
    else
      fmt_error "could not find /etc/shells file. Change your default shell manually."
      return
    fi

    # Get the path to the right zsh binary
    # 1. Use the most preceding one based on $PATH, then check that it's in the shells file
    # 2. If that fails, get a zsh path from the shells file, then check it actually exists
    if ! zsh=$(command -v zsh) || ! grep -qx "$zsh" "$shells_file"; then
      if ! zsh=$(grep '^/.*/zsh$' "$shells_file" | tail -n 1) || [ ! -f "$zsh" ]; then
        fmt_error "no zsh binary found or not present in '$shells_file'"
        fmt_error "change your default shell manually."
        return
      fi
    fi
  fi

  # We're going to change the default shell, so back up the current one
  if [ -n "$SHELL" ]; then
    echo "$SHELL" > "$zdot/.shell.pre-oh-my-zsh"
  else
    grep "^$USER:" /etc/passwd | awk -F: '{print $7}' > "$zdot/.shell.pre-oh-my-zsh"
  fi

  echo "Changing your shell to $zsh..."

  # Check if user has sudo privileges to run `chsh` with or without `sudo`
  #
  # This allows the call to succeed without password on systems where the
  # user does not have a password but does have sudo privileges, like in
  # Google Cloud Shell.
  #
  # On systems that don't have a user with passwordless sudo, the user will
  # be prompted for the password either way, so this shouldn't cause any issues.
  #
  if user_can_sudo; then
    sudo -k chsh -s "$zsh" "$USER"  # -k forces the password prompt
  else
    chsh -s "$zsh" "$USER"          # run chsh normally
  fi

  # Check if the shell change was successful
  if [ $? -ne 0 ]; then
    fmt_error "chsh command unsuccessful. Change your default shell manually."
  else
    export SHELL="$zsh"
    echo "${FMT_GREEN}Shell successfully changed to '$zsh'.${FMT_RESET}"
  fi

  echo
}
```

了解了 Oh My Zsh 安装的过程之后，我们可以重点来看下 `.zshrc` 配置文件：

``` bash
cd ~

# 如果 VS Code 配置了 code 命令
# 可以使用 code ~/.zshrc 命令在 VS Code 中打开配置文件进行高亮修改

# 使用默认的文本编辑器打开配置文件
open .zshrc
```

> 温馨提示：配置 VS Code 的 `code` 命令可以在终端中使用 VS Code 打开任何目录的文件，例如使用 `code ~/.zshrc` 命令，可以使我们对配置文件进行编辑器的高亮展示。为了生成 Shell 环境的 `code` 命令，首先需要在 VS Code 中使用 **⇧⌘P** 打开命令面板，输入 `code` 进行搜索，找到选项 **"Shell 命令：在 PATH 中安装 'code' 命令"**，点击进行安装即可。

打开以后的配置文件如下所示：

``` bash
# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"
```

在安装的过程中提供了 `~/.oh-my-zsh/templates/zshrc.zsh-template` 配置模板文件，该文件和最终生成的 `.zshrc` 文件一致。因此如果 Mac 电脑默认使用 zsh 作为登录 Shell，而 Oh My Zsh 默认的安装命令执行失败，那么可以通过如下命令手动安装：

``` bash
# 类似于手动执行 setup_ohmyzsh()
git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh
# 将末班文件拷贝后 ~/.zshrc 中生成 .zshrc 配置文件
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
# 查看默认的登录 Shell 是不是 zsh
echo $SHELL
# 如果默认的登录 Shell 不是 zsh，则修改默认的登录 Shell
chsh -s /bin/zsh
```

### Oh My Zsh 插件配置

在 `.zshrc` 配置文件中可以看到插件的配置参数，默认加入了 git 插件：

``` bash
# ZSH 变量指代 $HOME/.oh-my-zsh 路径
# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"
# Which plugins would you like to load?
# 在 $HOME/.oh-my-zsh/plugins 中 Oh My Zsh 提供了一些默认的插件
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# 插件的配置示例：plugins=(rails git textmate ruby lighthouse)
# Example format: plugins=(rails git textmate ruby lighthouse)
# 添加的插件数量过多会导致 Shell 启动速度变慢
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)
```

根据注释可以发现 Oh My Zsh 默认提供的插件在 `$HOME/.oh-my-zsh/plugins` 中，进入查看可以发现 Oh My Zsh 默认提供了很多可使用的插件：
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd02541ec88e47fcbe252f691529d009~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2434&h=1928&s=1407007&e=png&a=1&b=203036)
#### git 插件
我们进入 Oh My Zsh 默认配置的 git 插件查看一下插件的内容信息：
``` bash
# Git version checking
autoload -Uz is-at-least
git_version="${${(As: :)$(git version 2>/dev/null)}[3]}"

#
# Functions Current
# (sorted alphabetically by function name)
# (order should follow README)
#

# The name of the current branch
# Back-compatibility wrapper for when this function was defined here in
# the plugin, before being pulled in to core lib/git.zsh as git_current_branch()
# to fix the core -> git plugin dependency.
function current_branch() {
  git_current_branch
}

# Check for develop and similarly named branches
function git_develop_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  local branch
  for branch in dev devel develop development; do
    if command git show-ref -q --verify refs/heads/$branch; then
      echo $branch
      return 0
    fi
  done

  echo develop
  return 1
}

# Check if main exists and use instead of master
function git_main_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  local ref
  for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk,mainline,default,master}; do
    if command git show-ref -q --verify $ref; then
      echo ${ref:t}
      return 0
    fi
  done

  # If no main branch was found, fall back to master but return error
  echo master
  return 1
}

function grename() {
  if [[ -z "$1" || -z "$2" ]]; then
    echo "Usage: $0 old_branch new_branch"
    return 1
  fi

  # Rename branch locally
  git branch -m "$1" "$2"
  # Rename branch in origin remote
  if git push origin :"$1"; then
    git push --set-upstream origin "$2"
  fi
}

#
# Functions Work in Progress (WIP)
# (sorted alphabetically by function name)
# (order should follow README)
#

# Similar to `gunwip` but recursive "Unwips" all recent `--wip--` commits not just the last one
function gunwipall() {
  local _commit=$(git log --grep='--wip--' --invert-grep --max-count=1 --format=format:%H)

  # Check if a commit without "--wip--" was found and it's not the same as HEAD
  if [[ "$_commit" != "$(git rev-parse HEAD)" ]]; then
    git reset $_commit || return 1
  fi
}

# Warn if the current branch is a WIP
function work_in_progress() {
  command git -c log.showSignature=false log -n 1 2>/dev/null | grep -q -- "--wip--" && echo "WIP!!"
}

#
# Aliases
# (sorted alphabetically by command)
# (order should follow README)
# (in some cases force the alisas order to match README, like for example gke and gk)
#

alias grt='cd "$(git rev-parse --show-toplevel || echo .)"'

function ggpnp() {
  if [[ "$#" == 0 ]]; then
    ggl && ggp
  else
    ggl "${*}" && ggp "${*}"
  fi
}
compdef _git ggpnp=git-checkout

alias ggpur='ggu'
alias g='git'
alias ga='git add'
alias gaa='git add --all'
alias gapa='git add --patch'
alias gau='git add --update'
alias gav='git add --verbose'
alias gwip='git add -A; git rm $(git ls-files --deleted) 2> /dev/null; git commit --no-verify --no-gpg-sign --message "--wip-- [skip ci]"'
alias gam='git am'
alias gama='git am --abort'
alias gamc='git am --continue'
alias gamscp='git am --show-current-patch'
alias gams='git am --skip'
alias gap='git apply'
alias gapt='git apply --3way'
alias gbs='git bisect'
alias gbsb='git bisect bad'
alias gbsg='git bisect good'
alias gbsn='git bisect new'
alias gbso='git bisect old'
alias gbsr='git bisect reset'
alias gbss='git bisect start'
alias gbl='git blame -w'
alias gb='git branch'
alias gba='git branch --all'
alias gbd='git branch --delete'
alias gbD='git branch --delete --force'

function gbda() {
  git branch --no-color --merged | command grep -vE "^([+*]|\s*($(git_main_branch)|$(git_develop_branch))\s*$)" | command xargs git branch --delete 2>/dev/null
}

# Copied and modified from James Roeder (jmaroeder) under MIT License
# https://github.com/jmaroeder/plugin-git/blob/216723ef4f9e8dde399661c39c80bdf73f4076c4/functions/gbda.fish
function gbds() {
  local default_branch=$(git_main_branch)
  (( ! $? )) || default_branch=$(git_develop_branch)

  git for-each-ref refs/heads/ "--format=%(refname:short)" | \
    while read branch; do
      local merge_base=$(git merge-base $default_branch $branch)
      if [[ $(git cherry $default_branch $(git commit-tree $(git rev-parse $branch\^{tree}) -p $merge_base -m _)) = -* ]]; then
        git branch -D $branch
      fi
    done
}

alias gbgd='LANG=C git branch --no-color -vv | grep ": gone\]" | awk '"'"'{print $1}'"'"' | xargs git branch -d'
alias gbgD='LANG=C git branch --no-color -vv | grep ": gone\]" | awk '"'"'{print $1}'"'"' | xargs git branch -D'
alias gbm='git branch --move'
alias gbnm='git branch --no-merged'
alias gbr='git branch --remote'
alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'
alias gbg='LANG=C git branch -vv | grep ": gone\]"'
alias gco='git checkout'
alias gcor='git checkout --recurse-submodules'
alias gcb='git checkout -b'
alias gcd='git checkout $(git_develop_branch)'
alias gcm='git checkout $(git_main_branch)'
alias gcp='git cherry-pick'
alias gcpa='git cherry-pick --abort'
alias gcpc='git cherry-pick --continue'
alias gclean='git clean --interactive -d'
alias gcl='git clone --recurse-submodules'

function gccd() {
  setopt localoptions extendedglob

  # get repo URI from args based on valid formats: https://git-scm.com/docs/git-clone#URLS
  local repo="${${@[(r)(ssh://*|git://*|ftp(s)#://*|http(s)#://*|*@*)(.git/#)#]}:-$_}"

  # clone repository and exit if it fails
  command git clone --recurse-submodules "$@" || return

  # if last arg passed was a directory, that's where the repo was cloned
  # otherwise parse the repo URI and use the last part as the directory
  [[ -d "$_" ]] && cd "$_" || cd "${${repo:t}%.git/#}"
}
compdef _git gccd=git-clone

alias gcam='git commit --all --message'
alias gcas='git commit --all --signoff'
alias gcasm='git commit --all --signoff --message'
alias gcs='git commit --gpg-sign'
alias gcss='git commit --gpg-sign --signoff'
alias gcssm='git commit --gpg-sign --signoff --message'
alias gcmsg='git commit --message'
alias gcsm='git commit --signoff --message'
alias gc='git commit --verbose'
alias gca='git commit --verbose --all'
alias gca!='git commit --verbose --all --amend'
alias gcan!='git commit --verbose --all --no-edit --amend'
alias gcans!='git commit --verbose --all --signoff --no-edit --amend'
alias gc!='git commit --verbose --amend'
alias gcn!='git commit --verbose --no-edit --amend'
alias gcf='git config --list'
alias gdct='git describe --tags $(git rev-list --tags --max-count=1)'
alias gd='git diff'
alias gdca='git diff --cached'
alias gdcw='git diff --cached --word-diff'
alias gds='git diff --staged'
alias gdw='git diff --word-diff'

function gdv() { git diff -w "$@" | view - }
compdef _git gdv=git-diff

alias gdup='git diff @{upstream}'

function gdnolock() {
  git diff "$@" ":(exclude)package-lock.json" ":(exclude)*.lock"
}
compdef _git gdnolock=git-diff

alias gdt='git diff-tree --no-commit-id --name-only -r'
alias gf='git fetch'
# --jobs=<n> was added in git 2.8
is-at-least 2.8 "$git_version" \
  && alias gfa='git fetch --all --prune --jobs=10' \
  || alias gfa='git fetch --all --prune'
alias gfo='git fetch origin'
alias gg='git gui citool'
alias gga='git gui citool --amend'
alias ghh='git help'
alias glgg='git log --graph'
alias glgga='git log --graph --decorate --all'
alias glgm='git log --graph --max-count=10'
alias glods='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset" --date=short'
alias glod='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset"'
alias glola='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset" --all'
alias glols='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset" --stat'
alias glol='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset"'
alias glo='git log --oneline --decorate'
alias glog='git log --oneline --decorate --graph'
alias gloga='git log --oneline --decorate --graph --all'

# Pretty log messages
function _git_log_prettily(){
  if ! [ -z $1 ]; then
    git log --pretty=$1
  fi
}
compdef _git _git_log_prettily=git-log

alias glp='_git_log_prettily'
alias glg='git log --stat'
alias glgp='git log --stat --patch'
alias gignored='git ls-files -v | grep "^[[:lower:]]"'
alias gfg='git ls-files | grep'
alias gm='git merge'
alias gma='git merge --abort'
alias gms="git merge --squash"
alias gmom='git merge origin/$(git_main_branch)'
alias gmum='git merge upstream/$(git_main_branch)'
alias gmtl='git mergetool --no-prompt'
alias gmtlvim='git mergetool --no-prompt --tool=vimdiff'

alias gl='git pull'
alias gpr='git pull --rebase'
alias gprv='git pull --rebase -v'
alias gpra='git pull --rebase --autostash'
alias gprav='git pull --rebase --autostash -v'

function ggu() {
  [[ "$#" != 1 ]] && local b="$(git_current_branch)"
  git pull --rebase origin "${b:=$1}"
}
compdef _git ggu=git-checkout

alias gprom='git pull --rebase origin $(git_main_branch)'
alias gpromi='git pull --rebase=interactive origin $(git_main_branch)'
alias ggpull='git pull origin "$(git_current_branch)"'

function ggl() {
  if [[ "$#" != 0 ]] && [[ "$#" != 1 ]]; then
    git pull origin "${*}"
  else
    [[ "$#" == 0 ]] && local b="$(git_current_branch)"
    git pull origin "${b:=$1}"
  fi
}
compdef _git ggl=git-checkout

alias gluc='git pull upstream $(git_current_branch)'
alias glum='git pull upstream $(git_main_branch)'
alias gp='git push'
alias gpd='git push --dry-run'

function ggf() {
  [[ "$#" != 1 ]] && local b="$(git_current_branch)"
  git push --force origin "${b:=$1}"
}
compdef _git ggf=git-checkout

alias gpf!='git push --force'
is-at-least 2.30 "$git_version" \
  && alias gpf='git push --force-with-lease --force-if-includes' \
  || alias gpf='git push --force-with-lease'

function ggfl() {
  [[ "$#" != 1 ]] && local b="$(git_current_branch)"
  git push --force-with-lease origin "${b:=$1}"
}
compdef _git ggfl=git-checkout

alias gpsup='git push --set-upstream origin $(git_current_branch)'
is-at-least 2.30 "$git_version" \
  && alias gpsupf='git push --set-upstream origin $(git_current_branch) --force-with-lease --force-if-includes' \
  || alias gpsupf='git push --set-upstream origin $(git_current_branch) --force-with-lease'
alias gpv='git push --verbose'
alias gpoat='git push origin --all && git push origin --tags'
alias gpod='git push origin --delete'
alias ggpush='git push origin "$(git_current_branch)"'

function ggp() {
  if [[ "$#" != 0 ]] && [[ "$#" != 1 ]]; then
    git push origin "${*}"
  else
    [[ "$#" == 0 ]] && local b="$(git_current_branch)"
    git push origin "${b:=$1}"
  fi
}
compdef _git ggp=git-checkout

alias gpu='git push upstream'
alias grb='git rebase'
alias grba='git rebase --abort'
alias grbc='git rebase --continue'
alias grbi='git rebase --interactive'
alias grbo='git rebase --onto'
alias grbs='git rebase --skip'
alias grbd='git rebase $(git_develop_branch)'
alias grbm='git rebase $(git_main_branch)'
alias grbom='git rebase origin/$(git_main_branch)'
alias gr='git remote'
alias grv='git remote --verbose'
alias gra='git remote add'
alias grrm='git remote remove'
alias grmv='git remote rename'
alias grset='git remote set-url'
alias grup='git remote update'
alias grh='git reset'
alias gru='git reset --'
alias grhh='git reset --hard'
alias grhk='git reset --keep'
alias grhs='git reset --soft'
alias gpristine='git reset --hard && git clean --force -dfx'
alias groh='git reset origin/$(git_current_branch) --hard'
alias grs='git restore'
alias grss='git restore --source'
alias grst='git restore --staged'
alias gunwip='git rev-list --max-count=1 --format="%s" HEAD | grep -q "\--wip--" && git reset HEAD~1'
alias grev='git revert'
alias grm='git rm'
alias grmc='git rm --cached'
alias gcount='git shortlog --summary --numbered'
alias gsh='git show'
alias gsps='git show --pretty=short --show-signature'
alias gstall='git stash --all'
alias gstaa='git stash apply'
alias gstc='git stash clear'
alias gstd='git stash drop'
alias gstl='git stash list'
alias gstp='git stash pop'
# use the default stash push on git 2.13 and newer
is-at-least 2.13 "$git_version" \
  && alias gsta='git stash push' \
  || alias gsta='git stash save'
alias gsts='git stash show --patch'
alias gst='git status'
alias gss='git status --short'
alias gsb='git status --short --branch'
alias gsi='git submodule init'
alias gsu='git submodule update'
alias gsd='git svn dcommit'
alias git-svn-dcommit-push='git svn dcommit && git push github $(git_main_branch):svntrunk'
alias gsr='git svn rebase'
alias gsw='git switch'
alias gswc='git switch --create'
alias gswd='git switch $(git_develop_branch)'
alias gswm='git switch $(git_main_branch)'
alias gta='git tag --annotate'
alias gts='git tag --sign'
alias gtv='git tag | sort -V'
alias gignore='git update-index --assume-unchanged'
alias gunignore='git update-index --no-assume-unchanged'
alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'
alias gwt='git worktree'
alias gwta='git worktree add'
alias gwtls='git worktree list'
alias gwtmv='git worktree move'
alias gwtrm='git worktree remove'
alias gstu='gsta --include-untracked'
alias gtl='gtl(){ git tag --sort=-v:refname -n --list "${1}*" }; noglob gtl'
alias gk='\gitk --all --branches &!'
alias gke='\gitk --all $(git log --walk-reflogs --pretty=%h) &!'

unset git_version

# Logic for adding warnings on deprecated aliases
local old_alias new_alias
for old_alias new_alias (
  # TODO(2023-10-19): remove deprecated `git pull --rebase` aliases
  gup     gpr
  gupv    gprv
  gupa    gpra
  gupav   gprav
  gupom   gprom
  gupomi  gpromi
); do
  aliases[$old_alias]="
    print -Pu2 \"%F{yellow}[oh-my-zsh] '%F{red}${old_alias}%F{yellow}' is a deprecated alias, using '%F{green}${new_alias}%F{yellow}' instead.%f\"
    $new_alias"
done
unset old_alias new_alias
```

> 温馨提示：如果你对阅读 Shell 脚本没有兴趣，那么可以只查看同级目录下的 `README.md` 了解用法。

可以发现在 git 插件里提供了很多命令的别名，可以选择自己的常用命令进行强化记忆和使用，例如：
``` bash
# gst = git status
# gaa = git add --all
# gcmsg = git commit --message
# ggpush = git push origin "$(git_current_branch)" 
# gco = git checkout
➜  git git:(master) gst
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
```

> 温馨提示：如果你希望使用 `npmS` 代替 `npm i -S`，那么可以配置 npm 插件。

#### alias-finder 插件

尽管 git 插件提供了很多别名，但是那么多别名一个个记忆实在太痛苦了，对于那些实在记不住的 alias 如果有一个实时提示的记忆工具就好了。alias-finder 插件为此而生，它可以在每一次执行命令后提示该命令的 alias，打开它的 `README.md` 查看配置说明：

``` md
# alias-finder plugin

This plugin searches the defined aliases and outputs any that match the command inputted. This makes learning new aliases easier.

## Usage

To use it, add `alias-finder` to the `plugins` array of your zshrc file:

plugins=(... alias-finder)

To enable it for every single command, set zstyle in your `~/.zshrc`.

zstyle ':omz:plugins:alias-finder' autoload yes # disabled by default
zstyle ':omz:plugins:alias-finder' longer yes # disabled by default
zstyle ':omz:plugins:alias-finder' exact yes # disabled by default
zstyle ':omz:plugins:alias-finder' cheaper yes # disabled by default

As you can see, options are also available with zstyle.

### Options

> In order to clarify, let's say `alias a=abc` has source 'abc' and destination 'a'.

- Use `--longer` or `-l` to include aliases where the source is longer than the input (in other words, the source could contain the whole input).
- Use `--exact` or `-e` to avoid aliases where the source is shorter than the input (in other words, the source must be the same with the input).
- Use `--cheaper` or `-c` to avoid aliases where the destination is longer than the input (in other words, the destination must be the shorter than the input).
```

为此我们可以配置 `.zshrc` 文件：

``` bash
# 新增 alias-finder 插件
plugins=(git alias-finder)

zstyle ':omz:plugins:alias-finder' autoload yes # 默认是禁用的
zstyle ':omz:plugins:alias-finder' longer yes # 默认是禁用的
zstyle ':omz:plugins:alias-finder' exact yes # 默认是禁用的
zstyle ':omz:plugins:alias-finder' cheaper yes # 默认是禁用的
```

需要注意修改 `.zshrc` 的配置默认并不会立即生效，因为它本身是一个 Shell 脚本，需要被执行后才能生效。为了可以使它生效，你可以关闭 iTerm2 然后重新打开，此时 zsh 会按照设定的初始化过程自动查找并执行 `~/.zshrc` 配置文件，这也是为什么 Oh My Zsh 插件设置过多后会影响 zsh 启动速度的原因。当然，如果你不想关闭当前终端来生效 `.zshrc` 配置文件，那么只需要在当前环境使用 `.` 或者 `source` 执行 `.zshrc` 即可，如下所示：

``` bash
# 执行 . ~/.zshrc 是一样的功能效果
# . 命令和 source 命令相同，表示不产生新的 shell，在当前 shell 下执行命令，可以共享同一个 shell 上下文
# 在 huksy 中 pre-commit 钩子中也是使用 . 来执行 shell 命令
source ~/.zshrc
```

配置生效后，我们可以测试一下 alias-finder 插件的作用：

``` bash
# 执行
git status
# 打印（提示了执行命令相关的 alias 命令）
gsb='git status --short --branch'
gss='git status --short'
gst='git status'
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   plugins/git/README.md

no changes added to commit (use "git add" and/or "git commit -a")

# 执行
git push origin
# 打印（提示了执行命令相关的 alias 命令）
ggpush='git push origin "$(git_current_branch)"'
gpoat='git push origin --all && git push origin --tags'
gpod='git push origin --delete'
remote: Permission to ohmyzsh/ohmyzsh.git denied to ziyi2.
```


#### z 插件

在实际开发项目的过程中，我们会频繁使用 `cd` 和 `ls` 进出和查看文件目录，如果目录层级较深，那么进入目录的效率会非常低下，[z 插件](https://github.com/agkozak/zsh-z)可以帮我们快速进入之前访问过的目录，从而加速目录的访问效率，打开 z 插件的 `README.md` 查看配置说明：

``` md
# z - jump around

This plugin defines the [z command](https://github.com/agkozak/zsh-z) that tracks your most visited directories and allows you to access them with very few keystrokes.

### Example

Assume that you have previously visited directory `~/.oh-my-zsh/plugins`. From any folder in your command line, you can quickly access it by using a regex match to this folder:

/usr/bin$ z plug  # Even 'z p' might suffice
~/.oh-my-zsh/plugins$

### Setup

To enable z, add `z` to your `plugins` array in your zshrc file:

plugins=(... z)

### Further reading

For advanced usage and details of z, see [MANUAL](./MANUAL.md) (copied from [agkozak/zsh-z](https://github.com/agkozak/zsh-z)).
```

我们重新配置 `.zshrc` 增加 z 插件：

``` bash
plugins=(git alias-finder z)
```

执行 `source ~/.zshrc` 使配置生效，测试 z 插件的功能：

``` bash
➜  Desktop cd ~/.oh-my-zsh
➜  .oh-my-zsh git:(master) ✗ cd plugins
➜  plugins git:(master) ✗ cd ~
➜  ~ z p
➜  Desktop z plug
➜  plugins git:(master) ✗ z oh
➜  .oh-my-zsh git:(master) ✗
```

可以发现 z 插件可以通过模糊匹配快速跳转到之前访问过的目录。

> 温馨提示：[autojump](https://github.com/wting/autojump) 是一款和 z 相似的快速跳转工具，它会根据你访问目录的频率对目录进行加权。如果你想要使用 autojump，那么需要额外对它进行[安装](https://github.com/wting/autojump#installation)。

#### zsh-autosuggestions 插件

之前介绍的 git、alias-finder 和 z 都是 Oh My Zsh 默认自带的标准插件，因此不需要任何安装处理。除此之外，社区还提供了很多三方自定义的插件，这些插件需要额外的安装处理。 在了解自定义插件之前，我们重新查看 `.zshrc` 的插件配置说明：

``` bash
# Which plugins would you like to load?
# Oh My Zsh 默认自带的标准插件被放置在目录 $ZSH/plugins（$HOME/.oh-my-zsh/plugins) 中
# Standard plugins can be found in $ZSH/plugins/
# 三方自定义插件需要安装到 $ZSH_CUSTOM/plugins（$HOME/.oh-my-zsh/custom/plugins）中
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git alias-finder z)
```

从插件的注释说明可以发现，如果是自定义插件需要安装到 `$HOME/.oh-my-zsh/custom/plugins` 目录中，这样可以将三方插件和标准插件区分开，一旦 Oh My Zsh 需要更新，通常只会更新标准插件目录中的插件，不会覆盖三方插件所在的目录。

> 温馨提示：Oh My Zsh 允许配置三方插件所在的目录文件。除此之外，所有的三方插件放在单独的目录中可以使得备份、迁移和共享更加便捷，你完全可以把自定义插件和 Oh My Zsh 的配置拷贝给别人或者迁移到新的电脑上，不需要重新对所有插件进行安装处理。

[zsh-autosuggestions](https://github.com/zsh-users/zsh-autosuggestions/tree/master) 是一个能够自动提示命令的插件，它会根据用户的历史命令来预测用户想要输入的完整命令，从而智能的给出命令补全提示，如果用户接受提示，则只需要使用特定的快捷键快速补全命令即可，这样可以大大减少输入完整命令的时间，从而提升开发效率。我们首先需要安装 zsh-autosuggestions 插件，根据官方的 [Oh My Zsh 安装文档](https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh) 进行安装：

``` bash
# 首先克隆 zsh-autosuggestions 仓库到 $ZSH_CUSTOM/plugins 目录下
# $ZSH_CUSTOM/plugins = $HOME/.oh-my-zsh/custom/plugins

# ${ZSH_CUSTOM:-~/.oh-my-zsh/custom} 是一个参数替换表达式
# 如果环境变量 ZSH_CUSTOM 已设置，那么使用 ZSH_CUSTOM
# 否则使用 ~/.oh-my-zsh/custom 作为默认值（这里的 ~ 就是 $HOME）
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions

# 克隆成功后可以进入目录查看一下
# 使用 z 快速匹配最近访问的 $HOME/.oh-my-zsh/custom/plugins 目录
➜  ~ z plug
➜  plugins git:(master) ✗ ls
example             zsh-autosuggestions
```

在自定义的 `plugins` 目录下存放了 zsh-autosuggestions 插件之后，接下来可以配置 `~/.zshrc` 文件：

``` bash
# 新增 zsh-autosuggestions 插件配置
plugins=(git alias-finder z zsh-autosuggestions)
```

配置完成后执行 `source ~/.zshrc` 使得当前 Shell 环境的 Oh My Zsh 配置生效，接下来使用命令时 zsh-autosuggestions 会根据历史命令进行智能补全，如果灰色部分的智能提示是我们需要的补全命令，那么只需要使用快捷键 **→** 进行快速补全：

![录屏2023-11-24 09.27.44.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f17af5f2c49b4365b916e5b87acfb8a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=426&s=61967&e=gif&f=28&b=373833)

> 温馨提示：如果你对命令的自动补全感兴趣，可以查看 [zsh-completions](https://github.com/zsh-users/zsh-completions) 插件。注意，zsh-autosuggestions 是根据用户输入的历史命令进行补全提示，而 zsh-completions 用于补全命令和选项。除此之外，Zsh 默认已经具备了补全功能，包括命令、文件名（例如输入 `ls` + 空格然后按 `Tab` 键进行文件名补全提示）、变量名和其他类型的参数补全，zsh-completions 是对 Zsh 默认补全功能的额外补充。

#### zsh-syntax-highlighting 插件

[Fish Shell](https://fishshell.com/) 默认提供了输入信息的高亮展示，如下所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078b4bbda338471eba8ff5c98b730789~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=420&s=20177&e=png&b=000000)

Zsh 默认并没有输入的高亮能力，如下所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9b3b05fa1d24acbae984d04a23021c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2180&h=318&s=575790&e=png&b=303636)

如果想要实现类似于 Fish Shell 的输入高亮，可以使用 [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting) 插件，当输入命令时，zsh-syntax-highlighting 插件可以实时地对输入进行语法高亮，而且还可以帮助发现输入错误，例如拼写错误或者语法错误。它和 zsh-autosuggestions 插件的安装过程类似，我们需要根据官方的 [Oh My Zsh 安装文档](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh) 进行安装：

``` bash
# 首先克隆 zsh-autosuggestions 仓库到 $ZSH_CUSTOM/plugins 目录下
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
```

接下来可以配置 `~/.zshrc` 文件：

``` bash
# 新增 zsh-syntax-highlighting 插件配置
plugins=(git alias-finder z zsh-autosuggestions zsh-syntax-highlighting)
```

配置完成后执行 `source ~/.zshrc` 使得当前 Shell 环境的 Oh My Zsh 配置生效，接下来我们输入命令就可以进行语法高亮了：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22df270d94f94a17af0d9fe69103df23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2178&h=312&s=555330&e=png&b=2f3435)

> 温馨提示：如果想要了解更多三方插件，可以查看 [awesome-zsh-plugins](https://github.com/unixorn/awesome-zsh-plugins)。


### Oh My Zsh 主题配置

Oh My Zsh 除了提供了标准插件和三方插件之外，还提供了非常多的[默认主题](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes)（点击链接可以查看各种主题效果）。打开 `~/.zshrc` 找到主题配置：

``` bash
# 配置主题的名字，如果设置为 random，那么每次打开会随机使用一个内置的主题
# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# 可以设置一系列需要随机的主题
# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )
```

主题和标准插件类似，主要存放在 `~/.oh-my-zsh/themes`（插件在同级的 `plugins`） 目录下：
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e666a1eccf0b402294ba1cefd917f9f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2434&h=1960&s=1648699&e=png&a=1&b=203036)

#### agnoster 主题
我们可以根据官方提供的主题效果示例来配置一个主题，例如 [agnoster](https://gist.github.com/agnoster/3712874)：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b953b4957c4e4ea9b53978a8c4746d8d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1590&s=1428883&e=png&b=fefefe)

将 `~/.zshrc` 的主题更改为 agnoster，执行 `source ~/.zshrc` 使其生效：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e051c02bd4d84684a358d49381cd4473~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2172&h=634&s=1246780&e=png&b=2f3435)
 
根据 [agnoster](https://gist.github.com/agnoster/3712874) 的说明，使用该主题可能需要安装额外的字体，可以通过输入命令 `echo "\ue0b0 \u00b1 \ue0a0 \u27a6 \u2718 \u26a1 \u2699"` 测试是否支持主题需要的字体图标，例如作者的电脑默认不支持部分图标，所以会展示一些带 ? 号的图标：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0613c6350364eae83d1c2709d48062d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2182&h=394&s=757114&e=png&b=2f3435)

默认支持的情况如下所示：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4089f3f1ee8c402a95980e4409b8712a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=60&s=12177&e=png&b=032934)

除此之外，如果你想去除 `user@hostname` 提示，那么可以直接通过命令 `code ~/.oh-my-zsh/themes/agnoster.zsh-theme` 编辑主题：

``` bash
# Context: user@hostname (who am I and where am I)
prompt_context() {
  if [[ "$USERNAME" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then
    prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"
  fi
}

## Main prompt
build_prompt() {
  RETVAL=$?
  prompt_status
  prompt_virtualenv
  prompt_aws
  # 注释掉此功能
  # prompt_context
  prompt_dir
  prompt_git
  prompt_bzr
  prompt_hg
  prompt_end
}

PROMPT='%{%f%b%k%}$(build_prompt) '
```

再次执行 `source ~/.zshrc` 后，主题的命令提示符就被更改了：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9148dfc429004a72b4da722b6c45c2aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2174&h=538&s=1094274&e=png&b=2f3435)

#### powerlevel10k 主题

Oh My Zsh 不仅在插件方面可以通过三方进行定制，主题也可以通过三方进行安装配置。如果觉得默认的主题不够简洁美观，那么推荐安装 [powerlevel10k](https://github.com/romkatv/powerlevel10k) 主题，它是一个非常流行且高度可定制的 Zsh 主题，提供了强大的提示符支持，包括 Git 分支状态、命令执行时间、背景作业数以及许多其它实用功能。同时，它还提供了一个配置向导，帮助用户轻松设置和自定义他们的提示符外观。

Oh My Zsh 主题的安装和插件的安装流程类似，如下所示：

``` bash
# 克隆仓库到 $ZSH_CUSTOM/themes 目录下（三方定制的插件在同级的 plugins 目录下）
git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
```

配置 `.zshrc` 文件：

``` bash
# 配置主题为三方的自定义主题
ZSH_THEME="powerlevel10k/powerlevel10k"
```

配置完成后执行 `source ~/.zshrc` 使得主题生效，生效后 powerlevel10k 会自动开启配置向导，如下所示：
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25133100faee4f56b4224b1b2307bdc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560&h=1938&s=1021489&e=png&a=1&b=223237)

在 iTerm2 的终端环境中，powerlevel10k 的配置向导首先会提示是否需要安装 Meslo Nerd Font 字体（详见 [Meslo Nerd Font patched for Powerlevel10k / Automatic font installation](https://github.com/romkatv/powerlevel10k#automatic-font-installation)），我们回答 yes 进行安装即可。安装完成后会提示我们需要重启 iTerm2：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1a6f6c4a26474489c51b3990f6e655~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560&h=1938&s=1019560&e=png&a=1&b=223237)
重新启动后仍然会自动进入 iTerm2 的配置向导，此时我们只需要根据提示一步步进行配置即可：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/855333bc4d604a058df7dd6b3419bce0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560&h=1012&s=600368&e=png&a=1&b=223237)
例如作者配置完成后的效果如下所示：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fecad176beb245e99944f50f80d763dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560&h=1012&s=682739&e=png&a=1&b=223137)
打开 VS Code 查看终端的效果：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a649e9b9680343889134c3be631f95c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1624&h=969&s=376004&e=png&a=1&b=1a1a1a)
如果对配置的结果不满意，可以输入 `p10k configure` 命令进入配置向导进行配置。


### Zplug 插件管理器

Zsh 的开源配置框架有很多，除了 Oh My Zsh 也可以使用其它的开源配置框架，例如 [Zplug](https://github.com/zplug/zplug) ，它是一个强大的插件管理器，支持并行安装插件，从而具备较快的启动速度。如果希望插件配置可以在新电脑上进行快速迁移，那么 Zplug 只需要拷贝 `~/.zshrc` 文件即可，启动新环境的终端时，它会检插件是否安装，如果未安装会自动进行安装。Oh My Zsh 如果想要迁移三方插件，除了拷贝 `~/.zshrc` 文件之外，还需要额外拷贝已经安装的三方插件文件。除此之外，Zplug 还提供了 `update` 命令，具备一键更新插件版本的能力。如果不在乎 Zsh 的启动速度，那么可以使用 Oh My Zsh 来配置主题和默认插件，使用 Zplug 来管理三方插件。

## 小结

本课程讲解了如何使用 iTerm2 配置终端的分屏效果，从而可以并行执行多个终端任务。除此之外，还讲解了 Oh My Zsh 开源配置框架以及如何基于配置框架进行插件和主题的配置。通过使用 Zsh 的插件和主题，可以快速提升终端命令的操作效率。