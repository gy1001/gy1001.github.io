在之前的动态 Script 以及 Fetch 示例中，我们讲解的微应用都是单个 Bundle 的加载示例，但在实际的开发中，考虑到页面的加载性能，往往需要将微应用的资源进行代码分割（Code Splitting），从而实现首屏加载的性能优化。本课程会设计基于代码分割的 Fetch 示例。


## 为什么需要代码分割

代码分割（Code Splitting）是一种性能优化技术，它主要是将单个 Bundle 文件拆分成多个较小的 Bundle，然后实现这些 Bundle 的按需加载或者并行加载。如果拆分合理，可以极大的减少页面的首屏加载时间，并可以提升移动端或者弱网环境的页面加载性能。常用的代码分割包含以下几种情况：

- **多入口配置**：如果项目存在多个入口的应用，可以抽离被这些应用重复使用的代码（例如常见的三方库、通用的框架和工具方法等），从而减少整体体积，并可以提高复用代码的缓存效率。
- **按需加载**：例如在 React 和 Vue 等 Web 框架中通常会使用路由访问页面，此时可以实现按路由加载资源，当用户打开页面时，只需要加载激活路由对应的资源，从而缩短首屏资源的加载和解析时间。
- **并行加载**：现代浏览器允许并行下载多个文件，在单个 Bundle 体积较大时，可以将 Bundle 拆分成多个更小的 Bundle，从而利用并行下载的特性缩短资源的加载时间。除此之外，在计算资源受限的移动设备上，较小的文件可以更快的被解析和编译。

本课程会简单讲解如何实现代码分割，并讲解**按需加载**代码分割的运行时原理，从而使大家可以更好的了解在微前端中使用代码分割的注意事项。

> 温馨提示：在多入口的应用开发中，为了节省前端资源的整体体积大小，可以通过 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 来分析这些应用的可复用模块，从而将其从各个应用的 bundle 中抽离出来，形成可复用的 chunk 文件。例如可以切分出公共的 node_modules、公共业务组件、公共 service、公共 utils 等。例如在弱网环境中，请求加载一个完整的超大 JS 文件会比并行加载多个切割的小型 JS 文件需要更多的时间。另外，可复用的 chunk 文件在多页应用中可以进行 HTTP 缓存，从而增加 JS 的缓存命中数。当然，在分离的过程中需要考虑单个 chunk 的大小以及 chunk 的数量等，从而适配移动设备、弱网、HTTP 并发请求数量限制等不同的场景。

## 如何实现代码分割

这里简单讲解一些代码分割的简单示例，从而帮助大家更好的了解该功能的作用。

### 多入口配置

假设应用 1 和应用 2 都是 Vue 应用，示例代码的目录结构如下所示：

``` bash
.
├── public              # 静态资源托管目录
│   ├── dist            # 构建目录
│   │   ├── app1.js
│   │   └── app2.js   
│   ├── app1.html         
│   └── app2.html       
├── src                 # 源文件目录
│   ├── app1.js         # 微应用 1 源码
│   └── app2.js         # 微应用 2 源码
├── server.js           # 启动服务          
├── package.json        # 项目描述文件
└── webpack.config.js   # webpack 配置文件
```

> 温馨提示：示例源码可以从 webpack-runtime-analyze 的 [demo/code_splitting](https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/code_splitting) 分支获取。

在 `src/app1.js` 和 `src/app2.js` 中引入 Vue 创建 `div` 元素进行渲染，如下所示：

``` javascript
// src/app1.js
import { createApp, ref, h } from "vue";

createApp({
  setup() {
    // 详见 https://cn.vuejs.org/api/composition-api-setup.html#usage-with-render-functions
    const message = ref('Hello App 1');
    return () => h("div", message.value);
  },
}).mount("#app");


// src/app2.js
import { createApp, ref, h } from "vue";

createApp({
  setup() {
    const message = ref('Hello App 2');
    return () => h("div", message.value);
  },
}).mount("#app");
```

在 Webpack 的 `webpack.config.js` 文件中新增如下多入口配置：

``` javascript
// 用于分析构建产物
const BundleAnalyzerPlugin =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
const path = require("path");

module.exports = {
  mode: "production",
  entry: {
    // 应用 1 入口
    app1: "./src/app1.js",
    // 应用 2 入口
    app2: "./src/app2.js",
  },
  output: {
    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹
  },
  plugins: [new BundleAnalyzerPlugin()],
};

```

在项目的根目录执行 `npm run build` 后会在 `public/dist` 目录下生成构建文件：

``` bash
# 执行
npm run build 

# 打印
> webpack-runtime-analyze@1.0.0 build
> webpack

# 构建产物的可视化分析访问地址
Webpack Bundle Analyzer is started at http://127.0.0.1:8888
Use Ctrl+C to close it
# 生成 app1.js，大小为 57.8 KiB
asset app1.js 57.8 KiB [emitted] [minimized] (name: app1) 1 related asset
# 生成 app2.js，大小为 57.8 KiB
asset app2.js 57.8 KiB [emitted] [minimized] (name: app2) 1 related asset
orphan modules 348 KiB [orphan] 5 modules
runtime modules 442 bytes 2 modules
cacheable modules 696 KiB
  ./src/app1.js + 4 modules 348 KiB [built] [code generated]
  ./src/app2.js + 4 modules 348 KiB [built] [code generated]
webpack 5.89.0 compiled successfully in 1095 ms
```

在构建时使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对构建产物进行可视化分析，可以发现两个应用构建后各自打包了 `node_modules` 下的代码，如下所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a47206d97d0490093336c6546940c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1055&s=1617337&e=png&b=77d5b9)

> 温馨提示：从上图左侧 Show chunks 的 All 可以看出默认没有分割的情况下，两个应用的总体积为 115.51 KB。

在 `public/app1.html` 和 `public/app2.html` 中引入构建后的脚本，如下所示：

``` html
<!-- app1.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="./dist/app1.js"></script>
  </body>
</html>

<!-- app2.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="./dist/app2.js"></script>
  </body>
</html>
```

在 `server.js` 中使用 Express [配置静态文件服务](https://www.expressjs.com.cn/starter/static-files.html)，使得 `public` 目录下的文件可以对外访问：

``` javascript
const express = require("express");
const morgan = require("morgan");
const app = express();
const port = 4000;

// 打印请求日志
app.use(morgan("dev"));

app.use(
  // 利用 Express 托管静态文件：https://www.expressjs.com.cn/starter/static-files.html
  express.static("public", {
    cacheControl: false,
    // HTTP 缓存
    // 每次请求都会向服务器进行验证
    // 如果资源没有变化，则会返回 304（不携带资源）继续使用缓存
    // 如果资源变化，则返回 200 并携带变化后的资源
    etag: true,
    lastModified: false,
  })
);

// 启动 Node 服务
app.listen(port);
console.log(`server start at http://localhost:${port}/`);
```

> 温馨提示：在托管静态资源时加入了 HTTP 缓存，这里设置成强制向服务器验证服务文件的缓存有效性。如果你对缓存不清楚，可以查看[原理解析：性能优化 / HTTP 缓存](https://juejin.cn/book/7258893482318626868/section/7259192938658267151#heading-0)。

托管后我们可以访问 `public` 目录下的所有文件，例如：

``` 
http://localhost:4000/app1.html
http://localhost:4000/app2.html
http://localhost:4000/dist/app1.js
http://localhost:4000/dist/app2.js
```

执行 `node server.js` 启动服务，访问对应的应用，如下所示：

``` bash
# 执行 node server.js
npm run start

# 打印信息
> webpack-runtime-analyze@1.0.0 start
> node server.js

server start at http://localhost:4000/
# 首次访问 http://localhost:4000/app1.html 所有资源返回 200 状态码
GET /app1.html 200 10.138 ms - 281
GET /dist/app1.js 200 1.343 ms - 59141
# 首次访问 http://localhost:4000/app2.html 所有资源返回 200 状态码
GET /app2.html 200 1.819 ms - 281
GET /dist/app2.js 200 1.608 ms - 59141
```

> 温馨提示：重新启动服务会对 HTTP 缓存产生影响吗？

首次访问应用 1 和微应用 2 时所有资源都返回状态码 200：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5322dbbdd5e747e488e953b3ad1c735d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1604&h=986&s=167112&e=png&b=fefefe)

我们可以计算一下两个微应用首次请求资源的情况：

``` bash
# 首次请求微应用 1
app1.html：517 B
app1.js：59.4 kB
应用 1 的总请求：517 + 59.4 * 1024 = 61342.6 B（59.9 kB）
# 首次请求微应用 2
app2.html：517 B
app2.js：59.4 kB
应用 2 的总请求：517 + 59.4 * 1024 = 61342.6 B（59.9 kB）
```

由于应用 1 和应用 2 共用了 `node_modules` 中的库代码，因此这里可以将 `node_modules` 的代码分割出来，我们重新修改 `webpack.config.js` 文件：

``` javascript
// 用于分析构建产物
const BundleAnalyzerPlugin =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
const path = require("path");

module.exports = {
  mode: "production",
  entry: {
    app1: "./src/app1.js",
    app2: "./src/app2.js",
  },
  output: {
    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹
  },
  plugins: [new BundleAnalyzerPlugin()],
  optimization: {
    // 将复用的代码抽离出来，形成一个单独的 vendors.js 文件
    splitChunks: {
      chunks: 'all',
      name: 'vendors'
    },
  },
};
```

在项目的根目录执行 `npm run build` 后会在 `public/dist` 目录下生成构建文件：

``` bash
# 执行
npm run build

# 打印
> webpack-runtime-analyze@1.0.0 build
> webpack

# 构建产物的可视化分析访问地址
Webpack Bundle Analyzer is started at http://127.0.0.1:8888
Use Ctrl+C to close it
# 生成 vendors.js，大小为 60.9 KiB
asset vendors.js 60.9 KiB [emitted] [minimized] (name: vendors) (id hint: vendors) 1 related asset
# 生成 app1.js，大小为 1.35 KiB
asset app1.js 1.35 KiB [emitted] [minimized] (name: app1)
# 生成 app2.js，大小为 1.35 KiB
asset app2.js 1.35 KiB [emitted] [minimized] (name: app2)
Entrypoint app1 62.2 KiB = vendors.js 60.9 KiB app1.js 1.35 KiB
Entrypoint app2 62.2 KiB = vendors.js 60.9 KiB app2.js 1.35 KiB
runtime modules 6.03 KiB 10 modules
orphan modules 580 bytes [orphan] 1 module
cacheable modules 348 KiB
  modules by path ./node_modules/@vue/ 348 KiB
    ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js 48.2 KiB [built] [code generated]
    ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js 245 KiB [built] [code generated]
    ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js 34.1 KiB [built] [code generated]
    ./node_modules/@vue/shared/dist/shared.esm-bundler.js 20.3 KiB [built] [code generated]
  modules by path ./src/*.js 436 bytes
    ./src/app1.js 265 bytes [built] [code generated]
    ./src/app2.js 171 bytes [built] [code generated]
webpack 5.89.0 compiled successfully in 1193 ms
```

使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对构建产物进行可视化分析，可以发现两个应用构建后分割出了共同复用的 `vendors.js` 文件，该文件主要打包了所有 `node_modules` 中的库包代码，如下所示：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5109ca8369ed458a94b771657c7cd85c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1055&s=1609885&e=png&b=7598d3)

> 温馨提示：从上图左侧 Show chunks 的 All 可以看出在分割代码的情况下，两个应用的总体积为 63.57 KB，因为抽离了可复用的 `node_modules`，不再是每一个应用都打包 `node_modules` 的代码，因此相对没有分割代码的情况而言总体积少了 51.94 KB（115.51 KB - 63.57 KB）。

接下来修改 `public/app1.html` 和 `public/app2.html` 中的引入脚本，如下所示：

``` html
<!-- app1.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
    <!-- 引入复用的 vendors.js -->
    <script src="./dist/vendors.js"></script>
    <script src="./dist/app1.js"></script>
  </body>
</html>

<!-- app2.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
    <!-- 引入复用的 vendors.js -->
    <script src="./dist/vendors.js"></script>
    <script src="./dist/app2.js"></script>
  </body>
</html>
```

服务代码保持不变，重新执行 `node server.js` 启动服务，访问对应的应用，如下所示：

``` bash
# 执行 node server.js
npm run start

# 打印信息
> webpack-runtime-analyze@1.0.0 start
> node server.js

server start at http://localhost:4000/
GET / 404 2.914 ms - 139
# 首次请求微应用 1
# 所有资源返回 200 状态码
GET /app1.html 200 7.572 ms - 327
GET /dist/app1.js 200 6.890 ms - 1387
GET /dist/vendors.js 200 10.638 ms - 62326
# 首次请求微应用 2
# vendors.js 命中 304 缓存
GET /app2.html 200 1.819 ms - 327
GET /dist/vendors.js 304 3.722 ms - -
GET /dist/app2.js 200 9.547 ms - 1387
```

> 温馨提示：为了模拟首次请求的情况，防止命中缓存，可以将 `dist` 目录下的资源删除后重新生成（包括 `app1.html` 和 `app2.html`）。

首次访问微应用 1 时所有资源返回状态码 200：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9d013c24ea4e2db5da66419c0fe881~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=481&s=65930&e=png&b=fefefe)

首次访问微应用 2 时 `vendors.js` 命中 304 缓存：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a15fe0119ca4fbdae7e6b0e1dc5bbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=481&s=69163&e=png&b=fefefe)

我们可以计算一下两个微应用首次请求资源的情况：

``` bash
# 首次请求微应用 1
app1.html：559 B
vendors.js：62.6 kB
app1.js：1.6 kB
应用 1 的总请求：559 + (62.6 + 1.6) * 1024 = 66299.8 B（64.7 kB）
# 首次请求微应用 2
app2.html：559 B
vendors.js：186 kB
app2.js：1.6 kB
应用 2 的总请求：559 + 186 + 1.6 * 1024 = 2383.4 B（2.3 kB）
```

在真实的业务场景中我们往往需要修改应用的业务代码，此时如果 `node_modules` 没有新增任何库包，例如：

``` javascript
// src/app1.js
import { createApp, ref, h } from "vue";

createApp({
  setup() {
    // 更改渲染内容 1 为 11
    const message = ref('Hello App 11');
    return () => h("div", message.value);
  },
}).mount("#app");


// src/app2.js
import { createApp, ref, h } from "vue";

createApp({
  setup() {
    // 更改渲染内容 2 为 22
    const message = ref('Hello App 22');
    return () => h("div", message.value);
  },
}).mount("#app");
```

构建代码后访问对应的应用，如下所示：

``` bash
# 执行
npm run start

# 打印
> webpack-runtime-analyze@1.0.0 start
> node server.js

server start at http://localhost:4000/
# 首次请求微应用 1
# app1.html 和 vendors.js 命中 304 缓存
GET /app1.html 304 7.847 ms - -
GET /dist/vendors.js 304 9.076 ms - -
# 首次请求微应用 2
# app2.html 和 vendors.js 命中 304 缓存
GET /dist/app1.js 200 10.146 ms - 1388
GET /app2.html 304 1.123 ms - -
GET /dist/vendors.js 304 0.721 ms - -
GET /dist/app2.js 200 3.627 ms - 1388
```

首次访问微应用 1 和微应用 2 时 `vendors.js` 都会命中 304 缓存：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf780d797f643868d7bdd9b0726eb8e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=481&s=69114&e=png&b=fefefe)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a66fcaedc74d4f6a8bf6f9ded0e05520~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=481&s=69905&e=png&b=fefefe)

我们可以总结一下上述这些示例的首屏加载情况，如下所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf4441beefc34494ae87814cecadcae2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=681&h=177&s=32473&e=png&b=fefefe)

从上述表格中可以发现，如果没有进行代码分割，应用 1 和应用 2 的代码在首次加载时无法做到性能优化，并且每次构建都会因为构建脚本的变化而无法命中服务器缓存。而进行代码分割后，首先分割后的通用代码可以在第二次加载时命中缓存，并且如果再次构建后通用代码没有发生变化，则可以在后续的使用中继续命中服务缓存，从而节省应用的首屏加载时间。

### 按需加载

多入口配置主要应用于 MPA 场景，旨在多个应用中分割出可复用的代码，从而节省应用总体积的同时，增加复用代码的缓存命中率，实现优化首屏加载的性能。除此之外，我们也可以考虑在单个应用中考虑分割代码，例如按路由加载资源，从而继续减少首屏加载的体积。我们在应用 1 的基础上进行修改，示例代码的目录结构如下所示：


``` bash
.
├── public              # 静态资源托管目录
│   ├── dist            # 构建目录
│   │   └── app1.js         
│   └── app1.html       
├── src                 # 源文件目录
│   └── app1.js         # 微应用 2 源码
├── server.js           # 启动服务          
├── package.json        # 项目描述文件
└── webpack.config.js   # webpack 配置文件
```


首先根据 Vue Router 官方文档的[入门](https://router.vuejs.org/zh/guide/)，我们将 Vue 和 Vue Router 通过 CDN 的方式引入，`app1.html` 的代码如下所示：

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App1</title>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="https://unpkg.com/vue-router@4"></script>
  </head>
  <body>
    <div id="app">
      <h1>Hello App!</h1>
      <p>
        <!--使用 router-link 组件进行导航 -->
        <!--通过传递 `to` 来指定链接 -->
        <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->
        <router-link to="/">Go to Home</router-link>
        <router-link to="/about">Go to About</router-link>
      </p>
      <!-- 路由出口 -->
      <!-- 路由匹配到的组件将渲染在这里 -->
      <router-view></router-view>
    </div>
    <!-- 声明需要匹配路由的组件 -->
    <script src="./dist/app1.js"></script>
  </body>
</html>
```

根据文档在 `src/app1.js`中声明需要匹配路由的组件，如下所示：

``` javascript
// 1. 定义路由组件.
// 也可以从其他文件导入
import About from './about.js'
const Home = { template: '<div>Home</div>' }

// 2. 定义一些路由
// 每个路由都需要映射到一个组件。
const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
]

// 3. 创建路由实例并传递 `routes` 配置
// 你可以在这里输入更多的配置，但我们在这里
// 暂时保持简单
const router = VueRouter.createRouter({
  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
  history: VueRouter.createWebHashHistory(),
  routes, // `routes: routes` 的缩写
})

// 5. 创建并挂载根实例
const app = Vue.createApp({})
//确保 _use_ 路由实例使
//整个应用支持路由。
app.use(router)

app.mount('#app')

// 现在，应用已经启动了！
```

其中 `about.js` 是一个体积较大的[组件](https://github.com/ziyi2/webpack-runtime-analyze/blob/demo/import/src/about.js)，如下所示：

``` jsx
export default {
  template: `<div>
  About
  About
  // 省略 1 万行
  About
  </div>`,
};
``` 

修改 Webpack 的 `webpack.config.js` 文件：

``` javascript
// 用于分析构建产物
const BundleAnalyzerPlugin =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
const path = require("path");

module.exports = {
  mode: "production",
  entry: {
    app1: "./src/app1.js",
    // app2: "./src/app2.js",
  },
  output: {
    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹
  },
  plugins: [new BundleAnalyzerPlugin()]
};
```

在项目的根目录执行 `npm run build` 后会在 `public/dist` 目录下生成构建文件：

``` bash
# 执行
npm run build                                                                           

# 打印
> webpack-runtime-analyze@1.0.0 build
> webpack

No bundles were parsed. Analyzer will show only original module sizes from stats file.
# 构建产物的可视化分析访问地址
Webpack Bundle Analyzer is started at http://127.0.0.1:8888
Use Ctrl+C to close it
# 生成 app1.js，大小为 88.8 KiB
asset app1.js 88.8 KiB [compared for emit] [minimized] (name: app1)
orphan modules 78.8 KiB [orphan] 1 module
./src/app1.js + 1 modules 79.7 KiB [built] [code generated]
webpack 5.89.0 compiled successfully in 155 ms
```

使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对构建产物进行可视化分析，其中 `about.js` 没有被分割出来，其大小为 78.8 KiB， 如下所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86fc28d852243858269c090eccdf5ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1888&s=1674610&e=png&b=92d4ba)

执行 `node server.js` 启动服务，访问对应的应用，如下所示：

``` bash
# 执行
npm run start                                                                          

# 打印
> webpack-runtime-analyze@1.0.0 start
> node server.js

server start at http://localhost:4000/
# 首次请求微应用 1
GET /app1.html 200 10.147 ms - 865
GET /dist/app1.js 200 0.849 ms - 90977
```

首次请求应用时会先加载 `app1.js`，如下所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d54a0cede34d96b2859490405bfb02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1736&h=1084&s=244998&e=png&b=fefefe)

上述示例不论是否会点击 Go to About 对应的路由，都会在首次加载应用时加载路由对应的资源，因为 Webpack 构建后会将 `src/about.js` 对应的资源构建到 `dist/app1.js` 中。如果用户进入后不会点击 Go to About 对应的路由，那么加载路由相应组件资源 `src/about.js` 对于加载首屏而言就是一种多余请求。

我们可以修改源代码，从而可以利用 Webpack 的代码分割能力将 `src/about.js` 抽离出来，并且只在点击 Go to About 对应的路由时按需动态加载 `src/about.js` 对应的构建资源。我么可以修改 `src/app1.js` 源码，如下所示：

``` javascript
const Home = { template: '<div>Home</div>' }

const routes = [
  { path: '/', component: Home },
  // 详见
  // https://webpack.docschina.org/api/module-methods 
  // https://webpack.docschina.org/guides/code-splitting/#dynamic-imports
  // 调用 import() 被视为分割点，意思是，被请求的模块和它引用的所有子模块，会分割到一个单独的 chunk 中
  // 使用 /* webpackChunkName: "about" */ 注释可以使得分割后的 chunk 文件命名为 about.js
  { path: '/about', component: () => import(/* webpackChunkName: "about" */ './about.js')},
]

const router = VueRouter.createRouter({
  history: VueRouter.createWebHashHistory(),
  routes, // `routes: routes` 的缩写
})


const app = Vue.createApp({})

app.use(router)

app.mount('#app')
```

> 示例源码可以从 webpack-runtime-analyze 的 [demo/import](https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/import) 分支获取。

在项目的根目录执行 `npm run build` 后会在 `public/dist` 目录下生成构建文件：

``` bash
# 执行
npm run build

# 打印
> webpack-runtime-analyze@1.0.0 build
> webpack

Webpack Bundle Analyzer is started at http://127.0.0.1:8888
Use Ctrl+C to close it
# 生成 about.js，大小为 88.8 KiB
asset about.js 88.8 KiB [compared for emit] [minimized] (name: about)
# 生成 app1.js，大小为 2.79 KiB
asset app1.js 2.79 KiB [compared for emit] [minimized] (name: app1)
runtime modules 6.75 KiB 9 modules
cacheable modules 80 KiB
  ./src/app1.js 1.19 KiB [built] [code generated]
  ./src/about.js 78.8 KiB [built] [code generated]
webpack 5.89.0 compiled successfully in 163 ms
```

使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对构建产物进行可视化分析，其中 `about.js` 被分割出来，其大小为 88.8 KiB， 如下所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e352177acd341b08380fa33ff08e642~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1888&s=1886663&e=png&b=cea67e)

需要注意手动分离复用代码和使用 `import()` 实现自动分离存在一定的差异，手动分离需要将分离的脚本地址手动添加到 HTML 文件中进行加载，而通过 `import()` 自动分离的脚本则不需要 HTML 做任何处理，因为其内部本质就是利用 `<script>` 标签进行动态加载（接下来会讲解 Webpack 运行时原理），此时我们启动服务访问应用，会发现首次加载 `app1.js` 时资源非常小，点击 Go to About 路由时才会按需动态加载 `about.js`，从而相对于之前的示例在首屏加载时节省了加载资源：

![录屏2024-03-05 19.37.52.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da3f18ee5f44d119848ef9ef7503bde~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1768&h=1180&s=769628&e=gif&f=102&b=fdfdfd)

## 代码分割的运行时原理

在 qiankun 官方文档[配置微应用的打包工具](https://qiankun.umijs.org/zh/guide/getting-started#2-%E9%85%8D%E7%BD%AE%E5%BE%AE%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7)说明中需要进行如下 Webpack 配置：

``` javascript
// webpack 5.x
const packageName = require('./package.json').name;

module.exports = {
  output: {
    // library 和 libraryTarget 用于暴露微应用的生命周期函数
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    // chunkLoadingGlobal 用于代码分割
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
};

// webpack 4.x
const packageName = require('./package.json').name;


module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  },
};
```

其中为了让主应用能识别微应用暴露出来的生命周期函数，需要配置 `library` 和 `libraryTarget`，这两个配置以及对应的 Webpack 运行时原理已经在上一个课程中讲解。本课程主要讲解和代码分割息息相关的 `chunkLoadingGlobal` 配置。

为了简化大家对于 Webpack 运行时的原理，在这里基于上一个课程的 Webpack 示例进行讲解，示例代码的目录结构如下所示：

``` bash
.
├── dist                        # 构建目录
│   ├── index.js                # 构建入口文件
│   └── src_single-spa_js.js    # 构建分离 chunk
├── src                         # 源文件目录
│   ├── index.js                 # 入口文件
│   └── single-spa.js           # 被动态导入的文件
├── index.html                  # 网页代码，用于运行构建代码进行测试
├── package.json                # 项目描述文件
└── webpack.config.js           # Webpack 配置文件
```

> 温馨提示：示例源码可以从 webpack-runtime-analyze 的 [demo/chunkLoadingGlobal](https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/chunkLoadingGlobal) 分支获取。

如果在 `src/main.js` 中通过 ES 模块引入 `src/single-spa.js` 中的代码，那么 Webpack 构建时只会生成单个 Bundle 文件 `dist/main.js`。如果在 `src/main.js` 中通过 `import()` 动态导入 `src/single-spa.js`，那么 Webpack 在构建时会自动对引入的 `single-spa.js` 进行代码分割，从而生成新的 chunk 文件 `dist/src_single-spa_js.js`。动态导入的源代码如下所示：

``` javascript
// src/index.js
// 使用 import { bootstrap } from './single-spa.js' 引入时只会构建单个 Bundle
// 这里采用 import('./single-spa.js') 进行动态导入，会自动分离 chunk 文件
import("./single-spa.js").then((res) => {
  console.log(res);
});

// src/single-spa.js
export async function bootstrap() {
  console.log("bootstrap");
}

export async function mount() {
  console.log("mount");
}

export async function unmount() {
  console.log("unmount");
}

export async function update() {
  console.log("update");
}
```

在 Webpack 中新增 `chunkLoadingGlobal` 配置，如下所示：

``` javascript
const packageName = require("./package.json").name;

module.exports = {
  output: {
    library: "myLibrary",
    libraryTarget: "umd",
    // 代码分割配置
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
};index
```

在 `index.html` 中引入构建后的脚本，如下所示：

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="dist/main.js"></script>
  </body>
</html>
```

在浏览器中打开 `index.html` 执行后查看打印信息，可以发现 `import()` 的 Promise 回调中可以获取到 `src/single-spa.js` 导出的生命周期函数，除此之外 `single-spa.js` 中的代码被分离到了独立的 chunk 文件 `dist/src_single-spa_js.js` 中：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b469825b25841df9d60773ed6d43240~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2088&h=760&s=730301&e=png&b=fefefe)

`promise.then` 中打印的生命周期函数如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2eab4c786884ee898a2a89aa9787b6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2088&h=762&s=639690&e=png&b=fefefe)


在上一个课程中我们讲解了 `output.library` 的运行时原理，这里和直接暴露库属性的构建代码存在一些差异，在暴露库属性的构建代码中只有一个 `src/index.js` ES 模块，因此只需要执行对应的模块化包装函数并返回模块化导出对象 `__webpack_exports__` 即可，而在这个动态导入的示例中存在 `src/index.js` 和 `src/single-spa.js` 两个模块，并且 `single-spa.js` 所在的模块是一个需要异步加载的 chunk 文件。执行的大致流程包含：

- `src/index.js` 模块化包装函数的执行，返回对应的模块化导出对象 `__webpack_exports__`
- `src/index.js` 动态导入 `src/single-spa.js` 对应的构建 chunk 的动态加载和执行
- `src/single-spa.js` 模块化包装函数的执行，返回对应的模块化导出对象
- `src/index.js` 动态导入的 `promise.then` 获取 `src/single-spa.js` 对应的模块化导出对象

我们重点来分析一下 `dist/main.js` 的构建代码，去除 Webpack 自带的注释后如下所示：

``` javascript
// dist/main.js
(function webpackUniversalModuleDefinition(root, factory) {
  // UMD 规范的代码，支持 CommonJS、AMD 和浏览器运行环境
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  else if (typeof define === "function" && define.amd) define([], factory);
  else if (typeof exports === "object") exports["myLibrary"] = factory();
  // 如果在浏览器中通过 <script> 标签引入，那么这里的代码会被执行
  // root 是全局对象，例如在浏览器中就是 window
  else root["myLibrary"] = factory();
})(self, () => {
  return (() => {
    // webpackBootstrap
    // 这里是模块化路径对应的模块化包装函数，上一节课中已经详细讲解
    var __webpack_modules__ = {
      "./src/index.js": (
        __unused_webpack_module,
        __unused_webpack_exports,
        __webpack_require__
      ) => {
        eval(
          "// 使用 import { bootstrap } from './single-spa.js' 引入时只会构建单个 Bundle\n// 这里采用 import('./single-spa.js') 进行动态导入，会自动分离 chunk 文件\n__webpack_require__.e(/*! import() */ \"src_single-spa_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./single-spa.js */ \"./src/single-spa.js\")).then((res) => {\n  console.log(res);\n});\n\n//# sourceURL=webpack://myLibrary/./src/index.js?"
        );
      },
    };

    // The module cache
    // 模块化缓存对象
    var __webpack_module_cache__ = {};

    // The require function
    // 该函数的作用是根据模块路径加载模块
    function __webpack_require__(moduleId) {
      // Check if module is in cache
      // 检查模块是否在缓存中
      // 如果在缓存中，则直接返回缓存中的模块导出值
      // 可以想象一下模块被导入多次后，这里会有什么作用？
      var cachedModule = __webpack_module_cache__[moduleId];
      if (cachedModule !== undefined) {
        return cachedModule.exports;
      }
      // Create a new module (and put it into the cache)
      // 创建一个新的模块，并将其放入缓存中
      var module = (__webpack_module_cache__[moduleId] = {
        // no module.id needed
        // no module.loaded needed
        exports: {},
      });

      // Execute the module function
      // 执行模块化包装函数
      __webpack_modules__[moduleId](
        module,
        module.exports,
        __webpack_require__
      );

      // Return the exports of the module
      // 返回模块导出值
      return module.exports;
    }

    // expose the modules object (__webpack_modules__)
    // 将 __webpack_modules__ 赋值给 __webpack_require__.m
    __webpack_require__.m = __webpack_modules__;

    /* webpack/runtime/define property getters */
    (() => {
      // define getter functions for harmony exports
      
      // 函数作用
      // 用于定义 harmony 模块（ES2015 模块）的 exports 导出对象
      // 将源文件模块导出的对象赋值给模块化导出对象 __webpack_exports__

      // 参数说明
      // exports： 模块化导出对象 __webpack_exports__
      // definition： 源文件中的导出对象（例如 src/index.js 中导出的生命周期函数）

      // 举个例子
      // 如果在 src/index.js 中导出了 bootstrap、mount、unmount、update 四个函数
      // 那么 definition 对象就是 { bootstrap, mount, unmount, update }
      __webpack_require__.d = (exports, definition) => {
        // 遍历源文件中导出对象的属性
        for (var key in definition) {
          if (
            // 检查 definition 对象是否有 key 属性
            // 检查 exports 对象是否有 key 属性
            __webpack_require__.o(definition, key) &&
            !__webpack_require__.o(exports, key)
          ) {
            // 为 exports 对象定义 key 属性，属性值为 definition 对象的 key 属性值
            // 即将 src/index.js 中导出的 bootstrap 等函数添加到 __webpack_exports__ 对象中
            Object.defineProperty(exports, key, {
              // enumerable: true 表示该属性可以被枚举
              enumerable: true,
              // 设置 getter 函数，该函数返回 definition 对象的 key 属性值
              get: definition[key],
            });
          }
        }
      };
    })();

    /* webpack/runtime/ensure chunk */
    (() => {
      // __webpack_require__.f 内部存储了所有的加载器处理函数
      __webpack_require__.f = {};
      // This file contains only the entry chunk.
      // The chunk loading function for additional chunks
      // 该函数会在 ./src/index.js 中执行 __webpack_require__.e(/*! import() */ "src_single-spa_js") 时调用
      // 用于对 chunk 进行加载器的批量处理,
      // 在这个示例中主要用于异步加载 chunk 文件（src_single-spa_js）
      __webpack_require__.e = (chunkId) => {
        return Promise.all(
        
          // Object.keys(__webpack_require__.f) 获取所有的加载器
          // 这些加载器用于处理不同类型的模块,
          // 例如处理动态 script 加载的是 __webpack_require__.f.j
          
          // 在 reduce 的回调函数中，每个加载器都会被调用
          // 传入 chunkId 和 promises 两个参数
          
          // 加载器的任务就是根据 chunkId 加载对应的模块
          // 并将加载的结果（通常是一个 Promise 对象）添加到 promises 数组中
          
          // 最后，Promise.all 会等待 promises 处理完成，然后返回一个新的 Promise 对象
          // 这个新的 Promise 对象在所有加载器执行完成时解析
          // 如果有任何加载器执行失败，则会被拒绝。
          Object.keys(__webpack_require__.f).reduce((promises, key) => {
            // 调用加载器，如果加载器是 __webpack_require__.f.j
            // 那么就会调用 __webpack_require__.f.j(chunkId, promises)
            __webpack_require__.f[key](chunkId, promises);
            // 返回 promises 数组用于下一次迭代
            return promises;
          }, [])
        );
      };
    })();

    /* webpack/runtime/get javascript chunk filename */
    (() => {
      // This function allow to reference async chunks
      // 主要作用是计算 chunk 文件名
      __webpack_require__.u = (chunkId) => {
        // return url for filenames based on template
        return "" + chunkId + ".js";
      };
    })();

    /* webpack/runtime/global */
    (() => {
      // 主要作用是计算 window 全局对象并将其赋值给 __webpack_require__.g
      __webpack_require__.g = (function () {
        if (typeof globalThis === "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e) {
          if (typeof window === "object") return window;
        }
      })();
    })();

    /* webpack/runtime/hasOwnProperty shorthand */
    (() => {
      // 函数名称
      // __webpack_require__.o

      // 函数作用
      // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）

      // 参数说明
      // obj： 需要被检查的对象
      // prop： 需要被检查的属性
      __webpack_require__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop);
    })();

    /* webpack/runtime/load script */
    (() => {
      var inProgress = {};
      var dataWebpackPrefix = "myLibrary:";
      // loadScript function to load a script via script tag
      // 主要作用是通过创建和插入一个 <script> 标签来动态加载一个 chunk 文件
      __webpack_require__.l = (url, done, key, chunkId) => {
        // 首先检查给定的 URL 是否已经在加载中
        // 如果是在加载中，将回调函数添加到回调函数列表中，并立即返回
        if (inProgress[url]) {
          inProgress[url].push(done);
          return;
        }
        var script, needAttach;
        if (key !== undefined) {
          // 如果 key 参数存在，则检查是否已经存在对应的 <script> 标签
          var scripts = document.getElementsByTagName("script");
          for (var i = 0; i < scripts.length; i++) {
            var s = scripts[i];
            if (
              s.getAttribute("src") == url ||
              s.getAttribute("data-webpack") == dataWebpackPrefix + key
            ) {
              script = s;
              break;
            }
          }
        }
        if (!script) {
          // 如果没有找到具有相同 key 属性值的 <script> 标签，则创建一个新的 <script> 标签
          needAttach = true;
          script = document.createElement("script");

          script.charset = "utf-8";
          // 设置超时时间为 120 秒
          script.timeout = 120;
          // 如果 __webpack_require__.nc 存在
          // 那么就设置 <script> 标签的 nonce 属性值为 __webpack_require__.nc
          if (__webpack_require__.nc) {
            script.setAttribute("nonce", __webpack_require__.nc);
          }
          // 设置 data-webpack 属性值为 "myLibrary:chunk-src_single-spa_js"
          // 这个属性值是用于标记 <script> 是否被创建
          script.setAttribute("data-webpack", dataWebpackPrefix + key);
          // 设置 <script> 标签的 src 属性值为 url
          script.src = url;
        }
        inProgress[url] = [done];
        // onScriptComplete 函数的作用是清理加载过程中创建的资源
        // 防止内存泄漏，并调用所有注册的回调函数
        var onScriptComplete = (prev, event) => {
          // avoid mem leaks in IE.
          script.onerror = script.onload = null;
          clearTimeout(timeout);
          var doneFns = inProgress[url];
          delete inProgress[url];
          // 删除 <script> 标签
          script.parentNode && script.parentNode.removeChild(script);
          // 遍历所有的回调函数，进行调用
          doneFns && doneFns.forEach((fn) => fn(event));
          if (prev) return prev(event);
        };
        // 创建一个超时定时器，用于检测加载是否超时
        var timeout = setTimeout(
          onScriptComplete.bind(null, undefined, {
            type: "timeout",
            target: script,
          }),
          120000
        );
        script.onerror = onScriptComplete.bind(null, script.onerror);
        script.onload = onScriptComplete.bind(null, script.onload);
        // 将 <script> 标签添加到文档的 <head> 中进行 chunk 的动态加载
        needAttach && document.head.appendChild(script);
      };
    })();

    /* webpack/runtime/make namespace object */
    (() => {
      // define __esModule on exports
      // 函数名称
      // __webpack_require__.r

      // 函数作用
      // 该函数用于定义 ES6 模块的标准行为
      // 即为模块化导出对象 __webpack_exports__ 定义 __esModule 属性值等
      // 可用于识别 __webpack_exports__ 的模块性质

      // 参数说明
      // exports： 模块化导出对象 __webpack_exports__
      __webpack_require__.r = (exports) => {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          // 为 exports 对象定义属性 Symbol.toStringTag，值为 "Module"
          // Symbol.toStringTag：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag
          // ES6 模块的标准行为
          // Object.prototype.toString.call(exports) = "[object Module]"
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module",
          });
        }
        // exports.__esModule = true
        // 这是一个约定，用于标记这个模块是一个 ES 模块。
        // 其他模块在导入该模块时可以知道它是一个 ES 模块，从而使用正确的导入语法
        Object.defineProperty(exports, "__esModule", { value: true });
        
        // 为什么使用 Object.defineProperty 而不是直接 exports.__esModule = true 呢？ 
        // 因为 Object.defineProperty 有一个特性 configurable 
        // 当 configurable 为 false 时，该属性不可被删除，也不可被修改 
        // 这样可以防止其他模块修改 __esModule 的值，从而保证了 __esModule 的值为 true 
        // Object.defineProperty 被用于在 exports 对象上定义 __esModule 属性， 
        // 这个属性是不可枚举的，这意味着它不会出现在 for-in 循环或 Object.keys 方法中。 
        // 这个属性也是不可写的，这意味着你不能改变它的值。 
        // 这些特性都是通过 Object.defineProperty 方法来实现的 
        // { configurable: false, enumerable: false, value: true, writable: false } 
        console.log(Object.getOwnPropertyDescriptor(exports, "__esModule"));
      };
    })();

    /* webpack/runtime/publicPath */
    // 这个函数的主要作用是确定 Webpack 的公共路径（publicPath）
    // 这是 Webpack 用来确定异步加载的模块的 URL 的基础路径
    (() => {
      var scriptUrl;
      // 判断 Web Worker 环境
      // 函数首先检查全局对象（__webpack_require__.g）是否有 importScripts 方法
      // 将 scriptUrl 设置为全局对象的 location 属性的字符串表示
      if (__webpack_require__.g.importScripts)
        scriptUrl = __webpack_require__.g.location + "";
      var document = __webpack_require__.g.document;
      // 判断浏览器环境
      // 获取全局对象的 document 属性，
      // 如果 scriptUrl 还没有被设置
      // 并且 document 存在
      // 那么它将尝试从 document.currentScript.src 获取 scriptUrl
      if (!scriptUrl && document) {
        if (document.currentScript) scriptUrl = document.currentScript.src;
        if (!scriptUrl) {
          var scripts = document.getElementsByTagName("script");
          // 如果 scriptUrl 还没有被设置
          // 那么函数将获取页面上所有的 <script> 标签，并从最后一个标签开始向前遍历
          // 直到找到一个具有 src 属性的标签并将 src 属性的值设置为 scriptUrl
          if (scripts.length) {
            var i = scripts.length - 1;
            while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
          }
        }
      }
      // When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
      // or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
      // 如果函数无法确定 scriptUrl
      // 那么它将抛出一个错误，因为在这种情况下
      // Webpack 无法自动确定公共路径
      if (!scriptUrl)
        throw new Error(
          "Automatic publicPath is not supported in this browser"
        );
      // 将 scriptUrl 清理（移除哈希和查询参数，以及最后一个斜杠后的所有内容）
      // 并将其设置为 Webpack 的公共路径（__webpack_require__.p）
      scriptUrl = scriptUrl
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/");
      __webpack_require__.p = scriptUrl;
    })();

    /* webpack/runtime/jsonp chunk loading */
    (() => {
      // no baseURI

      // object to store loaded and loading chunks
      // undefined = chunk not loaded, null = chunk preloaded/prefetched
      // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
      
      // installedChunks 对象存储了已加载和正在加载的模块。其值的含义如下：
      // undefined：模块未加载
      // [resolve, reject, Promise]：模块正在加载
      // 0：模块已加载
      var installedChunks = {
        main: 0,
      };

      // 1. 初始化异步 chunk 文件的加载状态 installedChunks
      // 当异步 chunk 文件所在的 <script> 加载完成后
      // 会在 webpackJsonpCallback 中进行 promise.resolve 和 installedChunks[chunkId] = 0 处理
      
      // 2. 执行 __webpack_require__.l 函数
      // 动态创建 <script> 标签，加载分离的 chunk 代码块
      __webpack_require__.f.j = (chunkId, promises) => {
        // JSONP chunk loading for javascript
        // 获取当前 chunkId 对应的模块加载状态信息
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId)
          ? installedChunks[chunkId]
          : undefined;
          
        // 对应的模块是否已经被加载。如果已经被加载，则不做任何事情
        if (installedChunkData !== 0) {
          // 0 means "already installed".

          // a Promise means "currently loading".
          // 如果 installedChunkData 存在，且 installedChunkData 不为 0
          // 那么就说明当前模块正在加载中
          if (installedChunkData) {
            promises.push(installedChunkData[2]);
          // 否则说明当前模块未加载
          } else {
            if (true) {
              // all chunks have JS
              // setup Promise in chunk cache
              
              // 创建一个新的 Promise
              
              // 给当前即将需要加载的 chunk 文件创建一个 Promise 对象
              // 并将其添加到 promises 数组中
              
              // installedChunks[chunkId] 的值是一个数组
              // 数组的第一个元素是 Promise 的 resolve 函数
              
              // 第二个元素是 Promise 的 reject 函数
              // 用于表明当前的 chunkId 对应的 chunk 文件正在加载
              var promise = new Promise(
                (resolve, reject) =>
                  (installedChunkData = installedChunks[chunkId] =
                    [resolve, reject])
              );
              
              // installedChunks[chunkId] 的第三个元素是 Promise 对象
              promises.push((installedChunkData[2] = promise));

              // start chunk loading
              // 计算 chunk 的 URL
              var url = __webpack_require__.p + __webpack_require__.u(chunkId);
              // create error before stack unwound to get useful stacktrace later
              
              // 在开始加载模块之前，它会创建一个新的 Error 对象
              // 这个 Error 对象会在加载结束后用于处理可能的错误
              var error = new Error();
              
              // 1. 如果 <script> 加载失败，
              // 那么 installedChunkData 的状态仍然是 [resolve, reject, Promise]
              // 此时触发 script.onerror 执行 loadingEnded 函数重置加载状态
              
              // 2. 如果 <script> 加载成功，
              // 那么会先执行 webpackJsonpCallback 设置 installedChunkData 的加载状态为 0，
              //然后触发 script.onload 执行 loadingEnded 函数
              
              // 3. 如果超时，那么 installedChunkData 的状态仍然是 [resolve, reject, Promise]，
              // 会触发定时器执行 loadingEnded 函数重置加载状态
              var loadingEnded = (event) => {
                if (__webpack_require__.o(installedChunks, chunkId)) {
                  installedChunkData = installedChunks[chunkId];
                  
                  // 如果 installedChunkData 不为 0
                  // 那么将 installedChunks[chunkId] 设置为 undefined（模块未加载）
                  
                  // 下次加载该 chunk 文件时会重新加载,
                  // 这样可以避免加载失败的模块一直加载失败（例如超时重试）
                  if (installedChunkData !== 0)
                    installedChunks[chunkId] = undefined;
                    
                  // 失败处理
                  if (installedChunkData) {
                    var errorType =
                      event && (event.type === "load" ? "missing" : event.type);
                    // realSrc 是失败的模块的 URL，它从事件 target 的 src 属性中获取
                    var realSrc = event && event.target && event.target.src;
                    error.message =
                      "Loading chunk " +
                      chunkId +
                      " failed.\n(" +
                      errorType +
                      ": " +
                      realSrc +
                      ")";
                    error.name = "ChunkLoadError";
                    error.type = errorType;
                    error.request = realSrc;
                    // 使用 installedChunkData[1]（即 Promise 的 reject 函数）来处理错误
                    installedChunkData[1](error);
                  }
                }
              };
              
              // 通过动态 Script 标签加载分离的 chunk 代码块
              __webpack_require__.l(
                url,
                loadingEnded,
                "chunk-" + chunkId,
                chunkId
              );
            }
          }
        }
      };

      // no prefetching

      // no preloaded

      // no HMR

      // no HMR manifest

      // no on chunks loaded

      // install a JSONP callback for chunk loading
      
      // 当异步 chunk 文件所在的 <script> 加载完成后，会触发该函数执行
      // 该函数的作用是将 chunk 文件的模块映射对象合并到现有的模块映射对象 __webpack_require__.m
      // 并将 installedChunks[chunkId] 设置为 0，表示该模块加载完成
      var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
      
        // chunkIds（chunkId 数组）
        
        // moreModules（chunk 文件映射对象，和 __webpack_require__.m 
        // 以及 __webpack_modules__ 的结构一样）
        
        // runtime（暂时忽略，这里没有使用到）
        var [chunkIds, moreModules, runtime] = data;
        // add "moreModules" to the modules object,
        // then flag all "chunkIds" as loaded and fire callback
        var moduleId,
          chunkId,
          i = 0;
          
        // 检查 chunkIds 中是否有模块尚未加载（installedChunks[id] !== 0）
        // 将 moreModules 中未加载的模块添加到模块映射对象 __webpack_require__.m 中
        if (chunkIds.some((id) => installedChunks[id] !== 0)) {
          for (moduleId in moreModules) {
            // 判断 moreModules 中是否有 moduleId 属性
            if (__webpack_require__.o(moreModules, moduleId)) {
                // 将 moreModules 中的模块映射对象合并到
                // 现有的模块映射对象 __webpack_require__.m 中
              __webpack_require__.m[moduleId] = moreModules[moduleId];
            }
          }
          
          // 在本示例中没有 runtime 函数，所以这里不会执行
          if (runtime) var result = runtime(__webpack_require__);
        }
        
        // 如果 chunkLoadingGlobal.push 函数存在
        // 则将 chunk 文件对应的 data 数据添加到 chunkLoadingGlobal 中
        // 即添加到 window.webpackJsonp_webpack-runtime-analyze 数组中
        if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
        
        // 函数遍历 chunkIds，
        // 如果 installedChunks[chunkId] 为 [resolve, reject, Promise]
        // 说明当前模块的状态为加载中
        
        // 执行 installedChunks[chunkId][0]()
        // 即执行 __webpack_require__.f.j 中创建的 Promise 对象的 resolve 函数
        
        // 然后将 installedChunks[chunkId] 设置为 0，表示该模块加载完成
        for (; i < chunkIds.length; i++) {
          chunkId = chunkIds[i];
          if (
            __webpack_require__.o(installedChunks, chunkId) &&
            installedChunks[chunkId]
          ) {
            installedChunks[chunkId][0]();
          }
          installedChunks[chunkId] = 0;
        }
      };


      // 重点：Webpack 的 output.chunkLoadingGlobal 的配置值在此生效
      // output.chunkLoadingGlobal = webpackJsonp_webpack-runtime-analyze
      
      // 这行代码创建了一个全局数组 chunkLoadingGlobal（即 window.webpackJsonp_webpack-runtime-analyze）
      // 用于存储所有的 chunk 文件的数据
      var chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =
        self["webpackJsonp_webpack-runtime-analyze"] || []);
      // 这行代码遍历 chunkLoadingGlobal 中的每个元素
      // 对每个元素执行 webpackJsonpCallback 函数
      chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
      
      // 重写 chunkLoadingGlobal.push 方法
      // 当执行 chunkLoadingGlobal.push 方法时
      // 会自动执行 webpackJsonpCallback 函数
      
      // 在 chunk 文件所在的 <script> 加载完成后
      // 会触发 chunk 文件中的 chunkLoadingGlobal.push 方法执行
      // 从而触发 webpackJsonpCallback 函数执行
      chunkLoadingGlobal.push = webpackJsonpCallback.bind(
        null,
        chunkLoadingGlobal.push.bind(chunkLoadingGlobal)
      );
    })();

    // startup
    // Load entry module and return exports
    // This entry module can't be inlined because the eval devtool is used.
    var __webpack_exports__ = __webpack_require__("./src/index.js");

    return __webpack_exports__;
  })();
});

```

由于上述代码过于复杂，在这里可以做一下简化，如下所示：

``` javascript
// dist/main.js
(function webpackUniversalModuleDefinition(root, factory) {
  // UMD 规范的代码，支持 CommonJS、AMD 和浏览器运行环境
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  else if (typeof define === "function" && define.amd) define([], factory);
  else if (typeof exports === "object") exports["myLibrary"] = factory();
  // 如果在浏览器中通过 <script> 标签引入，那么这里的代码会被执行
  // root 是全局对象，例如在浏览器中就是 window
  else root["myLibrary"] = factory();
})(self, () => {
  return (() => {
    // webpackBootstrap
    // 这里是模块化路径对应的模块化包装函数，上一节课中已经详细讲解
    var __webpack_modules__ = {
      "./src/index.js": (
        __unused_webpack_module,
        __unused_webpack_exports,
        __webpack_require__
      ) => {
        eval(
          // src/index.js 的模块化处理源码
          "xxx"
        );
      },
    };

    // The module cache
    // 模块化缓存对象
    var __webpack_module_cache__ = {};

    // The require function
    // 该函数的作用是根据模块路径加载模块，如果有缓存则直接获取缓存对象
    function __webpack_require__(moduleId) {}

    // expose the modules object (__webpack_modules__)
    // 将 __webpack_modules__ 赋值给 __webpack_require__.m
    __webpack_require__.m = __webpack_modules__;

    /* webpack/runtime/define property getters */
    (() => {
      __webpack_require__.d = (exports, definition) => {};
    })();

    /* webpack/runtime/ensure chunk */
    (() => {
      // __webpack_require__.f 内部存储了所有的加载器处理函数
      // 例如 f.j 用于加载 script
      __webpack_require__.f = {};
      
      // This file contains only the entry chunk.
      // The chunk loading function for additional chunks
      // 该函数会在 ./src/index.js 中执行 
      // __webpack_require__.e(/*! import() */ "src_single-spa_js") 时调用
      
      // 用于对 chunk 进行加载器的批量处理,
      // 在这个示例中主要用于异步加载 chunk 文件（src_single-spa_js）
      __webpack_require__.e = (chunkId) => {
         // 这里会调用 __webpack_require__.f.j
      };
    })();

    /* webpack/runtime/get javascript chunk filename */
    (() => {
      // This function allow to reference async chunks
      // 主要作用是计算 chunk 文件名
      __webpack_require__.u = (chunkId) => {};
    })();

    /* webpack/runtime/global */
    (() => {
      // 主要作用是计算 window 全局对象并将其赋值给 __webpack_require__.g
      __webpack_require__.g = (function () {})();
    })();

    /* webpack/runtime/hasOwnProperty shorthand */
    (() => {
      // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）
      __webpack_require__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop);
    })();

    /* webpack/runtime/load script */
    (() => {
      var inProgress = {};
      var dataWebpackPrefix = "myLibrary:";
      // loadScript function to load a script via script tag
      
      // 主要作用是通过创建和插入一个 <script> 标签来动态加载一个 chunk 文件
      __webpack_require__.l = (url, done, key, chunkId) => {};
    })();

    /* webpack/runtime/make namespace object */
    (() => {
      
      // 该函数用于定义 ES6 模块的标准行为
      // 即为模块化导出对象 __webpack_exports__ 定义 __esModule 属性值等
      // 可用于识别 __webpack_exports__ 的模块性质
      __webpack_require__.r = (exports) => {}
      
    })();

    /* webpack/runtime/publicPath */
    // 这个函数的主要作用是确定 Webpack 的公共路径（publicPath）
    // 这是 Webpack 用来确定异步加载的模块的 URL 的基础路径
    (() => {
      var scriptUrl;
      // 省略计算过程
      __webpack_require__.p = scriptUrl;
    })();

    /* webpack/runtime/jsonp chunk loading */
    (() => {
      
      // installedChunks 对象存储了已加载和正在加载的模块。其值的含义如下：
      // undefined：模块未加载
      // [resolve, reject, Promise]：模块正在加载
      // 0：模块已加载
      var installedChunks = {
        main: 0,
      };

      // 1. 初始化异步 chunk 文件的加载状态 installedChunks
      // 当异步 chunk 文件所在的 <script> 加载完成后
      // 会在 webpackJsonpCallback 中进行 promise.resolve 和 installedChunks[chunkId] = 0 处理
      
      // 2. 执行 __webpack_require__.l 函数
      // 动态创建 <script> 标签，加载分离的 chunk 代码块
      __webpack_require__.f.j = (chunkId, promises) => {};

      // no prefetching

      // no preloaded

      // no HMR

      // no HMR manifest

      // no on chunks loaded

      // install a JSONP callback for chunk loading
      
      // 当异步 chunk 文件所在的 <script> 加载完成后，会触发该函数执行
      // 该函数的作用是将 chunk 文件的模块映射对象合并到现有的模块映射对象 __webpack_require__.m
      // 并将 installedChunks[chunkId] 设置为 0，表示该模块加载完成
      var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {};

      // 这行代码创建了一个全局数组 chunkLoadingGlobal
      // 即 window.webpackJsonp_webpack-runtime-analyze
      
      // 用于存储所有的 chunk 文件的数据
      var chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =
        self["webpackJsonp_webpack-runtime-analyze"] || []);
      // 这行代码遍历 chunkLoadingGlobal 中的每个元素
      // 对每个元素执行 webpackJsonpCallback 函数
      chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
      
      // 重写 chunkLoadingGlobal.push 方法
      // 当执行 chunkLoadingGlobal.push 方法时
      // 会自动执行 webpackJsonpCallback 函数
      
      // 在 chunk 文件所在的 <script> 加载完成后
      // 会触发 chunk 文件中的 chunkLoadingGlobal.push 方法执行
      // 从而触发 webpackJsonpCallback 函数执行
      chunkLoadingGlobal.push = webpackJsonpCallback.bind(
        null,
        chunkLoadingGlobal.push.bind(chunkLoadingGlobal)
      );
    })();

    // startup
    // Load entry module and return exports
    // This entry module can't be inlined because the eval devtool is used.
    // 执行 ./src/index.js 对应的模块化包装函数
    var __webpack_exports__ = __webpack_require__("./src/index.js");

    return __webpack_exports__;
  })();
});

```




其中 `src/index.js` 对应的模块化包装函数中的 `eval` 代码如下所示：

``` javascript
// 通过调用 __webpack_require__.e 函数
// 会动态创建 <script> 标签异步加载 chunk 文件 

// 内部会调用 __webpack_require__.f.j 函数
// 根据 chunkId 加载 chunk 文件

// 同时会标记 chunk 文件的加载状态
// 如果已经加载过，则不会重复加载（可以试试重复的动态导入）
__webpack_require__
  .e(/*! import() */ "src_single-spa_js")
  .then(
    // chunk 加载成功后
    // 会在 __webpack_modules__ 以及 __webpack_require__.m 模块化映射对象中
    // 建立新加载 chunk 的模块映射关系
    
    // 因此这里可以通过 __webpack_require__ 函数加载 chunk 文件
    // 并返回模块的 模块化导出 exports 对象
    __webpack_require__.bind(
      __webpack_require__,
      /*! ./single-spa.js */ "./src/single-spa.js"
    )
  )
  // 通过链式调用，可以获取到新加载的 chunk 文件的 exports 对象
  .then((res) => {
    // 这里的 res 就是 chunk 文件的 exports 对象
    console.log(res);
  });

//# sourceURL=webpack://myLibrary/./src/index.js?
```

我们先来分析一下主运行时代码 `dist/main.js`和 `src/index.js` 模块化包装函数中的 `eval`代码，如下所示：


-   通过 UMD 模式执行 `factory` 函数
-   定义模块化映射对象 `__webpack_modules__`(包含了 `src/index.js` 模块化包装代码)
-   定义模块化运行时函数 `__webpack_require__` （增加了模块的缓存处理）以及各种运行时方法
-   使用 `__webpack_modules__.m` 引用 `__webpack_modules__` 模块化映射对象
-   计算 `__webpack_require__.p` （计算拼装 chunk 文件 URL 需要的 `publicPath`）
-   声明 `webpackJsonpCallback` 函数，主要用于合并异步 chunk 文件的模块映射对象
-   开辟 `window.webpackJsonp_webpack-runtime-analyze` 数组，用于存放异步 chunk 文件的数据（包括 chunkId、模块映射对象等）
-   重写 `window.webpackJsonp_webpack-runtime-analyze.push`，使其指向 `webpackJsonpCallback` 函数
-   执行 `__webpack_require__` 获取 `src/index.js` 对应的模块化包装函数（内含`eval`代码）
    -   执行 `__webpack_require__.e` 动态加载 chunk 文件并标记模块的加载状态
    -   使用 `<script>` 标签加载 chunk 文件成功后，会立即执行 chunk 文件的脚本并调用 `window.webpackJsonp_webpack-runtime-analyze.push`，此时会将 chunk 对应的模块映射对象合并到 `__webpack_modules__.m` 中
    -   在 `then` 回调中执行 `__webpack_require__` 获取并执行 `src/single-spa.js` 模块路径对应的模块化包装函数，返回相应的模块化导出对象
    -   在链式调用的 `then` 中获取 `src/single-spa.js` 的模块化导出对象
-   将 `src/index.js` 的模块化导出对象 `__webpack_exports__`赋值给 `window.myLibrary`

> 温馨提示：上述的 chunk 文件或者 chunk 文件在动态导入示例中指代 Webpack 分离的 `dist/src_single-spa_js.js`文件。


在 `src/index.js` 的模块化包装函数中会执行 `__webpack_require__.e` 异步加载 `dist/src_single-spa_js.js`，该 chunk 文件的构建代码如下所示：

``` javascript
// dist/src_single-spa_js.js
"use strict";
(self["webpackJsonp_webpack-runtime-analyze"] = self["webpackJsonp_webpack-runtime-analyze"] || []).push([
  ["src_single-spa_js"],
  {
    /***/ "./src/single-spa.js":
      /*!***************************!*\
  !*** ./src/single-spa.js ***!
  \***************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n\tconsole.log("bootstrap");\n  }\n  \n  async function mount() {\n\tconsole.log("mount");\n  }\n  \n  async function unmount() {\n\tconsole.log("unmount");\n  }\n  \n  async function update() {\n\tconsole.log("update");\n  }\n\n//# sourceURL=webpack://myLibrary/./src/single-spa.js?'
        );

        /***/
      },
  },
]);
```

其中 `src/single-spa.js` 对应的模块化包装函数中的 `eval` 代码如下所示：

``` javascript
// 首先定义 ES 模块的标准行为，
// 可以通过标准行为识别 __webpack_exports__ 为 ES 模块
__webpack_require__.r(__webpack_exports__);

// 为 __webpack_exports__ 对象定义源码中的 ES 模块导出值，即 bootstrap、mount、unmount、update 四个函数
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bootstrap: () => (/* binding */ bootstrap),
/* harmony export */   mount: () => (/* binding */ mount),
/* harmony export */   unmount: () => (/* binding */ unmount),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
async function bootstrap() {
	console.log("bootstrap");
  }
  
  async function mount() {
	console.log("mount");
  }
  
  async function unmount() {
	console.log("unmount");
  }
  
  async function update() {
	console.log("update");
  }

//# sourceURL=webpack://myLibrary/./src/single-spa.js?
```

因此在 `src/index.js` 对应的模块化包装函数中使用 `__webpack_require__.e` 异步加载 `dist/src_single-spa_js.js` 的详细执行流程如下所示：

-   调用 `__webpack_require__.e`，内部会遍历加载器从而调用 `__webpack_require__.f.j`，返回一个 `Promise.all` 用于等待所有的加载器执行完成
-   执行 `__webpack_require__.f.j`，通过 `installedChunks` 标记 chunk 文件的异步加载状态，内部会调用 `__webpack_require__.l`  动态创建 `<script>` 加载 chunk 文件
-   `dist/src_single-spa_js.js` chunk 文件通过 `<script>` 标签加载完成后，浏览器会立即执行该脚本，脚本会立即执行 `window.webpackJsonp_webpack-runtime-analyze.push` 从而触发 `webpackJsonpCallback`函数的执行
-   在 `webpackJsonpCallback` 函数中合并当前异步加载的 chunk 文件对应的模块映射对象到 `__webpack_modules__.m` 中，并将 `dist/src_single-spa_js.js` 对应的异步模块的加载状态设置为加载完成，并执行 `__webpack_require__.f.j` 加载器对应的 `promise.resolve`，从而触发 `__webpack_require__.e` 的 `then`回调
-   在 `__webpack_require__.e` 的 `then` 回调中通过 `__webpack_require__` 执行 `src/single-spa.js` 对应的模块化包装函数，并返回对应的模块化导出对象 `__webpack_exports__`
    -   执行 `__webpack_require__.r` 定义 `__webpack_exports__` 的 ES 模块标准行为
    -   执行 `__webpack_require__.d` 将当前模块的导出值赋值给 `__webpack_exports__` 对象
-   在`__webpack_require__.e` 链式调用中获取 `src/single-spa.js` 的模块化导出对象进行处理


> 温馨提示：通过 `<script>` 脚本异步加载 chunk 文件 `dist/src_single-spa_js.js` 时，如果加载超时或者失败，还会进行加载模块的状态重置处理，从而可以在下一次加载时进行加载重试。如果加载完成，那么会删除 `<script>` 标签并释放对应的 JS 资源防止内存泄漏。

通过 `import()` 动态加载的构建代码的整体运行时流程如下所示：

![Webpack 运行时分析-流程图 (1).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50df1b60e9fe4786b925c974f6570427~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=5528&h=4489&s=1999264&e=png&b=ffffff)

我们重新回顾一下 Webpack 的配置：

``` javascript
// webpack 5.x
const packageName = require('./package.json').name;

module.exports = {
  output: {
    // library 和 libraryTarget 用于暴露微应用的生命周期函数
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    // chunkLoadingGlobal 用于代码分割
    // chunkLoadingGlobal = webpackJsonp_webpack-runtime-analyze
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
};

// package.json
{
  "name": "webpack-runtime-analyze"
}
```

再来看一下构建后的 `dist/main.js` 中的部分代码：

``` javascript
var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
    var [chunkIds, moreModules, runtime] = data;
    // add "moreModules" to the modules object,
    // then flag all "chunkIds" as loaded and fire callback
    var moduleId,
      chunkId,
      i = 0;
    if (chunkIds.some((id) => installedChunks[id] !== 0)) {
      for (moduleId in moreModules) {
        if (__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if (runtime) var result = runtime(__webpack_require__);
    }
    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
    for (; i < chunkIds.length; i++) {
      chunkId = chunkIds[i];
      if (
        __webpack_require__.o(installedChunks, chunkId) &&
        installedChunks[chunkId]
      ) {
        installedChunks[chunkId][0]();
      }
      installedChunks[chunkId] = 0;
    }
};

// 可以发现这里的 webpackJsonp_webpack-runtime-analyze 
// 就是 Webpack 的配置的 chunkLoadingGlobal
var chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =
self["webpackJsonp_webpack-runtime-analyze"] || []);
chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));

chunkLoadingGlobal.push = webpackJsonpCallback.bind(
null,
chunkLoadingGlobal.push.bind(chunkLoadingGlobal)
);
```

并且在 `dist/src_single-spa_js.js` 中也会使用该全局属性，如下所示：

``` javascript
// dist/src_single-spa_js.js
"use strict";
(self["webpackJsonp_webpack-runtime-analyze"] = self["webpackJsonp_webpack-runtime-analyze"] || []).push([
  ["src_single-spa_js"],
  {
    /***/ "./src/single-spa.js":
      /*!***************************!*\
  !*** ./src/single-spa.js ***!
  \***************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n\tconsole.log("bootstrap");\n  }\n  \n  async function mount() {\n\tconsole.log("mount");\n  }\n  \n  async function unmount() {\n\tconsole.log("unmount");\n  }\n  \n  async function update() {\n\tconsole.log("update");\n  }\n\n//# sourceURL=webpack://myLibrary/./src/single-spa.js?'
        );

        /***/
      },
  },
]);
```

可以发现 `window.webpackJsonp_webpack-runtime-analyze` 是实现 `dist/main.js` 和 `dist/src_single-spa_js.js` 之间的通信对象，通过该对象可以将 `dist/src_single-spa_js.js` 所在的异步模块添加到 `dist/main.js` 所在的模块化映射对象 `__webpack_modules__.m` 中。因此这个全局属性对应的 Webpack 配置 `chunkLoadingGlobal` 在微应用中需要保证唯一性，否则多个微应用加载时如果没有做好隔离，互相之间的 `chunkLoadingGlobal` 可能会因为名称相同而被覆盖，从而可能产生意想不到的问题。

除此之外，我们也了解到动态加载 `import()` 本质上就是通过动态 `<script>` 进行加载，因此所谓的按需加载就是利用了 Webpack 内部实现动态 `<script>` 加载。

## Fetch 示例

了解了 Webpack 配置的代码分割运行时原理后，我们可以设计一个基于代码分割的微前端方案。整体的目录结构如下所示：

``` bash
├── packages                                                                       
│   ├── main-app/                # 主应用
│   ├── react-app/               # React 微应用
│   ├── single-spa/              # single-spa 5.9.5 版本
│   └── vue-app/                 # Vue 微应用
└── lerna.json                   # Lerna 配置
```

> 温馨提示：示例源码可以从 micro-framework 的 [demo/code_splitting](https://github.com/ziyi2/micro-framework/tree/demo/code_splitting) 分支获取。


Fetch 方案示例的实现流程如下所示，当主应用切换路由时会先失活没有匹配路由的微应用，执行相应的 `unmount` 函数卸载微应用，然后会激活匹配路由的微应用，通过 Fetch 请求获取微应用的脚本文本，然后使用 `eval` 执行脚本代码，并立即获取执行代码后的微应用生命周期函数，最后执行 `mount` 函数挂载应用，从而实现监听路由切换微应用的功能：


![yuque_diagram (2).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cf1e87c83c24a6b975196c0af372e06~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2326&h=860&s=279920&e=png&b=fefefe)


### 主应用设计

首先来看下 Fetch 示例的实现效果，如下所示，点击左侧的导航切换路由，使用 single-spa 监听路由的变化来切换微应用：

![录屏2024-03-11 09.10.35.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e79c2bd7dba54d7da4bde6ad77f5d608~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2094&h=1180&s=787874&e=gif&f=63&b=fcfcfc)

> 温馨提示：切换路由的时候可以通过 Network 发现使用 Fetch 请求获取了微应用的 JS 脚本文本。除此之外，在 single-spa 源码的各个阶段植入了很多打印信息，可以根据打印信息来感性了解 single-spa 的内部运行机制。

主应用的目录结构如下所示：

``` bash
├── src                  
│   ├── index.js            # 入口文件，包含了 single-spa 的注册和 React 路由             
│   ├── App.js              # 主应用布局，包含了导航和内容区的布局设计           
│   └── utils/              # 工具方法
│        ├── micros.js      # 微应用数据信息（Mock 后端数据结构）      
│        └── single-spa.ts  # single-spa 的注册 API 封装
```

在 `src/utils/micros.js` 中定义了微应用列表的数据结构（在真实业务场景中这个数据会更复杂，并且可以从服务端进行动态加载），该数据主要用于注册 single-spa 的微应用、生成 React 路由和主应用导航，如下所示：

``` javascript
// src/utils/micros.js

import { IMicroApp } from "../types";

// 微应用容器元素的 ID
export const MICRO_APP_CONTAINER_ID = "micro-app-container";

export const MICRO_APP_ROUTER = {
  REACT: "react",
  VUE: "vue",
};

// 菜单信息，这里用于 Mock 后端数据
// 真实业务可能是一个树状的带权限的菜单信息
export const mockMicroApps: IMicroApp[] = [
  {
    // 应用标识
    name: "react",
    // 菜单名称
    title: "React Micro App",
    // 应用地址
    // 注意这里因为使用了代码分割，所以存在分割的 chunk 文件
    // 注意由于遍历执行 entry 中的脚本，需要和 HTML 中 <script> 标签的放置顺序保持一致
    // 分离出来的 chunk 文件需要优先于主文件执行
    entry: [
      "http://localhost:3000/vendors.js",
      "http://localhost:3000/main.js",
    ],
    // 激活路由
    router: MICRO_APP_ROUTER.REACT,
  },
  {
    name: "vue",
    title: "Vue Micro App",
    entry: [
      "http://localhost:8080/js/chunk-vendors.js",
      "http://localhost:8080/js/app.js",
    ],
    router: MICRO_APP_ROUTER.VUE,
  },
];
```

主应用在初始化时需要消费微应用列表数据，在初始化时使用 single-spa 注册微应用并生成对应的 React 路由：

``` javascript
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App.tsx";
import reportWebVitals from "./reportWebVitals.js";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { registerMicroApps, fetchApp } from "./utils/single-spa.ts";
import { MICRO_APP_CONTAINER_ID, mockMicroApps } from "./utils/micros.ts";

// 对 single-spa 的注册 API 进行了二次封装，支持传入数组进行批量注册
registerMicroApps(
  // 根据后端提供的动态数据批量注册微应用
  mockMicroApps.map((item) => ({
    name: item.name,
    app: () => {
      // 通过 Fetch 请求方式获取
      return fetchApp(item.entry);
    },
    activeWhen: item.router,
    customProps: {
      // 向微应用传递需要挂载的容器元素 ID
      container: MICRO_APP_CONTAINER_ID,
    },
  }))
);

const router = createBrowserRouter([
  {
    path: "/",
    // <App /> 中提供了左侧导航栏和右侧内容区域的布局结构
    element: <App />,
    // children 中的元素会被渲染到 <App /> 的 <Outlet /> 中
    // <Outlet> 是 react-router-dom 提供的一个组件，用于渲染子路由：https://reactrouter.com/en/main/components/outlet

    // 遍历迭代 mockMicroApps 中的数据，生成对应的路由配置
    // 这里的路由配置和微应用注册 API 中的 activeWhen 一致
    children: mockMicroApps.map((item) => ({
      path: item.router,
      // 微应用的容器元素，用于渲染微应用
      element: <div id={MICRO_APP_CONTAINER_ID}></div>,
    })),
  },
]);

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(<RouterProvider router={router} />);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

在 `src/utils/single-spa.ts` 中重点看下 `fetchApp` 的实现，通过 `window.fetch` 获取微应用的 JS 脚本文本进行动态执行，执行完成后立马获取相应的生命周期函数：

``` javascript
// 这里使用 npm link 进行连接调试
import { start, registerApplication } from "single-spa/src/single-spa";
import { LifeCycles, RegisterApplicationConfig } from "single-spa";

// 对 single-spa 的 registerApplication 进行二次封装，使其可以接收一个数组，批量注册子应用
export function registerMicroApps(apps: RegisterApplicationConfig[]) {
  // @ts-ignore
  // 如果不开启 __DEV__，single-spa 的源码无法正常运行
  window.__DEV__ = true;
  apps.forEach(registerApplication);
  start();
}

export function getAppLifeCycles() {
  // 使用 UMD 进行子应用的构建，挂载全局变量的动作是在内部微应用的代码执行完毕后
  // 例如 root["myLibrary"] = factory(), 这里的 factory 包含了内部微应用代码的执行
  // 因此这里通过遍历全局对象的属性顺序拿到子应用的生命周期函数

  // Object.keys 可以获取到对象的属性
  // 对象自身属性的返回顺序查看 ECMAScript 2015 标准：
  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys

  // 按照这个规范，Object.keys() 的返回顺序如下：

  // 数字键（整数索引），按照升序排列。
  // 字符串键，按照它们被添加到对象的顺序。
  // 符号键，按照它们被添加到对象的顺序。
  // 由于 Object.keys() 只返回字符串键，因此只需要关心数字键和字符串键。
  // 数字键会被视为数组索引并按照数值升序排列，而字符串键则会按照它们创建时的顺序排列。
  // 符号键不会被 Object.keys() 返回，但如果要获取它们，可以使用 Object.getOwnPropertySymbols()。

  // 注意，这里的“数字键”指的是那些可被转换为32位无符号整数的字符串键，它们属于数组索引的范围，即在0到2^32-1之间的整数。
  // 对于这些数字键，即使它们是作为对象的属性添加的，它们也会被当作数组索引并按照数值排序。其他非数字的字符串键则按照它们添加到对象的顺序进行枚举。

  // 需要注意和 for...in 的区别，for...in 还能遍历原型链上的属性

  // for...in
  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-for-in-and-for-of-statements-static-semantics-early-errors

  const keys = Object.keys(window);
  const lifeCycles = window[keys[keys.length - 1]];
  console.info(
    "%c当前 window 对象的最后一个属性是：%c" + keys[keys.length - 1],
    "color: blue; font-weight: bold; font-size: 20px;",
    "color: red; font-weight: bold; font-size: 20px;"
  );
  return lifeCycles as LifeCycles;
}

export async function fetchApp(urls: string[]) {
  // 在上一个 Fetch 示例中没有进行代码分割，只需要请求单个 Bundle 文件进行执行
  // 而在本示例中因为进行了代码分离，因此需要遍历执行微应用的所有脚本
  // 这里需要先执行分离的 chunk 文件，后执行主文件
  for (let url of urls) {
    const res = await window.fetch(url);
    const text = await res.text();
    // 使用 eval 执行
    (0, eval)(text);
  }

  // 执行微应用的代码后立即获取对应的生命周期函数
  return getAppLifeCycles();
}
```

最后在 `<App>` 中对主应用进行布局设计，将左侧设计成能够切换路由的导航，导航的信息来源于微应用数据列表，右侧设计成用于渲染微应用的内容区：

``` jsx
// src/App.js
import { Outlet, Link } from "react-router-dom";
import "./App.css";
import { mockMicroApps } from "./utils/micros";

function App() {
  return (
    <div className="app">
      <div className="app-nav">
        <p>Micro App List</p>
        <nav>
          <ul>
            {/* 遍历微应用的数据列表生成导航路由信息 */}
            {mockMicroApps.map((item) => (
              <li key={item.name}>
                <Link to={item.router}>{item.title}</Link>
              </li>
            ))}
          </ul>
        </nav>
      </div>
      <div className="app-content">
        {/* 这里的 <Outlet /> 会被 <RouterProvider router={router} /> 中 router 提供的 children 进行替换 */}
        {/* 所以本质上会被微应用的容器元素 <div id={MICRO_APP_CONTAINER_ID}></div> 替代  */}
        <Outlet />
      </div>
    </div>
  );
}

export default App;
```

### 微应用设计

本示例采用了代码分割，除了上个课程中的 UMD 导出配置外，需要额外注意和代码分割息息相关的 `chunkLoadingGlobal`，本课程的 React 示例需要在 `config/webpack.config.js` 中修改如下配置：

``` javascript
// config/webpack.config.js

// ...

// 保证全局属性的唯一性
const { v4: uuidv4 } = require("uuid");
const { name } = require("../package.json");

// 确保全局对象属性的唯一性
// name: 保持微应用的可辨识性
// uuidv4: 保持全局唯一性
const appKey = `${name}_${uuidv4()}`;

//  ...

// This is the production and development configuration.
// It is focused on developer experience, fast rebuilds, and a minimal bundle.
module.exports = function (webpackEnv) {
  
  // ...
 
  return {
    
    output: {
      // 在 Webpack 的运行时原理中已经说明会计算动态 import 的 publicPath
      // 通过动态 import 访问时需要计算 publicPath
      publicPath: `//localhost:${process.env.PORT || 3000}/`,
      // Point sourcemap entries to original disk location (format as URL on Windows)
      
      // 确保唯一性
      library: appKey,
      libraryTarget: "umd",
      // 确保唯一性
      chunkLoadingGlobal: `webpackJsonp_${appKey}`,
    },
    
    // ...
    
    optimization: {
      // 支持代码分割
      splitChunks: {
        chunks: "all",
        name: "vendors",
      },
    
    // ...
    
    plugins: [
      // ...
      // 注释该配置
      // 构建单个 JS 脚本
      // new webpack.optimize.LimitChunkCountPlugin({
      //   maxChunks: 1,
      // }),
    ].filter(Boolean),
    // Turn off performance processing because we utilize
    // our own hints via the FileSizeReporter
    performance: false,
  };
};
```

同时在 React 微应用的入口文件中导出生命周期函数，如下所示：

``` javascript
// src/index.js

import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
// import reportWebVitals from './reportWebVitals';

let root;

// 这里可以用于测试动态 import 自动分割，注意需要配置 publicPath
// 否则请求的 publicPath 会根据主应用的访问地址进行计算
// 需要新建 about.js 文件并导出内容
// 例如：src/about.js
// export function about() {
//   return "about";
// }
import(/* webpackChunkName: "about" */ "./about.js").then((res) => {
  console.log(res);
});

// 判断是否在 single-spa 的环境中运行
// 如果不是，那么说明不在微前端的环境中，可以独立启动
if (!window.singleSpaNavigate) {
  root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

/**
 * bootstrap 只会在微应用首次激活时调用一次
 * 微应用重新激活时会直接调用 mount 周期函数，不会再重复触发 bootstrap。
 * 通常情况下这里不需要进行任何处理，初始化的代码可以放在当前入口文件的顶层处理
 * 除非会执行微应用的 unload 动作，然后需要再次执行 bootstrap，可能需要在此做一些必要的初始化动作
 * 注意这里的周期函数不是 async 函数，在主应用中引入该周期函数后需要进行 async 处理
 */

// 注意这里的每一个生命周期函数必须是 async 函数
export async function bootstrap() {
  console.log("[React 子应用] bootstrap excuted");
}

/**
 * 微应用每次激活时都会调用 mount 周期函数，通常在这里执行微应用的渲染
 */
export async function mount(props) {
  console.log("[React 子应用] mount excuted, props: ", props);
  // 在 single-spa 的注册 API 中会通过 customProps 传递 container 微应用容器元素 ID
  // 因此这里将微应用挂载在主应用的容器元素上
  root = ReactDOM.createRoot(document.getElementById(props.container));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

/**
 * 微应用每次失活时会调用 unmount 周期函数，通常在这里执行微应用的卸载
 */
export async function unmount(props) {
  console.log("[React 子应用] unmount excuted, props: ", props);
  root && root.unmount();
}

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
// reportWebVitals();

```

Vue 示例也需要进行更改，首先使其支持代码分割：

``` javascript
// vue.config.js
const { defineConfig } = require("@vue/cli-service");
const { name } = require("./package.json");
const { v4: uuidv4 } = require("uuid");

const port = 8080;

// 确保全局对象属性的唯一性
// name: 保持微应用的可辨识性
// uuidv4: 保持全局唯一性
const appKey = `${name}_${uuidv4()}`;

module.exports = defineConfig({
  transpileDependencies: true,
  css: { extract: false },
  // 去除文件名哈希
  filenameHashing: false,

  publicPath: `//localhost:${port}/`,

  configureWebpack: {
    // 支持代码分割
    optimization: {
      splitChunks: {
        chunks: "all",
      },
    },
    output: {
      // 保证唯一性
      library: appKey,
      libraryTarget: "umd",
      // 保证唯一性
      chunkLoadingGlobal: `webpackJsonp_${appKey}`,
    },
  },
  devServer: {
    port: port, // 设置启动端口号
    headers: {
      "Access-Control-Allow-Origin": "*",
    },
  },
});
```

同时在 Vue 微应用的入口文件中导出生命周期函数，如下所示：

``` javascript
// src/main.js
import { createApp } from "vue";
import App from "./App.vue";
let app;

import(/* webpackChunkName: "about" */ "./about.js").then((res) => {
  console.log(res);
});

// 判断是否在 single-spa 的环境中运行
// 如果不是，那么说明不在微前端的环境中，可以独立启动
if (!window.singleSpaNavigate) {
  app = createApp(App);
  app.mount("#app");
}

// 注意这里的每一个生命周期函数必须是 async 函数
export async function bootstrap() {
  console.log("[Vue 子应用] bootstrap excuted");
}

export async function mount(props) {
  console.log("[Vue 子应用] mount excuted, props: ", props);
  app = createApp(App);
  app.mount(`#${props.container}`);
}

export async function unmount(props) {
  console.log("[Vue 子应用] unmount excuted, props: ", props);
  app && app.unmount();
}
```


## 小结

本课程讲解了 Fetch 请求方案的代码分割实现示例，重点讲解了代码分割的 Webpack 运行时原理，并详细讲解了 `output.chunkLoadingGlobal` 在微前端中的详细作用。在下一个课程中，我们会重点讲解 single-spa 的内部运行机制，从而为了解 qiankun 内部的运行机制奠定基础。
