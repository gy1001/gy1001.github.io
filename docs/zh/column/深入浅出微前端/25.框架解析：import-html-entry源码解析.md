在上一个课程中，我们讲解了 qiankun 的使用示例，在最后一个示例中我们将 `entry` 设置成 HTML 地址进行微应用的加载，此时 qiankun 会通过 `import-html-entry` 库包请求并解析 HTML 文本内容，最终实现微应用的加载。本课程我们主要分为两个部分来讲解 `import-html-entry`，首先会讲解如何通过 single-spa 来使用 `import-html-entry`，其次会详细讲解它的内部运行原理。

## import-html-entry

[import-html-entry](https://github.com/kuitos/import-html-entry)是一个被 qiankun 依赖的库包，它的主要作用是加载微应用，解析微应用导出的生命周期函数：

-   如果提供 HTML 地址，会请求和解析 HTML 文本，自动提取 JS 和 CSS 资源
-   请求外联 CSS 资源文本，通过内联的方式嵌入 HTML
-   请求外联 JS 资源文本，通过 `(0, eval)` 的形式动态执行脚本
-   识别微应用的入口脚本并解析微应用导出的生命周期函数提供给 single-spa 的注册参数 `app`

> 温馨提示： 在 single-spa 的示例中，我们通过 `fecthApp` 请求微应用的 JS 脚本，动态执行脚本并解析 single-spa 需要的生命周期函数。`import-html-entry` 库包可以理解为 `fecthApp` 的加强版，它不仅支持传入微应用的 JS 和 CSS 进行加载，还可以传入微应用的 HTML 地址进行解析加载。

qiankun 的 `entry` 可以提供两种配置方式，一种是 **Config Entry** 模式，需要配置 `scripts`、`styles` 以及 `html` 三个字段信息，另外一种是 **HTML Entry** 模式，只需要配置一个 HTML 地址。正好这两种模式对应了 `import-html-entry` 的两个对外 API:

-   `importHTML`：HTML Entry 解析模式，传入 HTML 地址进行解析
-   `importEntry`：如果是 Config Entry 模式，需要传入 JS、CSS 等资源

## 使用示例

为了能够调试 `import-html-entry`的源码，我们通过 Lerna 工具设计 Monorepo 结构引入 `1.15.2` 固定版本的源码包。由于 `import-html-entry` 采用 ES6 编写源码，并且 Chrome 浏览器默认支持 [ES2016 ~ ES2024](https://compat-table.github.io/compat-table/es2016plus/) 的新语法特性，因此在调试时可以不用编译 `import-html-entry`的源码。通过 Lerna 可以自然的将本地 `packages`目录下的项目链接成 NPM 包，直接在主应用中引入使用，目录结构如下所示：

```
├── packages  
│   ├── import-html-entry/       # import-html-entry 1.15.2 版本
│   ├── main-app/                # 主应用
│   ├── react-app/               # React 微应用
│   └── vue-app/                 # Vue 微应用
└── lerna.json                   # Lerna 配置
```

> 温馨提示：本示例不再引入 single-spa 的源码，如果你仍然对 single-spa 的源码运行原理感兴趣，可以自行参考之前的示例进行更改。


我们会在 **single-spa 的 Code Splitting 示例** 上进行简单更改，为此可以先回顾一下原有的执行流程，如下所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d00a3279f344d4be4bdc3989fd6f97~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2326&h=860&s=652067&e=png&b=fcf3f2)

上图中的**微应用 Fetch 加载逻辑**会使用 `import-html-entry` 替换实现，如下所示：

![yuque_diagram (53).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ae7165d82e4b199b8a912b0eadb469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2905&h=1393&s=445311&e=png&b=ffffff)

> 温馨提示：上图中红色文本是 `import-html-entry` 对外提供的 API。

### import-html-entry

为了可以在主应用中直接使用 `import-html-entry` 的源码，引入源码后需要修改 `package.json` 的入口文件，如下所示：

``` javascript
{
  "name": "import-html-entry",
  "version": "1.15.2",
  "description": "import html and get the exports of entry",
  // 去除 module 字段，不进行 build 处理
  // 将 main 字段修改成源码入口地址
  
  // 注意 import-html-entry 的源码可以被 Chrome 浏览器直接兼容
  // 如果只是用于调试，完全可以不用编译
  // 当然如果需要在生产环境使用，一定要使用编译后的代码
  "main": "./src/index.js",
  "sideEffects": false,
  "directories": {
    "example": "example"
  },
  "files": [
    "lib",
    "esm",
    "index.d.ts"
  ],
  "types": "./index.d.ts",
  "scripts": {
    "lint": "npm test",
    "build": "npm run build:lib && npm run build:esm",
    "build:lib": "rm -fr ./lib && babel ./src --out-dir ./lib --ignore 'src/**/__tests__/**/*.js'",
    "build:esm": "rm -fr ./esm && BABEL_ENV=esm babel ./src --out-dir ./esm --ignore 'src/**/__tests__/**/*.js'",
    "prepush": "npm run lint",
    "prepublishOnly": "npm run build",
    "release": "np --no-cleanup --yolo --no-publish --any-branch",
    "test": "jest --coverage",
    "codecov": "codecov"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kuitos/import-html-entry.git"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "keywords": [
    "html",
    "importer"
  ],
  "author": "Kuitos",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/kuitos/import-html-entry/issues"
  },
  "homepage": "https://github.com/kuitos/import-html-entry#readme",
  "browserslist": [
    "> 1%",
    "last 6 versions",
    "not ie <= 8"
  ],
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.2.2",
    "@babel/plugin-proposal-optional-chaining": "^7.8.3",
    "@babel/plugin-transform-runtime": "^7.0.0",
    "@babel/preset-env": "^7.0.0",
    "babel-loader": "^8.0.2",
    "codecov": "^3.7.0",
    "husky": "^1.3.1",
    "iconv-lite": "^0.6.2",
    "jest": "^24.9.0",
    "np": "^5.0.3",
    "webpack": "^4.17.1",
    "webpack-cli": "^3.1.0"
  },
  "jest": {
    "globals": {
      "process.env.NODE_ENV": "test"
    },
    "testURL": "http://test.com/path/",
    "testMatch": [
      "<rootDir>/src/**/__tests__/**/*.js"
    ],
    "testPathIgnorePatterns": [
      "/node_modules/",
      "/fixtures/"
    ],
    "coveragePathIgnorePatterns": [
      "/node_modules/",
      "/__tests__/",
      "/dist/"
    ],
    "setupFiles": [
      "./test/setup.js"
    ]
  },
  "dependencies": {
    "@babel/runtime": "^7.7.2"
  }
}
```

### 主应用设计

首先来看下实现效果，如下所示，点击左侧的导航切换路由，使用 single-spa 监听路由的变化来切换微应用：

![录屏2024-06-01 10.49.55.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956caca29e434584bff383602d42e20d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2348&h=1180&s=2745352&e=gif&f=139&b=fcfcfc)

> 温馨提示：从上述示例的 Network 中可以发现，会通过 `window.fetch` 请求微应用的 HTML 地址。除此之外，在上一个课程 **qiankun 使用示例**中默认会对所有微应用进行 Prefetch 处理，所以首次刷新激活微应用时会将所有微应用的资源进行预加载处理，而本示例没有对微应用的资源进行预请求处理，因此这里在首次刷新时只会加载激活的微应用。

主应用的目录结构如下所示：

``` bash
├── src                  
│   ├── index.tsx           # 入口文件，包含了 single-spa 的注册和 React 路由             
│   ├── App.tsx             # 主应用布局，包含了导航和内容区的布局设计           
│   └── utils/              # 工具方法
│        ├── micros.ts      # 微应用数据信息（Mock 后端数据结构）   
│        └── single-spa.ts  # single-spa 的注册 API 封装 
```

在 `src/utils/micros.js` 中定义了微应用列表的数据结构（在真实业务场景中这个数据会更复杂，并且可以从服务端进行动态加载），该数据主要用于注册 single-spa 的微应用、生成 React 路由和主应用导航，如下所示：

``` javascript
export const MICRO_APP_CONTAINER_ID = "micro-app-container";

export const MICRO_APP_ROUTER = {
  REACT: "react",
  VUE: "vue",
};

export const mockMicroApps = [
  {
    name: "react",
    title: "React Micro App",

    // 在原有 single-spa 的示例中
    // Entry 主要采用 Config Entry 的配置方式
    // 并且没有考虑 CSS 样式的 Entry 处理
    // 对配置 JS 的顺序有要求，需要按照 <script> 标签的执行顺序放置
    // entry: [
    //   "http://localhost:3000/vendors.js",
    //   "http://localhost:3000/main.js",
    // ],

    // 由于采用了 import-html-entry 加载微应用
    // Entry 采用 HTML Entry 的配置方式
    entry: "http://localhost:3000",
    activeWhen: MICRO_APP_ROUTER.REACT,
    customProps: {
      container: MICRO_APP_CONTAINER_ID,
    },
  },
  {
    name: "vue",
    title: "Vue Micro App",
    entry: "http://localhost:8080",
    activeWhen: MICRO_APP_ROUTER.VUE,
    customProps: {
      container: MICRO_APP_CONTAINER_ID,
    },
  },
];
```

主应用在初始化时需要消费微应用列表数据，在初始化时使用 single-spa 注册微应用并生成对应的 React 路由：

``` javascript
// src/index.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { registerMicroApps, fetchApp } from "./utils/single-spa";
import { MICRO_APP_CONTAINER_ID, mockMicroApps } from "./utils/micros";

registerMicroApps(
  mockMicroApps.map((item) => ({
    name: item.name,
    app: (props) => {
      // 注意 fetchApp 和之前 single-spa 请求微应用的方式存在巨大差异
      // 内部主要采用 import-html-entry 实现微应用的加载和生命周期函数的获取
      return fetchApp(item.entry);
    },
    activeWhen: item.activeWhen,
    customProps: item.customProps,
  }))
);

const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: mockMicroApps.map((item) => ({
      path: item.activeWhen,
      element: <div id={MICRO_APP_CONTAINER_ID}></div>,
    })),
  },
]);

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(<RouterProvider router={router} />);
```

在 `src/utils/single-spa.ts` 中重点关注 `fetchApp` 的实现，之前的示例通过 `window.fetch` 获取微应用的 JS 脚本文本进行动态执行，执行完成后立即识别相应的生命周期函数，现在则改用 `import-html-entry` 来实现类似的功能：

``` javascript
// single-spa 使用 NPM 库包
import {
  start,
  registerApplication,
  LifeCycles,
  RegisterApplicationConfig,
  AppProps,
} from "single-spa";

// 这里本质上可以理解为使用 npm link 进行连接调试
// 实际上采用 Lerna 进行内部 packages 包的链接
import { importEntry } from "import-html-entry";

import { MICRO_APP_CONTAINER_ID } from "./micros";

export function registerMicroApps(apps: RegisterApplicationConfig[]) {
  apps.forEach(registerApplication);
  start();
}

export async function fetchApp(url: string): Promise<LifeCycles> {
  // 1. 通过 window.fetch 请求 HTML 的 url 地址
  //    获取对应的文本字符串（url 地址需要支持跨域）
  
  // 2. 通过各种正则匹配 HTML 文本中的内联 CSS、外联 CSS、内联脚本、外联脚本
  
  // 3. 通过 window.fetch 请求外联 CSS，将其内联到微应用自身的 HTML 中
  //    解析的时候会通过注释的方式提供替换内联样式的占位符
  const { template, execScripts, getExternalScripts } = await importEntry(url);
  // 这个 template 会内联 CSS 样式，例如以 Vue 微应用为例，template 如下所示：
  //   <!DOCTYPE html>
  // <html lang="">
  //   <head>
  //     <meta charset="utf-8" />
  //     <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  //     <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  //     <link rel="icon" href="//localhost:8080/favicon.ico" />
  //     <title>vue-micro-app</title>
  //     <style>
  //       body {
  //         margin: 0;
  //       }
  //     </style>
  //     <!-- inline scripts replaced by import-html-entry -->
  //   <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry --><!--   script http://localhost:8080/js/app.js replaced by import-html-entry -->
  //     <style>/* http://localhost:8080/css/app.css *//*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  //   !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/HelloWorld.vue?vue&type=style&index=0&id=469af010&scoped=true&lang=css ***!
  //   ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
  
  // h3[data-v-469af010] {
  //   margin: 40px 0 0;
  // }
  // ul[data-v-469af010] {
  //   list-style-type: none;
  //   padding: 0;
  // }
  // li[data-v-469af010] {
  //   display: inline-block;
  //   margin: 0 10px;
  // }
  // a[data-v-469af010] {
  //   color: #42b983;
  // }
  
  // /*!************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  //   !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=css ***!
  //   ************************************************************************************************************************************************************************************************************************************************************************************************************************************/
  
  // #app {
  //   font-family: Avenir, Helvetica, Arial, sans-serif;
  //   -webkit-font-smoothing: antialiased;
  //   -moz-osx-font-smoothing: grayscale;
  //   text-align: center;
  //   color: #2c3e50;
  //   margin-top: 60px;
  // }
  
  // </style></head>
  //   <body>
  //     <noscript>
  //       <strong
  //         >We're sorry but vue-micro-app doesn't work
  //         properly without JavaScript enabled. Please enable it to
  //         continue.</strong
  //       >
  //     </noscript>
  //     <div id="app"></div>
  
  //   </body>
  // </html>
  console.log("template", template); 
  // 尽管 template 中已经通过 window.fetch 获取外联的 CSS 脚本
  // 但是还需要通过 window.fetch 请求获取并缓存微应用的 JS 脚本
  await getExternalScripts();
  // 将 HTML 挂载到 container 容器中
  const container = document.getElementById(MICRO_APP_CONTAINER_ID)!;
  container.innerHTML = template;
  // 1. 通过 eval 动态执行缓存的微应用脚本，
  //    注意不是使用 <script> 标签执行脚本
  //    qiankun 会进行沙箱隔离，该示例没有隔离处理
  
  // 2. 识别并返回微应用导出的生命周期函数
  const scriptExports: LifeCycles = await execScripts();
  // 封装成 single-spa 需要的微应用生命周期函数格式
  return {
    async bootstrap(props) {
      console.log("bootstrap", props);
      await execLifecycleFn(scriptExports, "bootstrap", props);
    },
    async mount(props) {
      const container = document.getElementById(MICRO_APP_CONTAINER_ID)!;
      // 挂载微应用时将微应用的 HTML（经过 import-html-entry 处理）挂载到 container 容器中
      container.innerHTML = template;
      await execLifecycleFn(scriptExports, "mount", props);
    },
    async unmount(props) {
      const container = document.getElementById(MICRO_APP_CONTAINER_ID)!;
      await execLifecycleFn(scriptExports, "unmount", props);
      // 卸载微应用时清除 container 容器元素的微应用内容
      container.innerHTML = "";
    },
  };
}

export async function execLifecycleFn(
  scriptExports: LifeCycles,
  lifecycle: keyof LifeCycles,
  props: AppProps
) {
  const lifecycleFn = scriptExports[lifecycle];
  if (Array.isArray(lifecycleFn)) {
    // 如果是数组，需要按顺序执行
    for (const fn of lifecycleFn) {
      await fn(props);
    }
  } else if (lifecycleFn) {
    await lifecycleFn(props);
  }
}

// 原有 single-spa 的 fetch 示例中 fetchApp 的实现如下：
// 此时 urls 为 Config Entry：
// [
//   "http://localhost:3000/vendors.js",
//   "http://localhost:3000/main.js",
// ]
// export async function fetchApp(urls: string[]) {
//   for (let url of urls) {
//     const res = await window.fetch(url);
//     const text = await res.text();
//     (0, eval)(text);
//   }
//   return getAppLifeCycles();
// }

// export function getAppLifeCycles() {
//   const keys = Object.keys(window);
//   const lifeCycles = window[keys[keys.length - 1]];
//   console.info(
//     "%c当前 window 对象的最后一个属性是：%c" + keys[keys.length - 1],
//     "color: blue; font-weight: bold; font-size: 20px;",
//     "color: red; font-weight: bold; font-size: 20px;"
//   );
//   return lifeCycles as LifeCycles;
// }
```

最后在 `<App>` 中对主应用进行布局设计，将左侧设计成能够切换路由的导航，导航的信息来源于微应用数据列表，右侧设计成用于渲染微应用的内容区：

``` javascript
import React from "react";
import { Outlet, Link } from "react-router-dom";
import "./App.css";
import { mockMicroApps } from "./utils/micros";

function App() {
  return (
    <div className="app">
      <div className="app-nav">
        <p>Micro App List</p>
        <nav>
          <ul>
            {/* 遍历微应用的数据列表生成导航路由信息 */}
            {mockMicroApps.map((item) => (
              <li key={item.name}>
                <Link to={item.activeWhen}>{item.title}</Link>
              </li>
            ))}
          </ul>
        </nav>
      </div>
      <div className="app-content">
        {/* 这里的 <Outlet /> 会被 <RouterProvider router={router} /> 中 router 提供的 children 进行替换 */}
        <Outlet />
      </div>
    </div>
  );
}

export default App;
```

### 微应用设计

微应用的 Webpack 配置和之前示例保持一致。除此之外，由于主应用中通过 `import-html-entry` 获取微应用的 HTML 内容进行渲染，因此仍然可以将微应用的内容渲染到原有 HTML 模板的根节点中，但是原有通过 `ducoment` 去寻找根节点的方式可以改为通过微应用渲染容器去寻找根节点，如下所示：

``` javascript
// packages/react-app/src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

let root;

if (!window.singleSpaNavigate) {
  // 默认单独启动时通过 document 获取根节点
  root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

export async function bootstrap() {
  console.log("[React 子应用] bootstrap excuted");
}

export async function mount(props) {
  console.log("[React 子应用] mount excuted, props: ", props);
  // 在 single-spa 的注册 API 中会通过 customProps 
  // 传递 container 微应用容器元素 ID
  const containerElm = document.getElementById(props.container);
  // 微应用的 HTML 内容通过 import-html-entry 处理后
  // 会在 container 微应用容器元素中渲染
  
  // 因此可以通过 container 微应用容器元素
  // 来寻找 HTML 内容中的根节点
  root = ReactDOM.createRoot(containerElm?.querySelector("#root"));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

export async function unmount(props) {
  console.log("[React 子应用] unmount excuted, props: ", props);
  root && root.unmount();
}
```

``` javascript
// packages/vue-app/src/main.js
import { createApp } from "vue";
import App from "./App.vue";
let app;

if (!window.singleSpaNavigate) {
  app = createApp(App);
  app.mount("#app");
}

export async function bootstrap() {
  console.log("[Vue 子应用] bootstrap excuted");
}

export async function mount(props) {
  console.log("[Vue 子应用] mount excuted, props: ", props);
  const containerElm = document.getElementById(props.container);
  app = createApp(App);
  app.mount(containerElm?.querySelector("#app"));
}

export async function unmount(props) {
  console.log("[Vue 子应用] unmount excuted, props: ", props);
  app && app.unmount();
}
```

我们可以观察 Vue 微应用通过 `import-html-entry` 处理渲染的 DOM 结构和单独启动的 DOM 结构差异。 Vue 微应用的原始 HTML 模版如下所示：

``` html
<!-- packages/vue-app/public/index.html -->
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="<%= BASE_URL %>favicon.ico" />
    <title><%= htmlWebpackPlugin.options.title %></title>
    <!-- 内联样式，用于测试 -->
    <style>
      body {
        margin: 0;
      }
    </style>
    <!-- 内联脚本式，用于测试 -->
    <script>
      console.log("inline script");
    </script>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work
        properly without JavaScript enabled. Please enable it to
        continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
```

> 温馨提示：为了测试内联脚本和内联样式在 `import-html-entry` 中的处理，这里专门在模板中添加了一些内联标签。

Vue 微应用单独启动 的 HTML 的结构如下所示：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcfcadc996c54125bf125bb587d9d4f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2994&h=1668&s=558613&e=png&b=ffffff)

> 温馨提示：单独启动 Vue 应用时通过 `localhost:8080` 进行访问。

当我们通过本课程示例 single-spa 微前端框架渲染 Vue 微应用时，会通过 `import-html-entry` 请求上述`localhost:8080` 的 HTML 文本，最终在主应用的容器中渲染处理后的 HTML，如下所示：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e149a05b7f432191e713f5215228ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1888&s=2763274&e=png&b=fdfcfc)


## 源码解析

我们重新回顾一下本课程的示例执行流程，如下所示：

![yuque_diagram (53).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ae7165d82e4b199b8a912b0eadb469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2905&h=1393&s=445311&e=png&b=ffffff)

通过上述的红色文本可以发现，在 single-spa 的 `app` 参数中加载微应用时，主要使用了 `importHTML`、`getExternalScripts` 和 `execScripts` 三个 API，我们可以根据这三个 API 来重点分析一下 `import-html-entry` 内部的源码实现。


### importHTML

`importHTML` 主要用于解析微应用的 HTML 文本，它的内部执行流程如下所示：

![yuque_diagram (55).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36fc4ab92a14f04b06e4e8acfbc8911~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3291&h=3262&s=818557&e=png&b=ffffff)

> 温馨提示：除了 `importHTML`，`import-html-entry` 还提供了 `importEntry` ，两者分别对应 HTML Entry 和 Config Entry 两种加载微应用的配置方式。

在之前的课程中我们其实已经讲解了使用 HTML Entry 的优势，例如在现实的业务开发中往往需要生成带 hash 的资源地址，如果采用 Config Entry 配置 JS 和 CSS 外联地址的请求方式，则每次构建后都需要变更请求的地址。采用 HTML Entry 的请求方式，可以解决 hash 地址引入的变更问题，开发者不需要感知 JS 和 CSS 的地址、数量和加载顺序配置。我们首先来看下 HTML Entry 对外提供的 API 实现：

``` javascript
export default function importHTML(url, opts = {}) {
	// 默认的 fetch 方法是 window.fetch
	let fetch = defaultFetch;
	let autoDecodeResponse = false;
	// 默认的 getPublicPath 方法是 defaultGetPublicPath
	let getPublicPath = defaultGetPublicPath;
	let getTemplate = defaultGetTemplate;
	// HTML 解析的后置处理，让用户可以对解析后的 HTML 内容进行二次处理
	const { postProcessTemplate } = opts;

	// compatible with the legacy importHTML api
	if (typeof opts === "function") {
		fetch = opts;
	} else {
		// fetch option is availble
		if (opts.fetch) {
			// fetch is a funciton
			if (typeof opts.fetch === "function") {
				fetch = opts.fetch;
			} else {
				// configuration
				fetch = opts.fetch.fn || defaultFetch;
				autoDecodeResponse = !!opts.fetch.autoDecodeResponse;
			}
		}
		getPublicPath =
			opts.getPublicPath || opts.getDomain || defaultGetPublicPath;
		getTemplate = opts.getTemplate || defaultGetTemplate;
	}

	return (
		// 如果已经解析并缓存了 HTML 的处理结果，直接返回缓存结果
		embedHTMLCache[url] ||
		// 通过 window.fetch 获取 HTML 内容（HTML 地址的请求需要支持跨域）
		(embedHTMLCache[url] = fetch(url)
			// 将请求结果转换为字符串
			.then((response) => readResAsString(response, autoDecodeResponse))
			// 请求成功后，处理 HTML 文本内容
			.then((html) => {
				// 获取 HTML 内容的 publicPath
				// 例如：http://localhost:8080/abc/index.html 
                           // -> http://localhost:8080/abc/
				const assetPublicPath = getPublicPath(url);
				// 对 HTML 内容进行解析，提取其中的 script、style、template 等内容
				const { template, scripts, entry, styles } = processTpl(
					getTemplate(html),
					assetPublicPath,
					postProcessTemplate
				);

				// 处理 CSS 样式表，将外联样式表转换为内联样式表

				// 例如 template：

				// <!DOCTYPE html>
				// <html lang="">
				// <head>
				// 	<meta charset="utf-8" />
				// 	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
				// 	<meta name="viewport" content="width=device-width,initial-scale=1.0" />
				// 	<link rel="icon" href="//localhost:8080/favicon.ico" />
				// 	<title>vue-micro-app</title>
				// 	<style>
				// 	body {
				// 		margin: 0;
				// 	}
				// 	</style>
				// 	<!-- inline scripts replaced by import-html-entry -->
				// <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry --><!--   script http://localhost:8080/js/app.js replaced by import-html-entry --><!--  link http://localhost:8080/css/app.css replaced by import-html-entry --></head>
				// <body>
				// 	<noscript>
				// 	<strong
				// 		>We're sorry but vue-micro-app doesn't work
				// 		properly without JavaScript enabled. Please enable it to
				// 		continue.</strong
				// 	>
				// 	</noscript>
				// 	<div id="app"></div>

				// </body>
				// </html>

				// 通过 getEmbedHTML 处理后转换成 embedHTML：

				// <!DOCTYPE html>
				// <html lang="">
				//   <head>
				// 	<meta charset="utf-8" />
				// 	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
				// 	<meta name="viewport" content="width=device-width,initial-scale=1.0" />
				// 	<link rel="icon" href="//localhost:8080/favicon.ico" />
				// 	<title>vue-micro-app</title>
				// 	<style>
				// 	  body {
				// 		margin: 0;
				// 	  }
				// 	</style>
				// 	<!-- inline scripts replaced by import-html-entry -->
				//   <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry --><!--   script http://localhost:8080/js/app.js replaced by import-html-entry --><style>/* http://localhost:8080/css/app.css *//*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
				//   !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/HelloWorld.vue?vue&type=style&index=0&id=469af010&scoped=true&lang=css ***!
				//   ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

				// h3[data-v-469af010] {
				//   margin: 40px 0 0;
				// }
				// ul[data-v-469af010] {
				//   list-style-type: none;
				//   padding: 0;
				// }
				// li[data-v-469af010] {
				//   display: inline-block;
				//   margin: 0 10px;
				// }
				// a[data-v-469af010] {
				//   color: #42b983;
				// }

				// /*!************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
				//   !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=css ***!
				//   ************************************************************************************************************************************************************************************************************************************************************************************************************************************/

				// #app {
				//   font-family: Avenir, Helvetica, Arial, sans-serif;
				//   -webkit-font-smoothing: antialiased;
				//   -moz-osx-font-smoothing: grayscale;
				//   text-align: center;
				//   color: #2c3e50;
				//   margin-top: 60px;
				// }

				// </style></head>
				//   <body>
				// 	<noscript>
				// 	  <strong
				// 		>We're sorry but vue-micro-app doesn't work
				// 		properly without JavaScript enabled. Please enable it to
				// 		continue.</strong
				// 	  >
				// 	</noscript>
				// 	<div id="app"></div>

				//   </body>
				// </html>
				return getEmbedHTML(template, styles, { fetch }).then((embedHTML) => ({
					// 对外暴露转换成内联样式表的 HTML 内容
					template: embedHTML,
					// 对外暴露 HTML 内容的 publicPath
					assetPublicPath,
					// 对外暴露获取外链脚本的方法（利用闭包缓存了参数 scripts 和 fetch）
					getExternalScripts: () => getExternalScripts(scripts, fetch),
					// 对外暴露获取外链样式表的方法（基本上不需要使用，因为 template 已经处理过内联样式）
					getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),
					// 对外暴露执行脚本的方法（利用闭包缓存了参数 entry、scripts 和 fetch）
					execScripts: (proxy, strictGlobal, opts = {}) => {
						// 如果没有脚本，则直接返回
						if (!scripts.length) {
							return Promise.resolve();
						}
						// 执行脚本
						return execScripts(entry, scripts, proxy, {
							fetch,
							strictGlobal,
							...opts,
						});
					},
				}));
			}))
	);
}
```

`importHTML` 的执行可以分解为以下几个重要的步骤：

- 入参的配置处理，例如 `getPublicPath`、`getTemplate` 和 `fetch`
- 请求微应用的 HTML 文本
- 通过 `processTpl` 解析 HTML 文本，提取 `styles`、`scripts` 和 `entry` 等
- 通过 `getEmbedHTML` 将外联的 CSS 样式全部内嵌到 HTML 文本中

在入参的配置处理时，会依赖一些默认的配置，这些默认配置可以通过 `imprtHTML` 的第二个配置参数 `opts`进行覆盖，从而满足一些业务上的定制化开发诉求。默认配置如下所示：

``` javascript
const defaultFetch = window.fetch.bind(window);

// 原样返回
function defaultGetTemplate(tpl) {
	return tpl;
}

/**
 * 计算 publicPath
 *
 * @export
 * @param {*} entry
 * @return {*}
 */

// 例如：entry = 'http://localhost:8080/entry.js'
// 返回 'http://localhost:8080/'

// 例如：entry = 'http://localhost:8080/a/b/entry.js'
// 返回：'http://localhost:8080/a/b/'
export function defaultGetPublicPath(entry) {
	if (typeof entry === "object") {
		return "/";
	}
	try {
		const { origin, pathname } = new URL(entry, location.href);
		const paths = pathname.split("/");
		// 移除最后一个元素
		paths.pop();
		return `${origin}${paths.join("/")}/`;
	} catch (e) {
		console.warn(e);
		return "";
	}
}
```

#### `processTpl`

在 `importHTML` 中最主要的部分是通过 `processTpl` 解析 HTML 文本，`processTpl` 内部的大致执行流程如下所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70afffa068ca4ac0b62fcab59716d503~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=536&h=776&s=40537&e=png&b=ffffff)

> 温馨提示：在  `importHTML` 中 `opts.getTemplate` 是处理微应用 HTML 的 pre hook，而 `opts.postProcessTemplate` 则是通过正则处理完 HTML 后的 post hook。

其中通过正则匹配 `<link>` 标签（外联样式）的执行流程如下所示：

![yuque_diagram (59).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efaf866cba1941a598c4bdc1eecacae6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3400&h=2137&s=464167&e=png&b=ffffff)

> 温馨提示：上图中的绿色区域实现提取外联 `styles`。

其中通过正则匹配 `<script>` 标签（包含内联和外联脚本）的执行流程如下所示：

![yuque_diagram (60).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31be396410e14164b358a5741bfa58ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3638&h=4720&s=1115629&e=png&b=ffffff)

其中绿色区域的流程主要用于实现提取内联和外联脚本，因此 `scripts` 数组中既包含内联脚本的文本，也包含外联脚本的链接地址，还可能包含识别了 `async` 或 `crossorigin` 的对象信息。红色区域主要用于提取微应用的入口脚本，如果 `<script>` 标签包含了 `entry` 属性，那么可以判定为入口脚本。当然一个微应用只能包含一个入口脚本，如果存在多个，则会抛出错误信息。当然，如果不存在 `entry` 属性，`processTpl` 会将提取的 `scripts` 数组中的最后一个脚本识别为入口脚本。

> 温馨提示：如果需要额外处理微应用的 HTML 模板，在没有显示指定 `entry` 入口文件时，切忌在 HTML 模板的最后添加非入口脚本，否则会被识别出入口脚本，从而导致无法识别微应用需要导出的生命周期函数。

`processTpl` 的源码如下所示：

``` javascript
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2018-09-03 15:04
 */
import { getInlineCode, isModuleScriptSupported, parseUrl } from "./utils";

// 注意一下这些正则表达式中使用了大量的捕获组，捕获组是用括号括起来的部分
// 例如获取 type 属性值的正则表达式: type=('|")?([^>'"\s]+), 其中 ('|")? 是第一个捕获组。([^>'"\s]+) 是第二个捕获组，用于提取 type 属性值
// 例如获取 href 属性值的正则表达式: href=('|")?([^>'"\s]+), 其中 ('|")? 是第一个捕获组。([^>'"\s]+) 是第二个捕获组，用于提取 href 属性值
// 例如获取 src 属性值的正则表达式: src=('|")?([^>'"\s]+), 其中 ('|")? 是第一个捕获组。([^>'"\s]+) 是第二个捕获组，用于提取 src 属性值
// 因为需要从匹配的字符串中提取出属性值，所以需要使用捕获组

const ALL_SCRIPT_REGEX = /(<script[\s\S]*?>)[\s\S]*?</script>/gi;
const SCRIPT_TAG_REGEX =
	/<(script)\s+((?!type=('|")text/ng-template\3).)*?>.*?</\1>/is;

const SCRIPT_SRC_REGEX = /.*\ssrc=('|")?([^>'"\s]+)/;
const SCRIPT_TYPE_REGEX = /.*\stype=('|")?([^>'"\s]+)/;
const SCRIPT_ENTRY_REGEX = /.*\sentry\s*.*/;
const SCRIPT_ASYNC_REGEX = /.*\sasync\s*.*/;
const SCRIPT_CROSSORIGIN_REGEX = /.*\scrossorigin=('|")?use-credentials\1/;
const SCRIPT_NO_MODULE_REGEX = /.*\snomodule\s*.*/;
const SCRIPT_MODULE_REGEX = /.*\stype=('|")?module('|")?\s*.*/;
const LINK_TAG_REGEX = /<(link)\s+.*?>/gis;
const LINK_PRELOAD_OR_PREFETCH_REGEX = /\srel=('|")?(preload|prefetch)\1/;
const LINK_HREF_REGEX = /.*\shref=('|")?([^>'"\s]+)/;
const LINK_AS_FONT = /.*\sas=('|")?font\1.*/;
const STYLE_TAG_REGEX = /<style[^>]*>[\s\S]*?</style>/gi;
const STYLE_TYPE_REGEX = /\s+rel=('|")?stylesheet\1.*/;
const STYLE_HREF_REGEX = /.*\shref=('|")?([^>'"\s]+)/;
const HTML_COMMENT_REGEX = /<!--([\s\S]*?)-->/g;
const LINK_IGNORE_REGEX = /<link(\s+|\s+.+\s+)ignore(\s*|\s+.*|=.*)>/is;
const STYLE_IGNORE_REGEX = /<style(\s+|\s+.+\s+)ignore(\s*|\s+.*|=.*)>/is;
const SCRIPT_IGNORE_REGEX = /<script(\s+|\s+.+\s+)ignore(\s*|\s+.*|=.*)>/is;

function hasProtocol(url) {
	return url.startsWith("http://") || url.startsWith("https://");
}

function getEntirePath(path, baseURI) {
	// URL：https://developer.mozilla.org/zh-CN/docs/Web/API/URL
	// 例如： path = //localhost:8080/css/app.css，baseURI = http://localhost:8080
	// new URL(path, baseURI) 会将 path 拼接到 baseURI 后面，返回一个新的 URL 对象
	// 此时 new URL(path, baseURI).toString() 返回的结果为 http://localhost:8080/css/app.css
	return new URL(path, baseURI).toString();
}

function isValidJavaScriptType(type) {
	const handleTypes = [
		"text/javascript",
		"module",
		"application/javascript",
		"text/ecmascript",
		"application/ecmascript",
	];
	// 如果 type 为空，则返回 true，或者 handleTypes 中包含 type，则返回 true
	// 例如：type 为 text/javascript，则返回 true
	// 例如：<script defer src="/static/js/bundle.js">，type 为空，也返回 true
	return !type || handleTypes.indexOf(type) !== -1;
}

export const genLinkReplaceSymbol = (linkHref, preloadOrPrefetch = false) =>
	`<!-- ${
		preloadOrPrefetch ? "prefetch/preload" : ""
	} link ${linkHref} replaced by import-html-entry -->`;
export const genScriptReplaceSymbol = (
	scriptSrc,
	async = false,
	crossOrigin = false
) =>
	`<!-- ${crossOrigin ? "cors" : ""} ${
		async ? "async" : ""
	} script ${scriptSrc} replaced by import-html-entry -->`;
export const inlineScriptReplaceSymbol = `<!-- inline scripts replaced by import-html-entry -->`;
export const genIgnoreAssetReplaceSymbol = (url) =>
	`<!-- ignore asset ${url || "file"} replaced by import-html-entry -->`;
export const genModuleScriptReplaceSymbol = (scriptSrc, moduleSupport) =>
	`<!-- ${
		moduleSupport ? "nomodule" : "module"
	} script ${scriptSrc} ignored by import-html-entry -->`;

/**
 * parse the script link from the template
 * 1. collect stylesheets
 * 2. use global eval to evaluate the inline scripts
 *    see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Difference_between_Function_constructor_and_function_declaration
 *    see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Do_not_ever_use_eval!
 * @param tpl
 * @param baseURI
 * @param postProcessTemplate
 * @stripStyles whether to strip the css links
 * @returns {{template: void | string | *, scripts: *[], entry: *}}
 */
export default function processTpl(tpl, baseURI, postProcessTemplate) {
	let scripts = [];
	const styles = [];
	let entry = null;
	// 判断浏览器的兼容性，是否支持 <script type=module>
	const moduleSupport = isModuleScriptSupported();

	const template = tpl

		/*
		remove html comment first
		*/

		// HTML_COMMENT_REGEX：/<!--([\s\S]*?)-->/g
		// 该正则表达式可以拆分为：
		// 1 <!--: 匹配 <!-- 开头的字符串
		// 2 ([\s\S]*?): 匹配任意字符，包括换行符，非贪婪模式，即尽可能少的匹配
		//   2.1 [\s\S]: 匹配任意字符，包括换行符
		//     2.1.1 []: 用于定义一个字符集，可以匹配字符集中的任意一个字符，例如常见的 [0-9] 匹配 0 到 9 之间的任意一个数字
		//     2.1.2 \s: 匹配一个空白字符
		//     2.1.3 \S: 匹配一个非空白字符
		//   2.2 *?: 匹配 0 次或多次，非贪婪模式，即尽可能少的匹配
		//     2.2.1 * 表示匹配 0 次或多次
		//     2.2.2 ? 表示非贪婪模式
		// 3 -->: 匹配 --> 结尾的字符串

		// 移除所有的 HTML 注释
		.replace(HTML_COMMENT_REGEX, "")

		// LINK_TAG_REGEX: /<(link)\s+.*?>/gis
		// 例如：<link rel="icon" href="//localhost:8080/favicon.ico">
		// 例如：<link href="//localhost:8080/css/app.css" rel="stylesheet">
		// 该正则表达式可以拆分为：
		// 1 <(link): 匹配 <link 开头的字符串
		// 2 \s+: 匹配一个或多个空白字符
		// 3 .*?: 匹配任意字符，非贪婪模式，即尽可能少的匹配
		// 	 3.1 . 匹配除了换行符之外的任意字符
		//   3.2 * 表示匹配 0 次或多次
		//   3.3 ? 表示非贪婪模式
		// 4 >: 匹配 > 字符

		// 匹配所有的 link 标签
		.replace(LINK_TAG_REGEX, (match) => {
			/*
			change the css link
			*/

			// STYLE_TYPE_REGEX: /\s+rel=('|")?stylesheet\1.*/
			// 例如：<link href="//localhost:8080/css/app.css" rel="stylesheet">
			// 该正则表达式可以拆分为：
			// 1 \s+: 匹配一个或多个空白字符
			// 2 rel=('|")?stylesheet\1: 匹配 rel='stylesheet'、rel="stylesheet" 或 rel=stylesheet
			//   2.1 rel=('|")?: 匹配 rel=' 或 rel=" 或者 rel=，其中 ? 表示匹配 0 次或 1 次
			//     2.1.1 ('|"): 匹配 ' 或 "，其中 | 表示或，() 表示捕获组
			//     2.1.2 ?: 表示匹配 0 次或 1 次
			//   2.2 stylesheet: 匹配 stylesheet
			//   2.3 \1: 反向引用，引用前面的 ('|") 第 1 个捕获组，可以简单理解为就是 ('|") 的引用
			// 3 .*: 匹配任意字符，其中 * 表示匹配 0 次或多次

			// 判读 link 标签中的 rel 属性是否为 stylesheet
			const styleType = !!match.match(STYLE_TYPE_REGEX);
			// styleType 为 true，表示 link 标签中有 rel 属性为 stylesheet，即为 CSS 样式表
			if (styleType) {
				// LINK_HREF_REGEX: /.*\shref=('|")?([^>'"\s]+)/
				// 例如：<link href="//localhost:8080/css/app.css" rel="stylesheet">
				// 该正则表达式可以拆分为：
				// 1 .*: 匹配任意字符
				// 2 \s: 匹配一个空白字符
				// 3 href=('|")?([^>'"\s]+): 匹配 href='、href=" 或 href=，并且匹配 href 属性值
				//   3.1 href=('|")?: 匹配 href=' 或 href=" 或者 href=，其中 ? 表示匹配 0 次或 1 次
				//   3.2 ([^>'"\s]+): 匹配除了 >, ', ", 空白字符之外的任意字符, + 表示匹配一次或多次（如果遇到了 >, ', ", 空白字符就结束匹配）
				//     3.2.1 (): 用于提取匹配的内容，是一个捕获组，用于捕获 href 属性值
				//     3.2.2 []: 用于定义一个字符集，可以匹配字符集中的任意一个字符，例如常见的 [0-9] 匹配 0 到 9 之间的任意一个数字
				//     3.2.3 ^: 在字符集中插入符号 ^ 表示取反，即匹配除了字符集中的字符之外的任意字
				//     3.2.4 >'"\s: 匹配 >, ', ", 空白字符
				//   3.3 (): 捕获组，用于提取匹配的内容，在这里一共有两个捕获组，第一个捕获组用于匹配 href 属性值的引号，第二个捕获组用于匹配 href 属性值

				// 以 <link href="//localhost:8080/css/app.css" rel="stylesheet"> 为例
				// styleHref = [
				// 	"<link href="//localhost:8080/css/app.css", // 整个匹配的字符串
				// 	""", // 第一个捕获组，匹配 href 属性值的引号 "，注意这里的 \ 是转义字符
				// 	"//localhost:8080/css/app.css" // 第二个捕获组，匹配 href 属性值
				// ]

				// 匹配 link 标签中的 href 属性
				const styleHref = match.match(STYLE_HREF_REGEX);

				// LINK_IGNORE_REGEX: /<link(\s+|\s+.+\s+)ignore(\s*|\s+.*|=.*)>/is
				// 例如：<link ignore href="//localhost:8080/css/app.css">
				// 该正则表达式可以拆分为：
				// 1 <link: 匹配 <link 开头的字符串
				// 2 (\s+|\s+.+\s+): 匹配一个或多个空白字符，或者匹配一个或多个空白字符加上任意字符加上一个或多个空白字符
				//   2.1 \s+: 匹配一个或多个空白字符
				//   2.2 \s+.+\s+: 匹配一个或多个空白字符加上任意字符加上一个或多个空白字符
				//     2.2.1 \s+: 匹配一个或多个空白字符
				//     2.2.2 .+: 匹配任意字符，+ 表示匹配一次或多次
				//     2.2.3 \s+: 匹配一个或多个空白字符
				//   2.3 |: 或
				// 3 ignore: 匹配 ignore
				// 4 (\s*|\s+.*|=.*)>: 匹配 0 个或多个空白字符，或者匹配一个或多个空白字符加上任意字符，或者匹配 = 加上任意字符
				//   4.1 \s*: 匹配 0 个或多个空白字符
				//   4.2 \s+.*: 匹配一个或多个空白字符加上任意字符
				//   4.3 =.*: 匹配 = 加上任意字符

				// 这里为什么要加上 ignore 属性的判断呢？
				// 因为有些微应用的 JS 脚本或者 CSS 资源必须放在主应用中加载，不能通过微应用自己的方式加载
				// 此时需要将 link 标签替换为注释信息，不加载 link 标签中的资源
				// 例如：<link ignore href="//localhost:8080/css/app.css"> 会被替换为注释信息
				// 这样微应用的 css 资源就不会被加载，需要将其加入到主应用的模板中
				// 如果微应用需要单独使用（不是在微前端中运行），那么 ignore 的属性不会影响资源的加载，它不是 HTML 标准的属性

				// 匹配 link 标签中的 ignore 属性
				const styleIgnore = match.match(LINK_IGNORE_REGEX);

				// 如果 link 标签中有 href 属性
				if (styleHref) {
					// 获取 href 属性值
					// 例如：<link href="//localhost:8080/css/app.css" rel="stylesheet">
					// href = "//localhost:8080/css/app.css"

					// 这里的 styleHref[2] 就是匹配到的 href 属性值、
					// 因为在 STYLE_HREF_REGEX 中，href 属性值是第二个捕获组
					const href = styleHref && styleHref[2];
					let newHref = href;
					// 如果 href 属性值不是以 http:// 或 https:// 开头，则将其拼接到 baseURI 后面
					if (href && !hasProtocol(href)) {
						// 例如：href = //localhost:8080/css/app.css，baseURI = http://localhost:8080
						// newHref = http://localhost:8080/css/app.css
						newHref = getEntirePath(href, baseURI);
					}

					// 如果 link 标签中有 ignore 属性
					if (styleIgnore) {
						// 将 link 标签替换为注释信息
						// 例如：<link ignore href="//localhost:8080/css/app.css"> 会被替换为注释信息
						// <!-- ignore asset http://localhost:8080/css/app.css replaced by import-html-entry -->
						return genIgnoreAssetReplaceSymbol(newHref);
					}

					// 例如：newHref = "http://example.com/path?query=param&amp;anotherParam=value"
					// 此时 newHref 中的 &amp; 是转义字符，需要将其转换为 & 符号
					// 使用 parseUrl 方法将 newHref 进行解析
					// 返回结果为 http://example.com/path?query=param&anotherParam=value
					newHref = parseUrl(newHref);
					// 将 newHref 添加到 styles 数组中
					styles.push(newHref);
					// 生成 link 标签替换的注释信息
					// 原有的文本 <link href="//localhost:8080/css/app.css" rel="stylesheet"> 会被替换为注释信息
					// <!-- link http://localhost:8080/css/app.css replaced by import-html-entry -->
					return genLinkReplaceSymbol(newHref);
				}
			}

			// 如果 link 标签中没有 rel 属性为 stylesheet，即不是 CSS 样式表
			// 但可能是 preload 或 prefetch，例如：<link rel="preload" href="//localhost:8080/css/app.css">
			// 也可能是 font，例如：<link as="font" href="//localhost:8080/css/app.css">
			// 这里需要对这些 link 标签进行处理
			const preloadOrPrefetchType =
				// LINK_PRELOAD_OR_PREFETCH_REGEX: /\srel=('|")?(preload|prefetch)\1/
				// 例如：<link rel="preload" href="//localhost:8080/css/app.css">
				// 该正则表达式可以拆分为：
				// 1 \srel=('|")?(preload|prefetch)\1: 匹配 rel='preload' 或 rel="preload" 或 rel='prefetch' 或 rel="prefetch" 或 rel=preload 或 rel=prefetch
				// 	 1.1 \s: 匹配一个空白字符
				// 	 1.2 rel=('|")?: 匹配 rel='、rel=" 或 rel=, ? 表示匹配 0 次或 1 次
				// 	 1.3 (preload|prefetch): 匹配 preload 或 prefetch，其中（）是一个分组，可以匹配 preload 或 prefetch
				//   1.4 \1: 反向引用，引用前面的 ('|") 第 1 个捕获组，这样就可以匹配到 rel='preload' 或 rel="preload 尾部的引号

				// 匹配所有的 rel 属性为 preload 或 prefetch 的 link 标签
				match.match(LINK_PRELOAD_OR_PREFETCH_REGEX) &&
				// 匹配所有的 rel 属性为 preload 或 prefetch 的 link 标签中的 href 属性
				// 已经在上面的代码中讲解了该正则表达式
				match.match(LINK_HREF_REGEX) &&
				// LINK_AS_FONT: /.*\sas=('|")?font\1.*/
				// 例如：<link as="font" href="//localhost:8080/css/app.css">
				// 该正则表达式可以拆分为：
				// 1 .*: 匹配任意字符
				// 2 \s: 匹配一个空白字符
				// 3 as=('|")?font\1: 匹配 as='font' 或 as="font" 或 as=font
				//   3.1 as=('|")?: 匹配 as='、as=" 或 as=，其中 ? 表示匹配 0 次或 1 次
				//   3.2 font: 匹配 font
				//   3.3 \1: 反向引用，引用前面的 ('|") 第 1 个捕获组，这样就可以匹配到 as='font' 或 as="font 尾部的引号
				// 4 .*: 匹配任意字符，* 表示匹配 0 次或多次

				// 不匹配 link 标签中的 as 属性为 font 的 link 标签
				!match.match(LINK_AS_FONT);

			// 如果 link 标签中的 rel 属性为 preload 或 prefetch
			// 此时 preloadOrPrefetchType 为 true
			if (preloadOrPrefetchType) {
				// 匹配 link 标签中的 href 属性
				// 因为 href 属性值是第二个捕获组，所以这里是 [2]
				const [, , linkHref] = match.match(LINK_HREF_REGEX);
				// 生成 link 标签替换的注释信息
				// 原有的文本 <link rel="preload" href="//localhost:8080/css/app.css"> 会被替换为注释信息
				// <!-- prefetch/preload link //localhost:8080/css/app.css replaced by import-html-entry -->

				// 这里可以思考一下为什么要将 preload 或 prefetch 的 link 标签替换为注释信息？
				// 为什么要去除 preload 或 prefetch 的能力？
				// 因为不是直接使用 HTML 的方式加载资源，而是通过 import-html-entry 的方式加载资源
				// 只有通过 HTML 的方式加载资源，才会触发浏览器的预加载或预取功能
				// 通过 import-html-entry 的方式加载资源，不会触发浏览器的预加载或预取功能
				return genLinkReplaceSymbol(linkHref, true);
			}
			// 其余情况，直接返回 link 标签
			return match;
		})

		// STYLE_TAG_REGEX: /<style[^>]*>[\s\S]*?</style>/gi
		// 例如：<style>body { color: red; }</style>
		// 该正则表达式可以拆分为：
		// 1 <style: 匹配 <style 开头的字符串
		// 2 [^>]*: 匹配除了 > 之外的任意字符，* 表示匹配 0 次或多次
		// 3 >: 匹配 > 字符
		// 4 [\s\S]*?: 匹配任意字符，非贪婪模式，即尽可能少的匹配
		// 5 </style>: 匹配 </style> 结尾的字符串

		// 匹配所有内联的 style 标签
		.replace(STYLE_TAG_REGEX, (match) => {
			// STYLE_IGNORE_REGEX: /<style(\s+|\s+.+\s+)ignore(\s*|\s+.*|=.*)>/is
			// 例如：<style ignore>body { color: red; }</style>
			// 该正则表达式可以拆分为：
			// 1 <style: 匹配 <style 开头的字符串
			// 2 (\s+|\s+.+\s+): 匹配一个或多个空白字符，或者匹配一个或多个空白字符加上任意字符加上一个或多个空白字符
			//   2.1 \s+: 匹配一个或多个空白字符
			//   2.2 \s+.+\s+: 匹配一个或多个空白字符加上任意字符加上一个或多个空白字符
			//     2.2.1 \s+: 匹配一个或多个空白字符
			//     2.2.2 .+: 匹配任意字符，+ 表示匹配一次或多次
			//     2.2.3 \s+: 匹配一个或多个空白字符
			//   2.3 |: 或
			// 3 ignore: 匹配 ignore
			// 4 (\s*|\s+.*|=.*)>: 匹配 0 个或多个空白字符，或者匹配一个或多个空白字符加上任意字符，或者匹配 = 加上任意字符
			//   4.1 \s*: 匹配 0 个或多个空白字符
			//   4.2 \s+.*: 匹配一个或多个空白字符加上任意字符
			//   4.3 =.*: 匹配 = 加上任意字符
			//   4.4 >: 匹配 > 字符

			// qiankun 识别到 style 标签中有 ignore 属性，不会加载该 style 标签中的样式
			// 而是将该 style 标签替换为注释信息

			// 匹配 ignore 属性的 style 标签
			if (STYLE_IGNORE_REGEX.test(match)) {
				// 将 ignore 属性的 style 标签替换为注释信息
				// 例如：<style ignore>body { color: red; }</style> 会被替换为注释信息
				// <!-- ignore asset style file replaced by import-html-entry -->
				return genIgnoreAssetReplaceSymbol("style file");
			}
			// 如果是内联的 style 标签，直接返回内联的 style 标签
			return match;
		})
		// 例如: <script defer src="/static/js/bundle.js"></scrip>
		// 例如: <script>console.log('inline script')</script>

		// ALL_SCRIPT_REGEX: /<script(\s+|.+?)*>[\s\S]*?</script>/gi
		// 该正则表达式可以拆分为：
		// 1 <script: 匹配 <script 开头的字符串
		// 2 (\s+|.+?)*: 匹配一个或多个空白字符，或者匹配任意字符，非贪婪模式，即尽可能少的匹配，注意这是一个捕获组
		//   2.1 \s+: 匹配一个或多个空白字符
		//   2.2 .+?: 匹配任意字符，非贪婪模式，即尽可能少的匹配
		//   2.3 *: 匹配 0 次或多次
		// 3 >: 匹配 > 字符
		// 4 [\s\S]*?: 匹配任意字符，非贪婪模式，即尽可能少的匹配
		//   4.1 \s: 匹配一个空白字符
		//   4.2 \S: 匹配一个非空白字符
		//   4.3 *: 匹配 0 次或多次
		//   4.4 ?: 非贪婪模式，即尽可能少的匹配
		// 5 </script>: 匹配 </script> 结尾的字符串

		// 匹配所有的 script 标签
		.replace(ALL_SCRIPT_REGEX, (match, scriptTag) => {
			// 匹配 script 标签中的 ignore 属性
			// 类似于上述 style 标签中的 ignore 匹配
			const scriptIgnore = scriptTag.match(SCRIPT_IGNORE_REGEX);
			// 1. 浏览器支持 module 但是 script 标签中有 nomodule 属性
			// 2. 浏览器不支持 module 但是 script 标签中有 type="module" 属性
			// 这两种情况都会被忽略
			const moduleScriptIgnore =
				// SCRIPT_NO_MODULE_REGEX: /.*\snomodule\s*.*/
				// 例如：<script nomodule src="/static/js/bundle.js"></script>
				// 该正则表达式可以拆分为：
				// 1 .*: 匹配任意字符
				// 2 \s: 匹配一个空白字符
				// 3 nomodule: 匹配 nomodule
				// 4 \s*: 匹配 0 个或多个空白字符
				// 5 .*: 匹配任意字符，* 表示匹配 0 次或多次

				// 浏览器支持 module 但是 script 标签中有 nomodule 属性
				(moduleSupport && !!scriptTag.match(SCRIPT_NO_MODULE_REGEX)) ||
				// SCRIPT_MODULE_REGEX: /.*\stype=('|")?module('|")?\s*.*/
				// 例如：<script type="module" src="/static/js/bundle.js"></script>
				// 该正则表达式可以拆分为：
				// 1 .*: 匹配任意字符
				// 2 \s: 匹配一个空白字符
				// 3 type=('|")?module('|")?: 匹配 type='module'、type="module"、type=module
				//   3.1 type=('|")?: 匹配 type=' 或 type=" 或者 type=，其中 ? 表示匹配 0 次或 1 次
				//   3.2 module: 匹配 module
				//   3.3 ('|")?: 匹配 ' 或 "，其中 ? 表示匹配 0 次或 1 次
				// 4 \s*: 匹配 0 个或多个空白字符
				// 5 .*: 匹配任意字符，* 表示匹配 0 次或多次

				// 浏览器不支持 module 但是 script 标签中有 type="module" 属性
				(!moduleSupport && !!scriptTag.match(SCRIPT_MODULE_REGEX));
			// in order to keep the exec order of all javascripts

			// SCRIPT_TYPE_REGEX: /.*\stype=('|")?([^>'"\s]+)/
			// 例如：<script type="text/javascript" src="/static/js/bundle.js"></script>
			// 该正则表达式可以拆分为：
			// 1 .*: 匹配任意字符
			// 2 \s: 匹配一个空白字符
			// 3 type=('|")?: 匹配 type=' 或 type=" 或者 type=，其中 ? 表示匹配 0 次或 1 次
			// 4 ([^>'"\s]+): 匹配除了 >, ', ", 空白字符之外的任意字符，+ 表示匹配一次或多次（如果遇到了 >, ', ", 空白字符就结束匹配）
			//   4.1 (): 用于提取匹配的内容，是一个捕获组，用于捕获 type 属性值，注意这里是第二个捕获组
			//   4.2 []: 用于定义一个字符集，可以匹配字符集中的任意一个字符，例如常见的 [0-9] 匹配 0 到 9 之间的任意一个数字
			//   4.3 ^: 在字符集中插入符号 ^ 表示取反，即匹配除了字符集中的字符之外的任意字
			//   4.4 >'"\s: 匹配 >, ', ", 空白字符
			//   4.5 +: 匹配 1 次或多次（匹配非 >, ', ", 空白字符之外的字符）

			// 匹配 script 标签中的 type 属性
			const matchedScriptTypeMatch = scriptTag.match(SCRIPT_TYPE_REGEX);
			const matchedScriptType =
				// SCRIPT_TYPE_REGEX 正则中有两个捕获组，
				// 第一个捕获组匹配 type 属性的引号
				// 第二个捕获组匹配 type 属性值

				// 在 ('|")? 中 () 有两个主要作用：
				// 1. 分组
				// 括号可以将多个字符组合在一起，然后应用一个或多个正则操作符。
				// 例如，a(bc)? 会匹配一个 'a' 后面跟着零个或多个 'bc'
				// 'bc' 是一个分组，可以使用 ? 来匹配 0 次或 1 次
				// 2. 捕获
				// 括号还可以捕获匹配的文本，以便稍后在表达式中或在后续的代码中使用。
				// 例如，a(bc) 会匹配 'abc'，并且捕获 'bc'

				// 正因为如此，所以 ([^>'"\s]+) 不得已成为了第二个捕获组，而不是第一个捕获组
				matchedScriptTypeMatch && matchedScriptTypeMatch[2];

			// 如果 script 标签的 type 不能判断是否为 JavaScript 脚本，那么不对该 script 标签进行处理
			if (!isValidJavaScriptType(matchedScriptType)) {
				return match;
			}

			// if it is a external script

			// SCRIPT_TAG_REGEX: /<(script)\s+((?!type=('|")text/ng-template\3).)*?>.*?</\1>/is
			// 例如：
			// <script type="text/ng-template" id="tpl1.html">
			// 	<div>Content of tpl1.html</div>
			// </script>

			// 该正则表达式可以拆分为：
			// 1 <(script): 匹配 <script 开头的字符串
			// 2 \s+: 匹配一个或多个空白字符
			// 3 ((?!type=('|")text/ng-template\3).)*?: 匹配除了 type='text/ng-template'、type="text/ng-template" 之外的任意字符
			//   3.1 (?!type=('|")text/ng-template\3): 负向预查，匹配后面不是 type='text/ng-template' 的字符
			//       3.1.1 type=('|")text/ng-template\3: 匹配 type='text/ng-template' 或 type="text/ng-template"
			//       3.1.2 \3: 反向引用，引用前面的 ('|") 第 3 个捕获组，这样就可以匹配到 type='text/ng-template' 或 type="text/ng-template 尾部的引号
			//       3.1.3 ('|"): 匹配 ' 或 "，其中 | 表示或，() 表示捕获组
			//       3.1.4 text/ng-template: 匹配 text/ng-template
			//       3.1.5 (?!) 负向预查，匹配后面不是 type='text/ng-template' 或 type="text/ng-template" 的字符
			//   3.2 .: 匹配任意字符
			//   3.3 *?: 匹配 0 次或多次，非贪婪模式，即尽可能少的匹配
			// 4 >: 匹配 > 字符
			// 5 .*?: 匹配任意字符，非贪婪模式，即尽可能少的匹配
			// 6 </\1>: 匹配 </script> 结尾的字符串，\1 表示引用前面的捕获组，这里是 script

			// SCRIPT_SRC_REGEX: /.*\ssrc=('|")?([^>'"\s]+)/
			// 例如：<script src="/static/js/bundle.js"></script>
			// 该正则表达式可以拆分为：
			// 1 .*: 匹配任意字符
			// 2 \s: 匹配一个空白字符
			// 3 src=('|")?: 匹配 src=' 或 src=" 或者 src=，其中 ? 表示匹配 0 次或 1 次
			// 4 ([^>'"\s]+): 匹配除了 >, ', ", 空白字符之外的任意字符，+ 表示匹配一次或多次（如果遇到了 >, ', ", 空白字符就结束匹配）
			//   4.1 (): 用于提取匹配的内容，是一个捕获组，用于捕获 src 属性值
			//   4.2 []: 用于定义一个字符集，可以匹配字符集中的任意一个字符，例如常见的 [0-9] 匹配 0 到 9 之间的任意一个数字
			//   4.3 ^: 在字符集中插入符号 ^ 表示取反，即匹配除了字符集中的字符之外的任意字
			//   4.4 >'"\s: 匹配 >, ', ", 空白字符
			//   4.5 +: 匹配 1 次或多次（匹配非 >, ', ", 空白字符之外的字符）

			// 1. 匹配 type 不为 text/ng-template 的 script 标签
			//    在 Angular 中，text/ng-template 用于定义模板，并不是 JavaScript 脚本
			// 2. 匹配 script 标签中有 src 属性, 例如：<script src="/static/js/bundle.js"></script>
			// 满足上述两个条件的 script 标签都会被认为是外部的 JavaScript 脚本
			if (SCRIPT_TAG_REGEX.test(match) && scriptTag.match(SCRIPT_SRC_REGEX)) {
				/*
				collect scripts and replace the ref
				*/

				// SCRIPT_ENTRY_REGEX: /.*\sentry\s*.*/
				// 例如：<script entry src="/static/js/bundle.js"></script>

				// 该正则表达式可以拆分为：
				// 1 .*: 匹配任意字符
				// 2 \s: 匹配一个空白字符
				// 3 entry: 匹配 entry
				// 4 \s*: 匹配 0 个或多个空白字符
				// 5 .*: 匹配任意字符，* 表示匹配 0 次或多次

				// 在 qiankun 中，entry 属性用于标识入口脚本
				// 如果 script 标签中有 entry 属性，那么该 script 标签中的 src 属性值就是入口脚本
				// 例如：<script entry src="/static/js/bundle.js"></script>，那么 /static/js/bundle.js 就是入口脚本
				const matchedScriptEntry = scriptTag.match(SCRIPT_ENTRY_REGEX);

				// 再次匹配 script 标签中的 src 属性值
				const matchedScriptSrcMatch = scriptTag.match(SCRIPT_SRC_REGEX);
				// 获取 script 标签中的 src 属性值
				let matchedScriptSrc =
					matchedScriptSrcMatch && matchedScriptSrcMatch[2];

				// 注意最外层的 .replace(ALL_SCRIPT_REGEX, (match, scriptTag) => {})  匹配的是整个 script 标签的内容
				// 如果当前 HTML 有多个 script 标签，那么会多次进入 .replace(ALL_SCRIPT_REGEX, (match, scriptTag) => {}) 中
				// 此时如果在之前的 script 标签中匹配到了 entry 属性，那么会将 entry 属性值赋值给 entry 变量
				// 如果在当前 script 标签中再次匹配到了 entry 属性，那么说明有多个入口脚本，此时会抛出异常
				if (entry && matchedScriptEntry) {
					throw new SyntaxError("You should not set multiply entry script!");
				}

				// 如果当前 script 标签有 src 属性, 例如：<script src="/static/js/bundle.js"></script>
				if (matchedScriptSrc) {
					// append the domain while the script not have a protocol prefix
					// 如果 script 标签中的 src 属性值不是以 http:// 或 https:// 开头，则将其拼接到 baseURI 后面
					if (!hasProtocol(matchedScriptSrc)) {
						// 例如：matchedScriptSrc = //localhost:8080/static/js/bundle.js，baseURI = http://localhost:8080
						// matchedScriptSrc = http://localhost:8080/static/js/bundle.js
						matchedScriptSrc = getEntirePath(matchedScriptSrc, baseURI);
					}
					// 例如：matchedScriptSrc = http://example.com/path?query=param&amp;anotherParam=value
					// 此时 matchedScriptSrc 中的 &amp; 是转义字符，需要将其转换为 & 符号
					// 使用 parseUrl 方法将 matchedScriptSrc 进行解析
					// 返回结果为 http://example.com/path?query=param&anotherParam=value
					matchedScriptSrc = parseUrl(matchedScriptSrc);
				}

				// 识别出入口脚本
				// 如果当前 script 标签中有 entry 属性，那么该 script 标签中的 src 属性值就是入口脚本
				// 例如：<script entry src="/static/js/bundle.js"></script>，那么 /static/js/bundle.js 就是入口脚本
				entry = entry || (matchedScriptEntry && matchedScriptSrc);

				// 如果 script 标签中有 ignore 属性，那么将该 script 标签替换为注释信息
				if (scriptIgnore) {
					// 例如：<script ignore src="/static/js/bundle.js"></script> 会被替换为注释信息
					// <!-- ignore asset /static/js/bundle.js replaced by import-html-entry -->
					return genIgnoreAssetReplaceSymbol(matchedScriptSrc || "js file");
				}

				// 如果浏览器支持 module 但是 script 标签中有 nomodule 属性
				// 或者浏览器不支持 module 但是 script 标签中有 type="module" 属性
				// 那么将该 script 标签替换为注释信息
				if (moduleScriptIgnore) {
					// 返回对应的注释信息
					return genModuleScriptReplaceSymbol(
						matchedScriptSrc || "js file",
						moduleSupport
					);
				}

				// 如果 script 标签中有 src 属性
				if (matchedScriptSrc) {
					// SCRIPT_ASYNC_REGEX: /.*\sasync\s*.*/
					// 例如：<script async src="/static/js/bundle.js"></script>
					// 该正则表达式可以拆分为：
					// 1 .*: 匹配任意字符
					// 2 \s: 匹配一个空白字符
					// 3 async: 匹配 async
					// 4 \s*: 匹配 0 个或多个空白字符
					// 5 .*: 匹配任意字符，* 表示匹配 0 次或多次

					// 匹配 script 标签中的 async 属性
					const asyncScript = !!scriptTag.match(SCRIPT_ASYNC_REGEX);

					// SCRIPT_CROSSORIGIN_REGEX: /.*\scrossorigin=('|")?use-credentials\1/
					// 例如：<script crossorigin="use-credentials" src="/static/js/bundle.js"></script>
					// 该正则表达式可以拆分为：
					// 1 .*: 匹配任意字符
					// 2 \s: 匹配一个空白字符
					// 3 crossorigin=('|")?: 匹配 crossorigin=' 或 crossorigin=" 或者 crossorigin=，其中 ? 表示匹配 0 次或 1 次
					// 4 use-credentials: 匹配 use-credentials
					// 5 \1: 反向引用，引用前面的 ('|") 第 1 个捕获组，这样就可以匹配到 crossorigin='use-credentials' 或 crossorigin="use-credentials" 尾部的引号

					// 匹配 script 标签中的 crossorigin 属性，use-credentials 表示使用凭证
					// use-credentials 会对 window.onerror 捕获的错误堆栈信息产生影响

					// 如果没有使用 crossorigin 属性或没有为跨源脚本配置适当的 CORS 头部，
					// 当跨源脚本发生运行时错误时，这些错误信息默认不会暴露给调用的域，
					// 即 window.onerror 事件处理器不能获取到错误的详细信息，比如行号、错误消息、堆栈信息等，只能得到 "Script error."。

					// 但是，如果你使用了 crossorigin="use-credentials" 并且服务端响应了适当的 CORS 头部，
					// 那么当跨源脚本发生错误时，浏览器会把详细的错误信息提供给 window.onerror 回调，允许开发者捕获并处理这些错误。

					// 例如 React CDN 中使用 crossorigin，详见 https://legacy.reactjs.org/docs/cdn-links.html#why-the-crossorigin-attribute
					const crossOriginScript = !!scriptTag.match(SCRIPT_CROSSORIGIN_REGEX);
					// 将 matchedScriptSrc 添加到 scripts 数组中
					scripts.push(
						asyncScript || crossOriginScript
							? {
									async: asyncScript,
									src: matchedScriptSrc,
									crossOrigin: crossOriginScript,
							  }
							: matchedScriptSrc
					);
					// 生成 script 标签替换的注释信息
					// 例如：<script src="/static/js/bundle.js"></script> 会被替换为注释信息
					// <!-- script /static/js/bundle.js replaced by import-html-entry -->

					// 例如: <script async src="/static/js/bundle.js"></script> 会被替换为注释信息
					// <!-- async script /static/js/bundle.js replaced by import-html-entry -->

					// 例如: <script crossorigin="use-credentials" src="/static/js/bundle.js"></script> 会被替换为注释信息
					// <!-- crossorigin script /static/js/bundle.js replaced by import-html-entry -->
					return genScriptReplaceSymbol(
						matchedScriptSrc,
						asyncScript,
						crossOriginScript
					);
				}

				// 其余情况，直接返回 script 标签
				return match;

				// 如果 script 标签中没有 src 属性，那么该 script 标签就是内联的脚本
			} else {
				// 如果 script 标签中有 ignore 属性，那么将该 script 标签替换为注释信息
				if (scriptIgnore) {
					// 例如：<script ignore>console.log('inline script')</script> 会被替换为注释信息
					// <!-- ignore asset js file replaced by import-html-entry -->
					return genIgnoreAssetReplaceSymbol("js file");
				}

				// 如果浏览器支持 module 但是 script 标签中有 nomodule 属性
				// 或者浏览器不支持 module 但是 script 标签中有 type="module" 属性
				// 那么将该 script 标签替换为注释信息
				// 例如：<script nomodule>console.log('inline script')</script> 会被替换为注释信息
				// <!-- module script js file replaced by import-html-entry -->
				if (moduleScriptIgnore) {
					return genModuleScriptReplaceSymbol("js file", moduleSupport);
				}

				// if it is an inline script
				// 去除 <script>console.log('inline script')</script> 中的 <script> 和 </script>
				// 只保留内联的脚本内容 console.log('inline script')
				const code = getInlineCode(match);

				// remove script blocks when all of these lines are comments.
				// 判断内联脚本是否全是注释
				const isPureCommentBlock = code
					// 通过 split 方法将 code 按照换行符分割为数组
					.split(/[\r\n]+/)
					// 通过 every 方法判断数组中的每一项是否都是注释
					.every((line) => !line.trim() || line.trim().startsWith("//"));

				// 如果内联脚本不全是注释
				if (!isPureCommentBlock) {
					// 将内联脚本添加到 scripts 数组中，注意这里加入的不是 code，而是 match
					// 例如：<script>console.log('inline script')</script> 会被添加到 scripts 数组中
					scripts.push(match);
				}

				// 生成内联脚本替换的注释信息
				// 例如：<script>console.log('inline script')</script> 会被替换为注释信息
				// <!-- inline script replaced by import-html-entry -->
				return inlineScriptReplaceSymbol;
			}
		});

	// 过滤掉空的 script
	scripts = scripts.filter(function (script) {
		// filter empty script
		return !!script;
	});

	let tplResult = {
		template,
		scripts,例如以当前示例项目的 Vue 微应用为例，通过 `window.fetch` 获取的 HTML 文本如下所示：
		styles,
		// set the last script as entry if have not set
		// 如果没有明确在 script 标签中设置 entry 属性
		// 那么将 scripts 数组中的最后一个脚本作为入口脚本
		entry: entry || scripts[scripts.length - 1],
	};

	// postProcessTemplate 是 importHTML 以及 importEntry 方法中 opts 参数的 postProcessTemplate 属性
	// 可以通过外部传入 postProcessTemplate 函数对模板进行后处理
	if (typeof postProcessTemplate === "function") {
		tplResult = postProcessTemplate(tplResult);
	}

	return tplResult;
}
```

例如以当前示例项目的 Vue 微应用为例，通过 `window.fetch` 获取的 HTML 文本如下所示：

``` html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="//localhost:8080/favicon.ico" />
    <title>vue-micro-app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script>
      console.log("inline script");
    </script>
  <script defer src="//localhost:8080/js/chunk-vendors.js"></script><script defer src="//localhost:8080/js/app.js"></script><link href="//localhost:8080/css/app.css" rel="stylesheet"></head>
  <body>
    <noscript>
      <strong
        >We're sorry but vue-micro-app doesn't work
        properly without JavaScript enabled. Please enable it to
        continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
```

> 温馨提示：为了调试 `import-html-entry` 源码，分别在 Vue 应用的 HTML 模板中插入了一个内联样式和内联脚本。


当上述 HTML 通过 `processTpl` 进行正则匹配和替换后，`template` 会得到如下结果：

``` html
<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="//localhost:8080/favicon.ico" />
    <title>vue-micro-app</title>
    <style>
    body {
        margin: 0;
    }
    </style>
    <!-- inline scripts replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/app.js replaced by import-html-entry -->
    <!--  link http://localhost:8080/css/app.css replaced by import-html-entry -->
</head>
<body>
    <noscript>
    <strong
        >We're sorry but vue-micro-app doesn't work
        properly without JavaScript enabled. Please enable it to
        continue.</strong
    >
    </noscript>
    <div id="app"></div>

</body>
</html>
```

而 `scripts`和  `styles` 以及 `entry` 都会被解析出来，如下所示：

``` javascript
// entry
// 没有识别出 <script> 标签中的 entry 属性
// 而是将 scripts 数组中的最后一个元素当做入口脚本
entry = 'http://localhost:8080/js/app.js'

// scripts
// 内联脚本需要被抽离，因为最终不再通过 <script> 标签执行
[
  "<script>\n      console.log("inline script");\n    </script>",
  "http://localhost:8080/js/chunk-vendors.js",
  "http://localhost:8080/js/app.js"
]

// styles
// 注意内联样式不需要抽离，仍然会在 template 中
// 并且最终 styles 中的外联样式也会被嵌入到 template 中成为内联样式
[
  "http://localhost:8080/css/app.css"
]
```

> 温馨提示：可以发现 HTML Entry 中 `stytles`和`scripts` 都是通过正则自动解析出来，这样用户不需要感知 HTML 中存在哪些 JS 脚本以及 Style 样式，而如果通过 Config Entry 的方式引入，则需要手动传入 `stytles`和`scripts`，这样就不需要通过 `processTpl` 进行正则解析了。

#### `getEmbedHTML`

通过 `processTpl` 获取到 `template`、`styles` 以及 `scripts` 后，`import-html-entry` 会将外联的 CSS 样式内联到 HTML 中，会通过 `getEmbedHTML`获取外联的 CSS 样式进行内联处理，如下所示：

``` javascript
// 将外链样式表转换为内联样式表
function getEmbedHTML(template, styles, opts = {}) {
	const { fetch = defaultFetch } = opts;
	let embedHTML = template;
	// 请求获取 HTML 中的外链样式表内容
	return getExternalStyleSheets(styles, fetch).then((styleSheets) => {
		// 将外链样式表替换为内联样式表
		embedHTML = styles.reduce((html, styleSrc, i) => {
			html = html.replace(
				// 之前通过 genLinkReplaceSymbol 生成的占位符，用于替换外链样式表
				genLinkReplaceSymbol(styleSrc),
				// 如果 styleSrc 是内联代码，则直接返回内联代码
				// 如果 styleSrc 是外链样式表地址，则将外链样式表内容转换为内联样式表
				isInlineCode(styleSrc)
					? `${styleSrc}`
					: `<style>/* ${styleSrc} */${styleSheets[i]}</style>`
			);
			return html;
			// 根据之前生成的 HTML Template 和外链样式表内容，生成最终带有内联样式表的 HTML
		}, embedHTML);
		return embedHTML;
	});
}
```

传入 `template` 和外联的 `styles`后，会请求 `styles`中的外联样式，并内联到 `template` 中，例如处理之前的 `template` 如下：

``` html
<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="//localhost:8080/favicon.ico" />
    <title>vue-micro-app</title>
    <style>
    body {
        margin: 0;
    }
    </style>
    <!-- inline scripts replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/app.js replaced by import-html-entry -->
    <!--  link http://localhost:8080/css/app.css replaced by import-html-entry --></head>
<body>
    <noscript>
    <strong
        >We're sorry but vue-micro-app doesn't work
        properly without JavaScript enabled. Please enable it to
        continue.</strong
    >
    </noscript>
    <div id="app"></div>

</body>
</html>
```

请求的 `styles` 如下：

``` javascript
[
  "http://localhost:8080/css/app.css"
]
```

通过 `getEmbedHTML` 处理后，`embedHTML` 如下所示：

``` html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="//localhost:8080/favicon.ico" />
    <title>vue-micro-app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <!-- inline scripts replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry -->
    <!--   script http://localhost:8080/js/app.js replaced by import-html-entry -->
    <style>
    /* http://localhost:8080/css/app.css *//*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/HelloWorld.vue?vue&type=style&index=0&id=469af010&scoped=true&lang=css ***!
  ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

h3[data-v-469af010] {
  margin: 40px 0 0;
}
ul[data-v-469af010] {
  list-style-type: none;
  padding: 0;
}
li[data-v-469af010] {
  display: inline-block;
  margin: 0 10px;
}
a[data-v-469af010] {
  color: #42b983;
}

/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** css ../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/App.vue?vue&type=style&index=0&id=7ba5bd90&lang=css ***!
  ************************************************************************************************************************************************************************************************************************************************************************************************************************************/

#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}

</style></head>
  <body>
    <noscript>
      <strong
        >We're sorry but vue-micro-app doesn't work
        properly without JavaScript enabled. Please enable it to
        continue.</strong
      >
    </noscript>
    <div id="app"></div>

  </body>
</html>
```

可以发现外联的 CSS 链接地址通过 `window.fetch` 请求后被放入 `template`中成为了内联样式。

#### `getExternalStyleSheets`

在 `getEmbedHTML` 中会通过 `getExternalStyleSheets`获取外联 CSS 文本，如下所示：


``` javascript

// for prefetch
export function getExternalStyleSheets(styles, fetch = defaultFetch) {
	return Promise.all(
		styles.map((styleLink) => {
			// 如果 styleLink 是内联代码，则以 < 开头
			// 否则 styleLink 是外链样式表地址
			if (isInlineCode(styleLink)) {
				// if it is inline style
				// 如果是内联样式表，则直接返回内联样式表内容
                // 例如：去除 <script>console.log('inline script')</script> 中的 <script> 和 </script>
				// 只保留内联的脚本内容 console.log('inline script')
				return getInlineCode(styleLink);
			} else {
				// external styles
				// 如果是外部样式表，则通过 fetch 获取样式表内容
				// 并将样式表内容缓存到 styleCache 中
				// 注意这里的 styleCache 存储的是 Promise，而不是样式表内容
				// 如果再次请求相同的样式表，会直接返回缓存的 Promise
				// 此时 Promise 的状态如果是 pending，则会等待 Promise resolve 后再返回
				// 如果 Promise 的状态是 resolved，则直接返回样式表内容
				// 这样可以避免多次请求相同的样式表
				return (
					styleCache[styleLink] ||
					(styleCache[styleLink] = fetch(styleLink).then((response) =>
						// 返回样式表内容
						response.text()
					))
				);
			}
		})
	);
}
```

### `importEntry` 


除了 `importHTML`，`import-html-entry` 还提供了 `importEntry` ，两者分别对应 HTML Entry 和 Config Entry 两种加载微应用的配置方式，重新回顾一下执行流程：

![yuque_diagram (55).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36fc4ab92a14f04b06e4e8acfbc8911~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3291&h=3262&s=818557&e=png&b=ffffff)

Config Entry 对外提供的 `importEntry` API 兼容了 HTML Entry 的处理，如果传入的 `entry` 仍然是 HTML 地址，那么还会调用`imprtHTML` 额外进行处理，否则需要传入 `styles`、`scripts` 以及 `html` 参数，相对于 HTML Entry 缺少了 HTML 解析 `processTpl` 的过程，如下所示：

``` javascript
export function importEntry(entry, opts = {}) {
	const {
		fetch = defaultFetch,
		getTemplate = defaultGetTemplate,
		postProcessTemplate,
	} = opts;
	const getPublicPath =
		opts.getPublicPath || opts.getDomain || defaultGetPublicPath;

	if (!entry) {
		throw new SyntaxError("entry should not be empty!");
	}

	// html entry
	if (typeof entry === "string") {
		return importHTML(entry, {
			fetch,
			getPublicPath,
			getTemplate,
			postProcessTemplate,
		});
	}

	// config entry
	// 如果 entry 是对象，且 entry 中包含 scripts 和 styles
	if (Array.isArray(entry.scripts) || Array.isArray(entry.styles)) {
		const { scripts = [], styles = [], html = "" } = entry;
		// 通过 getHTMLWithStylePlaceholder 方法将 HTML 中的外链样式表替换为占位符
		const getHTMLWithStylePlaceholder = (tpl) =>
			styles.reduceRight(
				(html, styleSrc) => `${genLinkReplaceSymbol(styleSrc)}${html}`,
				tpl
			);
		// 通过 getHTMLWithScriptPlaceholder 方法将 HTML 中的外链脚本替换为占位符
		const getHTMLWithScriptPlaceholder = (tpl) =>
			scripts.reduce(
				(html, scriptSrc) => `${html}${genScriptReplaceSymbol(scriptSrc)}`,
				tpl
			);

		// 基本上和 importHTML 逻辑一致
		return getEmbedHTML(
			getTemplate(
				getHTMLWithScriptPlaceholder(getHTMLWithStylePlaceholder(html))
			),
			styles,
			{ fetch }
		).then((embedHTML) => ({
			template: embedHTML,
			assetPublicPath: getPublicPath(entry),
			getExternalScripts: () => getExternalScripts(scripts, fetch),
			getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),
			execScripts: (proxy, strictGlobal, opts = {}) => {
				if (!scripts.length) {
					return Promise.resolve();
				}
				return execScripts(scripts[scripts.length - 1], scripts, proxy, {
					fetch,
					strictGlobal,
					...opts,
				});
			},
		}));
	} else {
		throw new SyntaxError("entry scripts or styles should be array!");
	}
}
```


## `getExternalScripts`


我们重新回顾一下本课程的示例执行流程，如下所示：

![yuque_diagram (53).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ae7165d82e4b199b8a912b0eadb469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2905&h=1393&s=445311&e=png&b=ffffff)

通过上述的红色文本可以发现，在 single-spa 的 `app` 参数中加载微应用时，主要使用了 `importHTML`、`getExternalScripts` 和 `execScripts` 三个 API。

至此，我们已经将 `importHTML` 的实现分析完毕，它的主要作用是请求微应用的 HTML 文本，提取 `scripts` 以及返回 `embedHTML`（将外联样式内嵌到微应用原有的 HTML 中），在主应用中调用 `importHTML` 后，会将获取的 `embedHTML` 挂载到相应的微应用容器元素上。处理了 HTML 的 CSS 样式后，还需要处理微应用的 JS 脚本，通过调用 `importHTML` 后已经将 `scripts` 提取出来，因此接下来可以通过 `getExternalScripts` 请求获取外联的 JS 脚本，它的实现如下所示：

``` javascript
// for prefetch
export function getExternalScripts(scripts, fetch = defaultFetch) {
	const fetchScript = (scriptUrl, opts) =>
		// 如果 scriptUrl 已经请求过，则直接返回缓存的 Promise
		// 否则通过 fetch 获取脚本内容
		scriptCache[scriptUrl] ||
		(scriptCache[scriptUrl] = fetch(scriptUrl, opts).then((response) => {
			// usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event
			// https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603
			if (response.status >= 400) {
				throw new Error(
					`${scriptUrl} load failed with status ${response.status}`
				);
			}
			// 返回脚本内容
			return response.text();
		}));

	// 通过 Promise.all 获取所有脚本内容
	// 如果脚本是内联代码，则直接返回内联代码
	// 如果脚本是外链脚本地址，则通过 fetch 获取脚本内容
	// 获取的脚本内容会缓存到 scriptCache 中
	return Promise.all(
		scripts.map((script) => {
			// 1. 内联代码
			// 2. 外链脚本地址
			if (typeof script === "string") {
				// 如果是内联代码，则直接返回内联代码
				if (isInlineCode(script)) {
					// if it is inline script
					// 例如：'<script>alert(1)</script>'
					// 返回内联代码内容, 例如：'alert(1)'
					return getInlineCode(script);
				} else {
					// external script
					// 如果是外链脚本地址，则通过 fetch 获取脚本内容
					return fetchScript(script);
				}

				// 1. async script
				// 2. crossOrigin script
			} else {
				// use idle time to load async script
				const { src, async, crossOrigin } = script;
				// 如果是 crossOrigin 脚本，则需要设置 fetch 的 credentials 为 include
				const fetchOpts = crossOrigin ? { credentials: "include" } : {};

				// 如果是 async 脚本，则通过 requestIdleCallback 在空闲时间内加载脚本
				if (async) {
					return {
						src,
						async: true,
						content: new Promise((resolve, reject) =>
							requestIdleCallback(() =>
								fetchScript(src, fetchOpts).then(resolve, reject)
							)
						),
					};
				}
				// 否则直接加载脚本
				return fetchScript(src, fetchOpts);
			}
		})
	);
}
```


## `execScripts`

请求了所有微应用的 JS 脚本后，需要通过 `execScripts` 执行脚本，它的主要执行流程如下所示：

![yuque_diagram (61).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62af6974f2fb4c6fa9b8f150ef025609~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=5013&h=1758&s=824108&e=png&b=fefbfb)

> 温馨提示：由于本课程没有使用沙箱隔离，这里不会赘述沙箱隔离相关的内容，感兴趣的同学可以重新回顾 [原理解析：iframe + Proxy 隔离](https://juejin.cn/book/7258893482318626868/section/7259192856407965711#heading-0)。

`execScripts` 的源码如下所示：


``` javascript
const supportsUserTiming =
	typeof performance !== "undefined" &&
	typeof performance.mark === "function" &&
	typeof performance.clearMarks === "function" &&
	typeof performance.measure === "function" &&
	typeof performance.clearMeasures === "function";

/**
 * FIXME to consistent with browser behavior, we should only provide callback way to invoke success and error event
 * @param entry
 * @param scripts
 * @param proxy
 * @param opts
 * @returns {Promise<unknown>}
 */
export function execScripts(entry, scripts, proxy = window, opts = {}) {
	const {
		fetch = defaultFetch,
		strictGlobal = false,
		success,
		error = () => {},
		beforeExec = () => {},
		afterExec = () => {},
		scopedGlobalVariables = [],
	} = opts;

	// 如果外部使用 import-html-entry 时没有调用 getExternalScripts 方法获取脚本内容
	// 调用 execScripts 时会再次获取脚本内容
	// 如果外部使用 import-html-entry 时已经调用 getExternalScripts 方法获取脚本内容
	// 此时再次调用时会直接获取 scriptCache 中缓存的脚本内容
	return (
		getExternalScripts(scripts, fetch)
			// scriptsText 是所有脚本内容的数组
			// 例如：['alert(1)', 'alert(2)', 'alert(3)']
			.then((scriptsText) => {
				// 例如：geval('<script>alert(1)</script>', 'alert(1)')
				// scriptSrc 为 '<script>alert(1)</script>'
				// inlineScript 为 'alert(1)'
				const geval = (scriptSrc, inlineScript) => {
					// beforeExec 用于处理脚本执行前的逻辑，外部可以通过 beforeExec 方法对脚本进行处理
					// 例如：rawCode 为 'alert(1)'
					const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;
					// 获取可执行的脚本内容
					const code = getExecutableScript(scriptSrc, rawCode, {
						// proxy 为 window，用于代理全局变量
						proxy,
						// 是否是严格模式
						strictGlobal,
						// scopedGlobalVariables 为全局变量数组
						// 例如：['window', 'document', 'location', 'localStorage', 'sessionStorage', 'alert', 'confirm', 'prompt']
						scopedGlobalVariables,
					});
					// 在非严格模式的全局作用域下执行脚本
					evalCode(scriptSrc, code);
					// afterExec 用于处理脚本执行后的逻辑，外部可以通过 afterExec 方法对脚本进行处理
					afterExec(inlineScript, scriptSrc);
				};

				function exec(scriptSrc, inlineScript, resolve) {
					const markName = `Evaluating script ${scriptSrc}`;
					// 用于记录脚本执行的时间
					const measureName = `Evaluating Time Consuming: ${scriptSrc}`;

					// 如果支持 performance API，则记录脚本执行的时间
					if (process.env.NODE_ENV === "development" && supportsUserTiming) {
						// mark 用于记录时间点
						performance.mark(markName);
					}

					// 如果 scriptSrc 是 entry，则执行 entry 脚本
					if (scriptSrc === entry) {
						// 记录入口脚本执行前的 window 对象的第一个属性、第二个属性以及最后一个属性
						noteGlobalProps(strictGlobal ? proxy : window);

						try {
							// 执行 entry 脚本
							geval(scriptSrc, inlineScript);
							// 获取 entry 脚本执行后导出的生命周期函数
							const exports =
								// 通过对比微应用脚本执行之前的 window 对象（noteGlobalProps）和执行之后的 window 对象
								// 可以计算出微应用脚本执行后新增的全局属性，从而计算出导出的生命周期函数
								proxy[getGlobalProp(strictGlobal ? proxy : window)] || {};

							// Promise.resolve(exports) 用于返回微应用导出的生命周期函数
							resolve(exports);
						} catch (e) {
							// entry error must be thrown to make the promise settled
							console.error(
								`[import-html-entry]: error occurs while executing entry script ${scriptSrc}`
							);
							throw e;
						}
						// 如果 scriptSrc 不是 entry，则执行普通脚本
					} else {
						if (typeof inlineScript === "string") {
							try {
								// 例如：scriptSrc.src = 'http://localhost:8080/js/app.js'
								if (scriptSrc?.src) {
									geval(scriptSrc.src, inlineScript);
								} else {
									// 例如： scriptSrc = '<script>alert(1)</script>'
									// 例如： inlineScript = 'alert(1)'
									geval(scriptSrc, inlineScript);
								}
							} catch (e) {
								// consistent with browser behavior, any independent script evaluation error should not block the others
								throwNonBlockingError(
									e,
									`[import-html-entry]: error occurs while executing normal script ${scriptSrc}`
								);
							}
						} else {
							// external script marked with async
							// 执行 async 脚本
							inlineScript.async &&
								// 通过 requestIdleCallback 在空闲时间内加载脚本
								inlineScript?.content
									.then((downloadedScriptText) =>
										geval(inlineScript.src, downloadedScriptText)
									)
									.catch((e) => {
										throwNonBlockingError(
											e,
											`[import-html-entry]: error occurs while executing async script ${inlineScript.src}`
										);
									});
						}
					}

					// 如果支持 performance API，则记录脚本执行的时间
					if (process.env.NODE_ENV === "development" && supportsUserTiming) {
						performance.measure(measureName, markName);
						performance.clearMarks(markName);
						performance.clearMeasures(measureName);
					}
				}

				function schedule(i, resolvePromise) {
					// 如果 i < scripts.length，则表明还有脚本需要执行
					if (i < scripts.length) {
						// 获取 scriptSrc
						// 如果是内联代码，则 scriptSrc 是内联代码内容
						// 如果是外链脚本地址，则 scriptSrc 是外链脚本地址
						// 例如：
						// [
						// 	"<script>\n      console.log("inline script");\n    </script>",
						// 	"http://localhost:8080/js/chunk-vendors.js",
						// 	"http://localhost:8080/js/app.js"
						// ]
						const scriptSrc = scripts[i];

						// 获取 inlineScript
						// inlineScript 是脚本的文本内容
						const inlineScript = scriptsText[i];

						// 执行脚本
						exec(scriptSrc, inlineScript, resolvePromise);
						// resolve the promise while the last script executed and entry not provided
						if (!entry && i === scripts.length - 1) {
							resolvePromise();
						} else {
							schedule(i + 1, resolvePromise);
						}
					}
				}

				// 开始执行所有的脚本
				return new Promise((resolve) => schedule(0, success || resolve));
			})
			.catch((e) => {
				error();
				throw e;
			})
	);
}
```

`getExecutableScript` 的实现如下所示：

``` javascript
// 如果 style 或 script 是内联代码，则以 < 开头
const isInlineCode = (code) => code.startsWith("<");

function getExecutableScript(scriptSrc, scriptText, opts = {}) {
	const { proxy, strictGlobal, scopedGlobalVariables = [] } = opts;

	// 如果 scriptSrc 是内联代码，则不需要设置 sourceURL
	const sourceUrl = isInlineCode(scriptSrc)
		? ""
		: // 否则设置 sourceURL 为 scriptSrc
		  `//# sourceURL=${scriptSrc}\n`;

	// 将 scopedGlobalVariables 拼接成变量声明，用于缓存全局变量，避免每次使用时都走一遍代理

	// 这里用于节省性能，防止每次使用全局变量时都需要通过代理获取
	// 在 qiankun 中为了使内部的微应用执行可以快速访问 history、location 等，
	// 专门进行了作用域内的局部声明，从而防止作用域链查找带来的性能损耗
	const scopedGlobalVariableDefinition = scopedGlobalVariables.length
		? `const {${scopedGlobalVariables.join(",")}}=this;`
		: "";

	// 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上
	// 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy

	// "嵌套场景" 指的是在一个 iframe 或 Web Worker 中运行代码。
	// 例如，有一个主页面，它包含一个 iframe，这个 iframe 又包含另一个 iframe，这就是一个嵌套的场景。

	// 在这种情况下，每个 iframe 都有自己的 window 对象，这些 window 对象是嵌套的。
	// 主页面的 window 对象是最外层的 window 对象，第一个 iframe 的 window 对象是第二层，第二个 iframe 的 window 对象是第三层，依此类推。

	// 这段代码的目的是确保 window.proxy 绑定到全局的 window 对象，而不是内层 iframe 应用的 window 对象。
	// 这样，即使代码在全局作用域运行，闭包里的 window.proxy 也能取到最外层的代理对象。
	const globalWindow = (0, eval)("window");
	globalWindow.proxy = proxy;
	// TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并
	return strictGlobal
		? scopedGlobalVariableDefinition
			? // 关于 Proxy + with 详见课程 iframe + Proxy 隔离：https://juejin.cn/book/7258893482318626868/section/7259192856407965711#heading-2
			  // 当然在这里使用 with 是因为 scopedGlobalVariableDefinition 里面的变量是需要在 with 作用域下的，使用 with 可以缩短作用域链查找的时间
			  `;(function(){with(this){${scopedGlobalVariableDefinition}${scriptText}\n${sourceUrl}}}).bind(window.proxy)();`
			: `;(function(window, self, globalThis){with(window){;${scriptText}\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`
		: // globalThis: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis
		  // globalThis 指代 window 对象，本质上是为了解决不同环境的代码移植性问题
		  `;(function(window, self, globalThis){;${scriptText}\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;
}
```


其中 `evalCode`的实现如下所示：

``` javascript
// 在非严格模式的全局作用域中执行 JavaScript 代码，同时缓存已经解析过的代码
export function evalCode(scriptSrc, code) {
	// 例如：scriptSrc = 'http://localhost:8080/entry.js'
	// 例如：scriptSrc = '<script>var a = 123;</script>'
	// 例如：code: ;(function(window, self, globalThis){;
	//   var a = 123;
	// }).bind(window.proxy)(window.proxy, window.proxy, window.proxy);
	const key = scriptSrc;
	// 检测是否已经缓存了该代码
	if (!evalCache[key]) {
		// 例如： (function(){;(function(window, self, globalThis){;var a = 123;}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);})'
		// 例如： (function(){;(function(){with(this){var a = 123;}}).bind(window.proxy)();})'
		const functionWrappedCode = `(function(){${code}})`;
		// 通过 (0, eval) 执行的函数，其作用域是全局作用域
		// 因此这里得到了一个在全局作用域下执行的函数

		// 除此之外，间接调用的 eval（0,eval） 还会在非严格模式下执行代码，因此内部可以使用 with 语句（默认情况下严格模式才能使用 with）
		// 当然，如果显示指定 "use strict"，则会在严格模式下执行代码；例如：(0, eval("use strict; var a = 123;"))
		// 在严格模式下间接调用 eval （0,eval）也是非严格模式下执行
		evalCache[key] = (0, eval)(functionWrappedCode);
	}
	// evalFun 是一个函数，该函数因为使用了 (0, eval)，所在是在全局作用域下执行
	const evalFunc = evalCache[key];
	// 执行 evalFunc 函数
	evalFunc.call(window);
}
```


## 小结

本课程通过改造已有的 `single-spa` 示例，结合 `import-html-entry` 的使用和源码解析，使大家对 HTML Entry 的功能有了详细的认知，其实在 qiankun 的源码实现中，就是将这两者结合起来使用，并增强了微应用脚本的沙箱隔离能力。在下一个课程中，我们会详细讲解 qiankun 的内部实现。