本课程主要讲解如何书写符合规范的提交说明，并基于提交说明自动生成变更日志。为了使得大家更好的理解课程设计，接下来会按照以下内容进行讲解：

![yuque_diagram (1).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd3bbabfa9e94d638f10f3d2f2d10420~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2102&h=1628&s=339847&e=png&b=ffffff)

## 提交说明

在 Git 中进行代码提交都需要手写**提交说明**（Commit Message）：

``` bash
git commit -m "hello world"
```

如果**提交说明**语义不清晰则很难阐述当前提交代码的目的，例如提交是为了修复 Bug、优化性能、新增功能还是发布版本？查看 Vue 项目的 Git **提交说明**：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de7af459fae49bebf1e7fe14c6b1588~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1109&h=868&e=png&b=ffffff)

在上述提交说明中，可以很清晰的知道每一次提交的类型和作用：

-   `feat`：新增一个功能
-   `fix`：修复一个 Bug
-   `chore`：变更构建流程或者辅助工具
-   `refactor`： 进行代码重构
-   `test`：测试变更

如果将这些提交说明放在需要发布的变更日志里，那么立马就能看明白在历史的各个版本里修复了什么 Bug 以及新增了什么功能，因此语义化的提交说明可以用于生成变更日志，例如 Vue 的[变更日志](https://github.com/vuejs/vue/blob/main/CHANGELOG.md)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d415b34112479b9f646cc6a46a811e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2250&h=1394&e=png&b=ffffff)

> 温馨提示：上述版本日志信息可以在 [Commit 列表](https://github.com/vuejs/vue/commits/)中一一找到对应的提交说明。

开发者可以从上述日志中查看 Bug 修复对应的 Commit 提交说明、Pull Request 链接、Issue 链接以及代码提交链接。当然 Vue 的日志并不是手动生成，需要基于规范的提交说明并配套相应的工具自动生成。

## 提交说明规范

为了生成类似于 Vue 这样的变更日志，首先需要提交规范的 Git 说明。社区很早以前就出现了一些 Git 提交说明的规范，目前使用最广的是[ Angular 规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.uyo6cb12dt6w)，它的主要作用如下：

-   可以通过脚本工具自动生成变更日志
-   能忽视一些不重要的提交说明，例如代码格式化
-   在浏览历史提交记录时能够提供更好的语义说明

为了实现上述目的，在 Angular 规范中提供了提交说明的格式规范，需要包含三个部分：

``` bash
<type>(<scope>): <subject>   # <header>
<BLANK LINE>                 # 换行
<body>                       # <body> 
<BLANK LINE>                 # 换行
<footer>                     # <footer>
```

### Header

Header 包括三个字段`type`（必需）、`scope`（可选）和`subject`（必需）：

``` bash
<type>(<scope>): <subject>
# 例如 type => feat 
# scope => Button 
# subject => 新增 Button 组件
feat(Button): 新增 Button 组件
```

`type` 用于描述 Git 的提交类型：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/159992084b6842e7b073661e7b023f21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1220&h=552&e=png&b=ffffff)

> 温馨提示： `feat` 和 `fix` 必须放入变更日志。

`scope` 用于描述 Git 提交的影响范围， 范围可以依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分。如果是组件库开发，则可以依据组件划分。如果是工具库，则可以根据依据文件名称或功能类型划分。

`subject`是 Git 提交的简短描述，一般需要：

-   使用第一人称的动作表述，不要使用被动句和第三人称表述
-   如果是英文，第一个字母小写
-   结尾不需要加句号（. 或者 。）

### Body

Body 是 Git 提交的详细描述，说明提交代码的详细作用，可以分成多行进行说明：

-   提交尽量不超过 50 个字符
-   使用第一人称的动作表述，不要使用被动句和第三人称表述
-   描述包含代码变更的动机以及和变更之前的行为对比

在大部分场景下， Header 的 `subject` 可以满足提交说明的描述功能，因此 Body 不是必需的。在书写说明时，应该使用 `subject` 尽可能的描述清楚本次提交的目的。

> 温馨提示：在本课程的演示中，对 `subject` 进行了非常简短的说明，而对 Body 进行了非常详细的说明设计，其实对于生成变更日志而言不是特别友好，大家在学习本课程的时候可以重点观察一下。

> 温馨提示：更多关于 Body 规范的描述可以查看[ Writing Git commit messages](https://365git.tumblr.com/post/3308646748/writing-git-commit-messages) 和 [A Note About Git Commit Messages](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)。

### Footer

Footer 只在提交的代码有非兼容性更新以及需要关联 issues 时才需要使用。当前代码与上一个版本不兼容，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述以及变动的理由和迁移方法，例如：

``` bash
BREAKING CHANGE: isolate scope bindings definition has changed and
    the inject option for the directive controller injection was removed.
    
    To migrate the code follow the example below:
    
    Before:
    
    scope: {
      myAttr: 'attribute',
      myBind: 'bind',
      myExpression: 'expression',
      myEval: 'evaluate',
      myAccessor: 'accessor'
    }
    
    After:
    
    scope: {
      myAttr: '@',
      myBind: '@',
      myExpression: '&',
      // myEval - usually not useful, but in cases where the expression is assignable, you can use '='
      myAccessor: '=' // in directive's template change myAccessor() to myAccessor
    }
    
    The removed inject wasn't generaly useful for directives so there should be no code using it.
```

如果当前提交的代码是进行 Bug 修复，并且需要关联对应 Bug 的 issues，那么可以使用 Footer：

``` bash
# 关联单个需要关闭的 issues
Closes #234
# 关联多个需要关闭的 issues
Closes #123, #245, #992
```

### 示例

完整的 Anguar 规范提交说明如下所示：

``` bash
# <header>
# <type>(<scope>): <subject> 
# type: feat
# scope: directive
# subject: ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected
feat(directive): ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected
# <BLANK LINE> Header 和 Body 之间需要空一行

# <body>         
New directives for proper binding these attributes in older browsers (IE).
Added coresponding description, live examples and e2e tests.
# <BLANK LINE> Body 和 Footer 之间需要空一行

# <footer>
Closes #351
```

## Commitizen

手写 Anguler 规范的提交说明难免会产生错误，因此社区产生了可以撰写提交说明的工具 [commitizen](https://github.com/commitizen/cz-cli)。在官方文档的说明中提供了全局安装 commitizen 的方式，这里为了让所有开发者使用统一的 commitizen 版本，可以在项目中进行局部安装和使用：

``` bash
# 其他协作的开发者不需要感知 commitizen 的安装
# 查看 node_modules/commitizen/package.json 的 bin 字段可以发现
# 对外提供了 cz 和 git cz 命令，通过使用这两个命令代替 git commit 操作
# commitizen 示例固定 4.3.0 版本
npm install --save-dev commitizen
```

安装完成后可以通过 `git cz` 命令代替 `git commit` 命令执行，由于使用局部安装，可以在 `package.json` 中配置 `git cz` 命令，如下所示：

``` json
// package.json
"scripts": {
  "cz": "git cz"
},
```

此时执行 `npm run cz` 等同于执行了 `git commit` 命令：

``` bash
# 执行（等同于执行 git commit）
npm run cz

# 打印

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch demo/changelog-cz
# Changes to be committed:
#       modified:   package-lock.json
#       modified:   package.json
#
# Changes not staged for commit:
#       modified:   package.json
#
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~                                                                                 
~   
```

commitizen 提供了适配器用于扩展自身的能力（可以简单理解为插件），开发者可以自己设计适配器，也可以使用别人设计好的适配器。本文主要介绍几个常用的适配器：

-   [cz-conventional-changelog](https://github.com/commitizen/cz-conventional-changelog)：生成符合 Auglar 规范的提交说明
-   [cz-customizable](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fleonardoanalista%2Fcz-customizable)：定制提交说明


通过执行 `npm run cz` 可以发现只安装 commitizen 并没有任何能力增强，我们继续安装可以生成 Auglar 规范提交说明的适配器 cz-conventional-changelog：

``` bash
# 查看 node_modules/commitizen/package.json 的 bin 字段可以发现 
# 除了对外提供了 cz 和 git-cz 命令，还提供了 commitizen 命令 
# commitizen 命令只有一个 init 动作 
# cz-conventional-changelog 示例固定 3.3.0 版本 
npx commitizen init cz-conventional-changelog --save --save-exact
```

`commitizen init` 命令主要用于快速增加 commitizen 适配器，执行过程如下所示：

-   解析适配器的参数（Yarn、NPM 的安装参数、`--force` 等）
-   判断是否存在其他适配器，如果存在则报错并提示使用 `--force` 参数强制覆盖
-   安装适配器并将依赖保存到 `package.json` 的 `devDependencies` 字段信息
-   在 `package.json` 中新增或者更改适配器 cz-conventional-changelog 的路径

> 温馨提示：从 commitizen 命令可以看出在 commitizen 中只能使用一个适配器，不能让多个适配器共存。


如果当前已经有其他适配器被使用则会报以下错误，此时如果仍然需要替换适配器，可以加上 `--force` 进行强制覆盖：

``` bash
Error: A previous adapter is already configured. Use --force to override
```
 
`commitizen init` 命令执行后会在 `package.json` 中新增或者更改 commitizen 的适配器 cz-conventional-changelog 路径，如下所示：

``` json
"config": {
  "commitizen": {
    // 适配器路径，也可以是 cz-conventional-changelog，在源码中是通过 require 加载
    "path": "./node_modules/cz-conventional-changelog"
  }
}
```


添加了 cz-conventional-changelog 适配器后，我们再次执行 `npm run cz`：

``` bash
# 执行
npm run cz

# 打印
> micro-framework@1.0.6 cz
> git cz

cz-cli@4.3.0, cz-conventional-changelog@3.3.0

? Select the type of change that you're committing: (Use arrow keys)
❯ feat:     A new feature 
  fix:      A bug fix 
  docs:     Documentation only changes 
  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing 
semi-colons, etc) 
  refactor: A code change that neither fixes a bug nor adds a feature 
  perf:     A code change that improves performance 
(Move up and down to reveal more choices)
```

此时可以通过工具生成符合 Angular 规范的提交说明了，如下所示：

![提交说明.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0740e0b0dd0455781abd4845e8f4fbd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1456&h=950&e=gif&f=574&b=1b1b1b)

注意不要被这里的演示误导，应该尽可能详细的书写短说明 subject，而不是长说明 Body，因为 subject 是必须的，后续有助于生成变更日志，而长说明会被变更日志忽略。

> 温馨提示：示例源码可以从 [demo/changelog-cz](https://github.com/ziyi2/micro-framework/tree/demo/changelog-cz) 分支获取。为什么这里没有触发 lint-staged 校验呢？


### commitizen 工作原理

commitizen 构建后的代码相对难以阅读，这里以源码为例进行讲解，首先看下 CLI 的入口 `bin` 配置信息：

``` javascript
// package.json
"bin": {
  "cz": "./bin/git-cz",
  "git-cz": "./bin/git-cz",
  // 用于执行 commitizen init
  "commitizen": "./bin/commitizen"
},
```

当执行 `git cz` 时指向了 `bin/git-cz` 文件：

``` javascript
// bin/git-cz

// 熟悉的 Shebang，注意省略了 .js 后缀
// git-cz 文件会被 Node 解析执行
#!/usr/bin/env node

require('./git-cz.js');
```

`git-cz.js` 的代码如下所示：

``` javascript
var path = require('path');

process.on('uncaughtException', function (err) {
  console.error(err.message || err);
  process.exit(1);
});

// catch SIGINT signal
process.stdin.on('data', function (key) {
  if (key == '\u0003') {
    process.exit(130); // 128 + SIGINT
  }
});

// dist 是构建目录，这里可以查看 src/cli/git-cz.js 文件
require('../dist/cli/git-cz.js').bootstrap({
  cliPath: path.join(__dirname, '../')
});

```

`src/cli/git-cz.js` 的代码如下所示：

``` javascript
// src/cli/git-cz.js
import { configLoader } from '../commitizen';
import { git as useGitStrategy, gitCz as useGitCzStrategy } from './strategies';

export {
  bootstrap
};

/**
 * This is the main cli entry point.
 * environment may be used for debugging.
 */
function bootstrap (environment = {}, argv = process.argv) {

  // Get cli args
  // 获取 CLI 命令的解析参数
  let rawGitArgs = argv.slice(2, argv.length);
  
  // 解析适配器的配置信息（包括 path 路径）
  // 在之前的演示中主要解析 commitizen init 之后在 package.json 的 config 中生成的适配器配置信息
  let adapterConfig = environment.config || configLoader.load();

  // Choose a strategy based on the existance the adapter config
  if (typeof adapterConfig !== 'undefined') {
    // This tells commitizen we're in business
    // 使用适配器后进行执行
    useGitCzStrategy(rawGitArgs, environment, adapterConfig);
  } else {
    // This tells commitizen that it is not needed, just use git
    // 使用原生的 git commit 进行执行
    useGitStrategy(rawGitArgs, environment);
  }
}

```

可以发现默认的 `environment` 没有传入 `config` 配置，因此从 `configLoader.load()` 中获取适配器的配置信息，跟踪代码可以发现最后获取配置的操作如下所示：

``` javascript
// src/configLoager/getNormalizedConfig.js

export default getNormalizedConfig;

// Given a config and content, plucks the actual
// settings that we're interested in
function getNormalizedConfig (config, content) {

  // 如果从 package.json 中获取配置
  if (content && (config === 'package.json')) {

  // PACKAGE.JSON

    // Use the npm config key, be good citizens
    if (content.config && content.config.commitizen) {
      // 读取 package.json 的 config 字段信息
      // 可以查看之前使用 commitizen init 生成的配置信息
      // "config": {
      //    "commitizen": {
                // 适配器路径，也可以是 cz-conventional-changelog，在源码中是通过 require 加载
                // "path": "./node_modules/cz-conventional-changelog"
      //     }
      // }
      
      // 返回了适配器的配置信息（包括 path 路径）
      return content.config.commitizen;
    } else if (content.czConfig) { // Old method, will be deprecated in 3.0.0

      // Suppress during test
      if (typeof global.it !== 'function')
      {
        console.error("\n********\nWARNING: This repository's package.json is using czConfig. czConfig will be deprecated in Commitizen 3. \nPlease use this instead:\n{\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"./path/to/adapter\"\n    }\n  }\n}\nFor more information, see: http://commitizen.github.io/cz-cli/\n********\n");
      }
      return content.czConfig;
    }
  } else {
    // .cz.json or .czrc
    return content;
  }

}

```

重新回到 `bootstrap` 函数，获取适配器的参数后会通过 `useGitCzStrategy` 执行：

``` javascript
// src/strategies/git-cz.js

import inquirer from 'inquirer';
import findRoot from 'find-root';
import { getParsedPackageJsonFromPath } from '../../common/util';
import { gitCz as gitCzParser, commitizen as commitizenParser } from '../parsers';
import { commit, staging, adapter } from '../../commitizen';
import * as gitStrategy from './git';

// destructure for shorter apis
let { parse } = gitCzParser;

let { getPrompter, resolveAdapterPath, getGitRootPath } = adapter;
let { isClean } = staging;

// 外部引入时重命名为 useGitCzStrategy 函数
export default gitCz;

function gitCz (rawGitArgs, environment, adapterConfig) {

  // See if any override conditions exist.

  // In these very specific scenarios we may want to use a different
  // commit strategy than git-cz. For example, in the case of --amend
  let parsedCommitizenArgs = commitizenParser.parse(rawGitArgs);
    
  // 如果存在 --amend 参数，则直接使用 git commit 
  if (parsedCommitizenArgs.amend) {
    // console.log('override --amend in place');
    gitStrategy.default(rawGitArgs, environment);
    return;
  }

  // Now, if we've made it past overrides, proceed with the git-cz strategy
  let parsedGitCzArgs = parse(rawGitArgs);

  // Determine if we need to process this commit as a retry instead of a
  // normal commit.
  let retryLastCommit = rawGitArgs && rawGitArgs[0] === '--retry';

  // Determine if we need to process this commit using interactive hook mode
  // for husky prepare-commit-message
  let hookMode = !(typeof parsedCommitizenArgs.hook === 'undefined');

  // 这里计算适配器的路径，可以发现读取的就是 package.json config 中的适配器参数
  let resolvedAdapterConfigPath = resolveAdapterPath(adapterConfig.path);
  let resolvedAdapterRootPath = findRoot(resolvedAdapterConfigPath);
  
  // 获取适配器的 prompter，适配器必须要提供这个入口函数
  let prompter = getPrompter(adapterConfig.path);
  let shouldStageAllFiles = rawGitArgs.includes('-a') || rawGitArgs.includes('--all');

  isClean(process.cwd(), function (error, stagingIsClean) {
    if (error) {
      throw error;
    }

    if (stagingIsClean && !parsedGitCzArgs.includes('--allow-empty')) {
      throw new Error('No files added to staging! Did you forget to run git add?');
    }

    // OH GOD IM SORRY FOR THIS SECTION
    let adapterPackageJson = getParsedPackageJsonFromPath(resolvedAdapterRootPath);
    let cliPackageJson = getParsedPackageJsonFromPath(environment.cliPath);
    console.log(`cz-cli@${cliPackageJson.version}, ${adapterPackageJson.name}@${adapterPackageJson.version}\n`);
    
    // 调用 commit 函数
    commit(inquirer, getGitRootPath(), prompter, {
      args: parsedGitCzArgs,
      disableAppendPaths: true,
      emitData: true,
      quiet: false,
      retryLastCommit,
      hookMode
    }, function (error) {
      if (error) {
        throw error;
      }
    });
  }, shouldStageAllFiles);

}
```


重点来看一下 `getPrompter` 是如何获取适配器的 `prompter` 函数：

``` javascript
// src/commitizen/adapter.js

import childProcess from 'child_process';
import path from 'path';
import fs from 'fs';
import findNodeModules from 'find-node-modules';
import _ from 'lodash';
import detectIndent from 'detect-indent';

import { isFunction } from '../common/util';

/**
 * Gets the prompter from an adapter given an adapter path
 */
function getPrompter (adapterPath) {
  // Resolve the adapter path
  let resolvedAdapterPath = resolveAdapterPath(adapterPath);

  // Load the adapter
  // 通过 require 加载适配器
  let adapter = require(resolvedAdapterPath);

  /* istanbul ignore next */
  // 适配器必须抛出 prompter 供 commitizen 调用
  if (adapter && adapter.prompter && isFunction(adapter.prompter)) {
     return adapter.prompter;
  } else if (adapter && adapter.default && adapter.default.prompter && isFunction(adapter.default.prompter)) {
     return adapter.default.prompter;
  } else {
    throw new Error(`Could not find prompter method in the provided adapter module: ${adapterPath}`);
  }
}

/**
 * Given a resolvable module name or path, which can be a directory or file, will
 * return a located adapter path or will throw.
 */
function resolveAdapterPath (inboundAdapterPath) {
  // Check if inboundAdapterPath is a path or node module name
  let parsed = path.parse(inboundAdapterPath);
  let isPath = parsed.dir.length > 0 && parsed.dir.charAt(0) !== "@";

  // Resolve from the root of the git repo if inboundAdapterPath is a path
  let absoluteAdapterPath = isPath ?
    path.resolve(getGitRootPath(), inboundAdapterPath) :
    inboundAdapterPath;

  try {
    // try to resolve the given path
    return require.resolve(absoluteAdapterPath);
  } catch (error) {
    error.message = "Could not resolve " + absoluteAdapterPath + ". " + error.message;
    throw error;
  }
}

function getGitRootPath () {
  return childProcess.spawnSync('git', ['rev-parse', '--show-toplevel'], { encoding: 'utf8' }).stdout.trim();
}

```

获取了适配器的 `prompter` 之后，我们来看下最终的 `commit` 函数执行：

``` javascript
// src/commitizen/commit.js


/**
 * Takes all of the final inputs needed in order to make dispatch a git commit
 */
function dispatchGitCommit (repoPath, template, options, overrideOptions, done) {
    // Commit the user input -- side effect that we'll test
    // 提交适配器返回的用户输入的说明信息 
    gitCommit(repoPath, template, { ...options, ...overrideOptions }, function (error) {
      done(error, template);
    });
}


 /**
  * Asynchronously commits files using commitizen
  */
function commit (inquirer, repoPath, prompter, options, done) {
  var cacheDirectory = cacheDir('commitizen');
  var cachePath = path.join(cacheDirectory, 'commitizen.json');

  ensureDir(cacheDirectory, function (error) {
    if (error) {
      console.error("Couldn't create commitizen cache directory: ", error);
      // TODO: properly handle error?
    } else {
      if (options.retryLastCommit) {

        console.log('Retrying last commit attempt.');

        // We want to use the last commit instead of the current commit,
        // so lets override some options using the values from cache.
        let {
          options: retryOptions,
          overrideOptions: retryOverrideOptions,
          template: retryTemplate
        } = cache.getCacheValueSync(cachePath, repoPath);
        dispatchGitCommit(repoPath, retryTemplate, retryOptions, retryOverrideOptions, done);

      } else {
      
        // 执行适配器提供的 prompter 函数来获取用户输入
        // Get user input -- side effect that is hard to test
        prompter(inquirer, function (error, template, overrideOptions) {
          // Allow adapters to error out
          // (error: Error?, template: String, overrideOptions: Object)
          if (!(error instanceof Error)) {
            overrideOptions = template;
            template = error;
            error = null;
          }

          if (error) {
            return done(error);
          }

          // We don't want to add retries to the cache, only actual commands
          cache.setCacheValueSync(cachePath, repoPath, { template, options, overrideOptions });
          
          // template 是通过执行适配器后获取的 git message 信息
          // 最终会调用 git commit -m 执行提交说明
          dispatchGitCommit(repoPath, template, options, overrideOptions, done);
        });
      }
    }
  });

}
```

在执行适配器提供的 `prompter` 函数后，会通过提供的 `inquirer` 工具回调最终用户输入的 commit 信息，最后会通过 `dispatchGitCommit` 函数执行原始的 `git commit -m` 操作。`gitCommit` 最后的操作如下所示：

``` javascript
// src/git/commit.js

import { execSync, spawn } from 'child_process';

import path from 'path';

import { writeFileSync, openSync, closeSync } from 'fs';

import dedent from 'dedent';

export { commit };

/**
 * Asynchronously git commit at a given path with a message
 */
function commit (repoPath, message, options, done) {
  let called = false;

  // commit the file by spawning a git process, unless the --hook
  // option was provided. in that case, write the commit message into
  // the .git/COMMIT_EDITMSG file
  if (!options.hookMode) {
     
     // 最终还是通过 git commit -m 提交说明
    let args = ['commit', '-m', dedent(message), ...(options.args || [])];
    let child = spawn('git', args, {
      cwd: repoPath,
      stdio: options.quiet ? 'ignore' : 'inherit'
    });

    child.on('error', function (err) {
      if (called) return;
      called = true;

      done(err);
    });

    child.on('exit', function (code, signal) {
      if (called) return;
      called = true;

      if (code) {
        if (code === 128) {
          console.warn(`
            Git exited with code 128. Did you forget to run:

              git config --global user.email "you@example.com"
              git config --global user.name "Your Name"
            `)
        }
        done(Object.assign(new Error(`git exited with error code ${code}`), { code, signal }));
      } else {
        done(null);
      }
    });
  } else {
    const gitDirPath = execSync(
      'git rev-parse --absolute-git-dir',
      { cwd: repoPath, encoding: 'utf8' },
    ).trim();
    const commitFilePath = path.join(gitDirPath, 'COMMIT_EDITMSG');
    try {
      const fd = openSync(commitFilePath, 'w');
      try {
        writeFileSync(fd, dedent(message));
        done(null);
      } catch (e) {
        done(e);
      } finally {
        closeSync(fd);
      }
    } catch (e) {
      // windows doesn't allow opening existing hidden files
      // in 'w' mode... but it does let you do 'r+'!
      try {
        const fd = openSync(commitFilePath, 'r+');
        try {
          writeFileSync(fd, dedent(message));
          done(null);
        } catch (e) {
          done(e);
        } finally {
          closeSync(fd);
        }
      } catch (e) {
        done(e);
      }
    }
  }
}

```

从上述 commitizen 的代码执行流程可以发现，commitizen 需要获取适配器提供的 commit message 信息来执行 `git commit -m`，具体流程如下所示：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8b7131b5d74ae39383f9822dac8fe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1674&h=564&e=jpg&b=fefefe)

上述流程是一个简单的示意流程，在真正设计的过程中，还包含 Git 的参数解析，例如 `--allow-empty`、`--retry`、`--amend` 等。

> 温馨提示：学习 huksy、lint-staged、commitizen 以及 cz-conventional-changelog 等三方库的源码，了解内部的一些 Git 操作，有助于加深对于工程化设计的理解。例如提供一个工具库，如何设计它的配置文件，如何获取配置，如何设计它的可扩展能力等，当然也有助于在实际的项目中简单使用 Node 脚本设计工程自动化。


### cz-conventional-changelog 工作原理


cz-conventional-changelog 的代码非常简单，主要利用 commitizen 提供的 [inquirer](https://github.com/SBoudrias/Inquirer.js) 让用户提供信息，从而生成 Angular 规范的 commit 信息供 commitizen 进行 `git commit` 操作：

``` javascript
// cz-conventional-changelog：3.3.0 
// 查看 node_modules/cz-conventional-changelog/package.json 中的 main 字段信息找到入口文件
// node_modules/cz-conventional-changelog/index.js

'format cjs';

var engine = require('./engine');
var conventionalCommitTypes = require('conventional-commit-types');
var configLoader = require('commitizen').configLoader;

// 最终会调取 commitizen 的 getNormalizedConfig.js 获取 commitizen 的配置信息
var config = configLoader.load() || {};
var options = {
  // 获取提交类型 
  // Angular 规范中 Header 部分 <type>(<scope>): <subject> 的 type
  types: config.types || conventionalCommitTypes.types,
  defaultType: process.env.CZ_TYPE || config.defaultType,
  defaultScope: process.env.CZ_SCOPE || config.defaultScope,
  defaultSubject: process.env.CZ_SUBJECT || config.defaultSubject,
  defaultBody: process.env.CZ_BODY || config.defaultBody,
  defaultIssues: process.env.CZ_ISSUES || config.defaultIssues,
  disableScopeLowerCase:
    process.env.DISABLE_SCOPE_LOWERCASE || config.disableScopeLowerCase,
  disableSubjectLowerCase:
    process.env.DISABLE_SUBJECT_LOWERCASE || config.disableSubjectLowerCase,
  maxHeaderWidth:
    (process.env.CZ_MAX_HEADER_WIDTH &&
      parseInt(process.env.CZ_MAX_HEADER_WIDTH)) ||
    config.maxHeaderWidth ||
    100,
  maxLineWidth:
    (process.env.CZ_MAX_LINE_WIDTH &&
      parseInt(process.env.CZ_MAX_LINE_WIDTH)) ||
    config.maxLineWidth ||
    100
};

(function(options) {
  try {
    var commitlintLoad = require('@commitlint/load');
    commitlintLoad().then(function(clConfig) {
      if (clConfig.rules) {
        var maxHeaderLengthRule = clConfig.rules['header-max-length'];
        if (
          typeof maxHeaderLengthRule === 'object' &&
          maxHeaderLengthRule.length >= 3 &&
          !process.env.CZ_MAX_HEADER_WIDTH &&
          !config.maxHeaderWidth
        ) {
          options.maxHeaderWidth = maxHeaderLengthRule[2];
        }
      }
    });
  } catch (err) {}
})(options);

module.exports = engine(options);
```


> 温馨提示：在 commitizen 的 `getNormalizedConfig.js` 中可以发现按顺序读取了 package.json、.cz.json 以及 .czrc 中配置的 types 字段信息，优先读取 package.json 中的配置信息。

从上述注释代码可以发现，提交说明的 types 通过 commitizen 的配置或者 [conventional-commit-types](https://github.com/commitizen/conventional-commit-types) 获取，由于默认没有 `commitizen` 配置，因此会从 conventional-commit-types 获取 types：

``` json
// node_modules/conventional-commit-types/index.json
// 和提交说明规范的 Header 部分的 type 基本上一致，这里多出了 perf、ci、build 等类型

{
  "types": {
    "feat": {
      "description": "A new feature",
      "title": "Features"
    },
    "fix": {
      "description": "A bug fix",
      "title": "Bug Fixes"
    },
    "docs": {
      "description": "Documentation only changes",
      "title": "Documentation"
    },
    "style": {
      "description": "Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)",
      "title": "Styles"
    },
    "refactor": {
      "description": "A code change that neither fixes a bug nor adds a feature",
      "title": "Code Refactoring"
    },
    "perf": {
      "description": "A code change that improves performance",
      "title": "Performance Improvements"
    },
    "test": {
      "description": "Adding missing tests or correcting existing tests",
      "title": "Tests"
    },
    "build": {
      "description": "Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)",
      "title": "Builds"
    },
    "ci": {
      "description": "Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)",
      "title": "Continuous Integrations"
    },
    "chore": {
      "description": "Other changes that don't modify src or test files",
      "title": "Chores"
    },
    "revert": {
      "description": "Reverts a previous commit",
      "title": "Reverts"
    }
  }
}

```

> 温馨提示：从源码可以发现 types 的值优先读取 commitizen 的配置，因此可以将上述 types 放入 commitizen 的配置进行覆盖，这里可以放入 package.json 的 config.commitizen.types 中，也可以放入 .cz.json 或者 .czrc  的 types 中，并且如果不喜欢英文，也可以进行汉化处理。

我们重点来看下 cz-conventional-changelog 的 `engine.js`：

``` javascript
'format cjs';

var wrap = require('word-wrap');
var map = require('lodash.map');
var longest = require('longest');
var chalk = require('chalk');

var filter = function(array) {
  return array.filter(function(x) {
    return x;
  });
};

var headerLength = function(answers) {
  return (
    answers.type.length + 2 + (answers.scope ? answers.scope.length + 2 : 0)
  );
};

var maxSummaryLength = function(options, answers) {
  return options.maxHeaderWidth - headerLength(answers);
};

var filterSubject = function(subject, disableSubjectLowerCase) {
  subject = subject.trim();
  if (!disableSubjectLowerCase && subject.charAt(0).toLowerCase() !== subject.charAt(0)) {
    subject =
      subject.charAt(0).toLowerCase() + subject.slice(1, subject.length);
  }
  while (subject.endsWith('.')) {
    subject = subject.slice(0, subject.length - 1);
  }
  return subject;
};

// This can be any kind of SystemJS compatible module.
// We use Commonjs here, but ES6 or AMD would do just
// fine.
module.exports = function(options) {
  var types = options.types;

  var length = longest(Object.keys(types)).length + 1;
  var choices = map(types, function(type, key) {
    return {
      name: (key + ':').padEnd(length) + ' ' + type.description,
      value: key
    };
  });

  return {
    // When a user runs `git cz`, prompter will
    // be executed. We pass you cz, which currently
    // is just an instance of inquirer.js. Using
    // this you can ask questions and get answers.
    //
    // The commit callback should be executed when
    // you're ready to send back a commit template
    // to git.
    //
    // By default, we'll de-indent your commit
    // template and will keep empty lines.
    
    
    // 这里是 commitizen 提供的扩展写法，在 commitizen 中会获取 prompter 进行执行
    // 这里的 cz 指代 commitizen 中传入的 inquirer，而 commit 指代回调函数
    prompter: function(cz, commit) {
      // Let's ask some questions of the user
      // so that we can populate our commit
      // template.
      //
      // See inquirer.js docs for specifics.
      // You can also opt to use another input
      // collection library if you prefer.
      cz.prompt([
        {
          // 首先让用户选择 Header 的 type
          type: 'list',
          name: 'type',
          message: "Select the type of change that you're committing:",
          choices: choices,
          default: options.defaultType
        },
        {
          type: 'input',
          name: 'scope',
          message:
            'What is the scope of this change (e.g. component or file name): (press enter to skip)',
          default: options.defaultScope,
          filter: function(value) {
            return options.disableScopeLowerCase
              ? value.trim()
              : value.trim().toLowerCase();
          }
        },
        {
          type: 'input',
          name: 'subject',
          message: function(answers) {
            return (
              'Write a short, imperative tense description of the change (max ' +
              maxSummaryLength(options, answers) +
              ' chars):\n'
            );
          },
          default: options.defaultSubject,
          validate: function(subject, answers) {
            var filteredSubject = filterSubject(subject, options.disableSubjectLowerCase);
            return filteredSubject.length == 0
              ? 'subject is required'
              : filteredSubject.length <= maxSummaryLength(options, answers)
              ? true
              : 'Subject length must be less than or equal to ' +
                maxSummaryLength(options, answers) +
                ' characters. Current length is ' +
                filteredSubject.length +
                ' characters.';
          },
          transformer: function(subject, answers) {
            var filteredSubject = filterSubject(subject, options.disableSubjectLowerCase);
            var color =
              filteredSubject.length <= maxSummaryLength(options, answers)
                ? chalk.green
                : chalk.red;
            return color('(' + filteredSubject.length + ') ' + subject);
          },
          filter: function(subject) {
            return filterSubject(subject, options.disableSubjectLowerCase);
          }
        },
        {
          type: 'input',
          name: 'body',
          message:
            'Provide a longer description of the change: (press enter to skip)\n',
          default: options.defaultBody
        },
        {
          type: 'confirm',
          name: 'isBreaking',
          message: 'Are there any breaking changes?',
          default: false
        },
        {
          type: 'input',
          name: 'breakingBody',
          default: '-',
          message:
            'A BREAKING CHANGE commit requires a body. Please enter a longer description of the commit itself:\n',
          when: function(answers) {
            return answers.isBreaking && !answers.body;
          },
          validate: function(breakingBody, answers) {
            return (
              breakingBody.trim().length > 0 ||
              'Body is required for BREAKING CHANGE'
            );
          }
        },
        {
          type: 'input',
          name: 'breaking',
          message: 'Describe the breaking changes:\n',
          when: function(answers) {
            return answers.isBreaking;
          }
        },

        {
          type: 'confirm',
          name: 'isIssueAffected',
          message: 'Does this change affect any open issues?',
          default: options.defaultIssues ? true : false
        },
        {
          type: 'input',
          name: 'issuesBody',
          default: '-',
          message:
            'If issues are closed, the commit requires a body. Please enter a longer description of the commit itself:\n',
          when: function(answers) {
            return (
              answers.isIssueAffected && !answers.body && !answers.breakingBody
            );
          }
        },
        {
          type: 'input',
          name: 'issues',
          message: 'Add issue references (e.g. "fix #123", "re #123".):\n',
          when: function(answers) {
            return answers.isIssueAffected;
          },
          default: options.defaultIssues ? options.defaultIssues : undefined
        }
      ]).then(function(answers) {
        var wrapOptions = {
          trim: true,
          cut: false,
          newline: '\n',
          indent: '',
          width: options.maxLineWidth
        };

        // parentheses are only needed when a scope is present
        var scope = answers.scope ? '(' + answers.scope + ')' : '';

        // Hard limit this line in the validate
        var head = answers.type + scope + ': ' + answers.subject;

        // Wrap these lines at options.maxLineWidth characters
        var body = answers.body ? wrap(answers.body, wrapOptions) : false;

        // Apply breaking change prefix, removing it if already present
        var breaking = answers.breaking ? answers.breaking.trim() : '';
        breaking = breaking
          ? 'BREAKING CHANGE: ' + breaking.replace(/^BREAKING CHANGE: /, '')
          : '';
        breaking = breaking ? wrap(breaking, wrapOptions) : false;

        var issues = answers.issues ? wrap(answers.issues, wrapOptions) : false;
        
        // 最终通过 commitizen 传入的 commit 回调函数返回用户通过 inquirer 交互产生的 message 信息
        commit(filter([head, body, breaking, issues]).join('\n\n'));
      });
    }
  };
};

```

我们重新回到 commitizen 查看如何执行上述 `commit` 回调函数：

``` javascript
// src/commitizen/commit.js

 /**
  * Asynchronously commits files using commitizen
  */
  
// 这里的 prompter 就是从适配器获取的 prompter 函数
function commit (inquirer, repoPath, prompter, options, done) {
  var cacheDirectory = cacheDir('commitizen');
  var cachePath = path.join(cacheDirectory, 'commitizen.json');

  ensureDir(cacheDirectory, function (error) {
    if (error) {
      console.error("Couldn't create commitizen cache directory: ", error);
      // TODO: properly handle error?
    } else {
      if (options.retryLastCommit) {

        console.log('Retrying last commit attempt.');

        // We want to use the last commit instead of the current commit,
        // so lets override some options using the values from cache.
        let {
          options: retryOptions,
          overrideOptions: retryOverrideOptions,
          template: retryTemplate
        } = cache.getCacheValueSync(cachePath, repoPath);
        dispatchGitCommit(repoPath, retryTemplate, retryOptions, retryOverrideOptions, done);

      } else {
      
        // 执行适配器提供的 prompter 函数，传入的第二个参数是一个回调函数
        // 在 cz-conventional-changelog 中的  prompter: function(cz, commit) {} 中的 commit 就是该回调函数
        // 该回调函数在 cz-conventional-changelog 中的调用为 commit(filter([head, body, breaking, issues]).join('\n\n'));
        // Get user input -- side effect that is hard to test
        prompter(inquirer, function (error, template, overrideOptions) {
          // Allow adapters to error out
          // (error: Error?, template: String, overrideOptions: Object)
          // 判断传入的第一个参数是否是 Error 实例，如果不是则说明传入的是 message 信息
          if (!(error instanceof Error)) {
            overrideOptions = template;
            template = error;
            error = null;
          }

          if (error) {
            return done(error);
          }

          // We don't want to add retries to the cache, only actual commands
          cache.setCacheValueSync(cachePath, repoPath, { template, options, overrideOptions });
          
          // template 是通过执行适配器后获取的 git message 信息
          // 最终会调用 git commit -m 执行提交说明
          dispatchGitCommit(repoPath, template, options, overrideOptions, done);
        });
      }
    }
  });

}
```

通过 cz-conventional-changelog 的源码可以发现，commitizen 需要适配器提供 prompter 执行函数，并会向该函数注入 inquirer 和回调函数两个参数，适配器通过 inquirer 和用户产生信息交互，获取用户的信息后通过回调函数将用户信息返回给 commitizen 执行最终的 `git commit`。这是一种非常典型的插件设计模式，包括在 Webpack 中执行插件也是类似的模式，如下所示：

``` javascript
// https://webpack.docschina.org/contribute/writing-a-plugin/

// 导出一个 Class 类
class MyExampleWebpackPlugin {
  // 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。
  apply(compiler) {
    // 指定一个挂载到 webpack 自身的事件钩子。
    compiler.hooks.emit.tapAsync(
      'MyExampleWebpackPlugin',
      (compilation, callback) => {
        console.log('这是一个示例插件！');
        console.log(
          '这里表示了资源的单次构建的 `compilation` 对象：',
          compilation
        );

        // 用 webpack 提供的插件 API 处理构建过程
        compilation.addModule(/* ... */);

        callback();
      }
    );
  }
}

module.exports = MyExampleWebpackPlugin;
```

在 Webpack 中配置该插件时需要通过 `new` 进行实例化（commitizen 只需要在配置层面提供 NPM 包的路径，如果适配器还需要额外提供配置参数，那么也可以通过 Webpack 的形式来处理），在内部执行 Webpack 插件的实例时会调用 `apply` 函数并传入 `compiler` 参数，在 `compiler` 内部的事件钩子上通过 `callback` 实现和宿主环境的回调处理。

> 温馨提示：不管是 Webpack 的插件还是 commitizen 的适配器，本质上都是在宿主环境中定义出一个插件标准（NPM 包形式，可以形成复用），让插件导出可以被宿主环境调用的标准函数，并给插件注入宿主环境提供的参数和回调函数，让插件基于宿主环境的参数进行处理并返回宿主环境需要的信息。如果插件的功能非常复杂，那么也可以是一套完整的插件脚手架，例如 Vue CLI 的插件开发就相对复杂，需要提供一套标准的插件脚手架来完成插件功能的设计，具体可查看 [Vue CLI 插件开发指南](https://cli.vuejs.org/zh/dev-guide/plugin-dev.html)。如果微前端的框架需要提供一个插件的功能供三方自定义，例如三方想自定义沙箱实例，想自行定义静态资源的请求方法，则完全可以通过上述思想来提供设计方案。



### 定制提交说明


通过 commitizen 和 cz-conventional-changelog 已经能够创建符合 Angular 规范的提交说明，如下所示：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bd435703a6a42f9a75a8f842966e955~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2506&h=756&s=289368&e=png&b=ffffff)

但是可以发现上述的两个 scope（工程化和 readme.md）仍然需要手写，并且 cz-conventional-changelog 中配置的能力是有限的，例如可以在 commitizen 的配置文件中配置自定义的 types 来覆盖 cz-conventional-changelog 中默认读取的 conventional-commit-types。那么是否有插件可以非常详细的来自定义整个提交说明呢，此时可以使用[cz-customizable](https://github.com/leonardoanalista/cz-customizable) 适配器：

``` bash
# 将之前的 cz-conventional-changelog 替换为 cz-customizable 适配器
npx commitizen init cz-customizable --save --save-exact
```

由于已经配置了 cz-conventional-changelog 适配器，此时执行会产生错误信息：

``` bash
# 执行
npx commitizen init cz-customizable --save --save-exact

# 打印
Attempting to initialize using the npm package cz-customizable
Error: Error: A previous adapter is already configured. Use --force to override
    adapterConfig.path: ./node_modules/cz-conventional-changelog
    repoPath: /Users/zhuxiankang/Desktop/Github/micro-framework
    CLI_PATH: /Users/zhuxiankang/Desktop/Github/micro-framework/node_modules/commitizen/
    installAdapterCommand: npm install cz-customizable --save-dev
    adapterNpmName: cz-customizable
```

我们重新使用 `--force` 强制覆盖适配器：

``` bash
npx commitizen init cz-customizable --save --save-exact --force
```

执行后可以发现 `package.json` 中的 commitizen 适配器路径配置变更为 cz-customizable，此时我们执行 `npm run cz` 进行测试：

``` bash
# 执行
npm run cz

# 打印
> micro-framework@1.0.6 cz
> git cz

cz-cli@4.3.0, cz-customizable@7.0.0

Unable to find a configuration file. Please refer to documentation to learn how to set up: https://github.com/leonardoanalista/cz-customizable#steps "
Cannot read properties of null (reading 'subjectLimit')
```

可以发现适配器已经成功被替换，但是提示需要提供配置文件，查看 cz-customizable 的仓库文档可以发现需要提供 [.cz-config.js](https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js) 配置文件，并且官方提供了一个示例，如下所示：

``` javascript
// https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js
module.exports = {
  types: [
    { value: "feat", name: "feat:     A new feature" },
    { value: "fix", name: "fix:      A bug fix" },
    { value: "docs", name: "docs:     Documentation only changes" },
    {
      value: "style",
      name: "style:    Changes that do not affect the meaning of the code\n            (white-space, formatting, missing semi-colons, etc)",
    },
    {
      value: "refactor",
      name: "refactor: A code change that neither fixes a bug nor adds a feature",
    },
    {
      value: "perf",
      name: "perf:     A code change that improves performance",
    },
    { value: "test", name: "test:     Adding missing tests" },
    {
      value: "chore",
      name: "chore:    Changes to the build process or auxiliary tools\n            and libraries such as documentation generation",
    },
    { value: "revert", name: "revert:   Revert to a commit" },
    { value: "WIP", name: "WIP:      Work in progress" },
  ],

  scopes: [
    { name: "accounts" },
    { name: "admin" },
    { name: "exampleScope" },
    { name: "changeMe" },
  ],

  usePreparedCommit: false, // to re-use commit from ./.git/COMMIT_EDITMSG
  allowTicketNumber: false,
  isTicketNumberRequired: false,
  ticketNumberPrefix: "TICKET-",
  ticketNumberRegExp: "\\d{1,5}",

  // it needs to match the value for field type. Eg.: 'fix'
  /*
    scopeOverrides: {
      fix: [
  
        {name: 'merge'},
        {name: 'style'},
        {name: 'e2eTest'},
        {name: 'unitTest'}
      ]
    },
    */
  // override the messages, defaults are as follows
  messages: {
    type: "Select the type of change that you're committing:",
    scope: "\nDenote the SCOPE of this change (optional):",
    // used if allowCustomScopes is true
    customScope: "Denote the SCOPE of this change:",
    subject: "Write a SHORT, IMPERATIVE tense description of the change:\n",
    body: 'Provide a LONGER description of the change (optional). Use "|" to break new line:\n',
    breaking: "List any BREAKING CHANGES (optional):\n",
    footer:
      "List any ISSUES CLOSED by this change (optional). E.g.: #31, #34:\n",
    confirmCommit: "Are you sure you want to proceed with the commit above?",
  },

  allowCustomScopes: true,
  allowBreakingChanges: ["feat", "fix"],
  // skip any questions you want
  // skipQuestions: ['scope', 'body'],

  // limit subject length
  subjectLimit: 100,
  // breaklineChar: '|', // It is supported for fields body and footer.
  // footerPrefix : 'ISSUES CLOSED:'
  // askForBreakingChangeFirst : true, // default is false
};

```

我们在根目录下新增 `.cz-config.js`，并将示例放入文件中，再次执行 `npm run cz`：

``` bash
# 执行
 npm run cz

# 打印
> micro-framework@1.0.6 cz
> git cz

cz-cli@4.3.0, cz-customizable@7.0.0

All lines except first will be wrapped after 100 characters.
? Select the type of change that you're committing: (Use arrow keys)
❯ feat:     A new feature 
  fix:      A bug fix 
  docs:     Documentation only changes 
  style:    Changes that do not affect the meaning of the code
            (white-space, formatting, missing semi-colons, etc) 
  refactor: A code change that neither fixes a bug nor adds a feature 
  perf:     A code change that improves performance 
(Move up and down to reveal more choices)
```

可以发现适配器 cz-customizable 已经可以根据配置文件进行提示了，我们重新更改一下示例文件，对其进行汉化处理并更改 scopes 从而可以符合我们的开发项目：

``` javascript
// 根目录下的 .cz-config.js
// https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js
module.exports = {
  // 对原有的 types 进行汉化处理
  types: [
    { value: "特性", name: "特性:    一个新的特性" },
    { value: "修复", name: "修复:    修复一个Bug" },
    { value: "文档", name: "文档:    变更的只有文档" },
    { value: "格式", name: "格式:    空格, 分号等格式修复" },
    { value: "重构", name: "重构:    代码重构，注意和特性、修复区分开" },
    { value: "性能", name: "性能:    提升性能" },
    { value: "测试", name: "测试:    添加一个测试" },
    { value: "工具", name: "工具:    开发工具变动(构建、脚手架工具等)" },
    { value: "回滚", name: "回滚:    代码回退" },
    { value: "开发中", name: "开发中:  功能正在开发，还未完成" },
  ],

  // 以本小册的课程内容进行 scopes 的拆分
  // 如果是组件库，则可以根据组件的名称进行拆分
  // 如果是框架库，也可以根据框架库的模块内容进行拆分
  // 例如这里的框架设计还可以细分为 框架设计(沙箱)、框架设计(性能优化)、框架设计(通信)
  scopes: [
    { name: "方案了解" },
    { name: "框架原理" },
    { name: "工程设计" },
    { name: "框架设计" },
  ],

  usePreparedCommit: false, // to re-use commit from ./.git/COMMIT_EDITMSG
  allowTicketNumber: false,
  isTicketNumberRequired: false,
  ticketNumberPrefix: "TICKET-",
  ticketNumberRegExp: "\\d{1,5}",

  // it needs to match the value for field type. Eg.: 'fix'
  /*
    scopeOverrides: {
      fix: [
  
        {name: 'merge'},
        {name: 'style'},
        {name: 'e2eTest'},
        {name: 'unitTest'}
      ]
    },
    */
  // override the messages, defaults are as follows
  messages: {
    type: "选择一种提交类型:",
    scope: "选择一个 scope (可选):",
    // used if allowCustomScopes is true
    customScope: "选择一个 scope:",
    subject: "短说明:\n",
    body: '长说明，使用"|"换行(可选)：\n',
    breaking: "非兼容性说明 (可选):\n",
    footer: "关联关闭的 issue，例如：#31, #34(可选):\n",
    confirmCommit: "确定提交说明?",
  },

  allowCustomScopes: true,
  allowBreakingChanges: ["feat", "fix"],
  // skip any questions you want
  // skipQuestions: ['scope', 'body'],

  // limit subject length
  subjectLimit: 100,
  // breaklineChar: '|', // It is supported for fields body and footer.
  // footerPrefix : 'ISSUES CLOSED:'
  // askForBreakingChangeFirst : true, // default is false
};
```

更改以后再次进行代码提交：

![定制cz.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9fde36063a46afacd6a6ac9fcd6c97~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=730&s=5884568&e=gif&f=516&b=191919)

> 温馨提示：示例源码可以从 [demo/changelog-cz-customizable](https://github.com/ziyi2/micro-framework/commits/demo/changelog-cz-customizable) 分支获取。感兴趣的同学可以简单阅读一下 cz-customizable 适配器的源码，本课程不再讲解实现细节。


## commitlint

尽管我们已经可以通过 `git cz` 进行提交说明，但是在团队协作的过程中并不是所有人都会遵循该提交规范。为了防止不符合 Angular 规范的提交说明被上传，并且为了后续可通过工具快速生成规范的变更日志，我们需要在提交说明时对说明内容进行校验，此时我们可以通过 husky 配合 [commitlint](https://github.com/conventional-changelog/commitlint) 来完成这项工作，通过校验：

- 有助于自动生成 CHANGELOG (变更日志)
- 有助于发布语义版本
- 有助于向库的使用者传达变更信息
- 有助于建设 CI / CD 流程
- 通过浏览结构化的提交历史，有助于更好的团队协作

commitlint 用于校验提交说明的格式规范，配合 [commitlint-config-conventional](https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-conventional) 可以校验提交说明是否 Angular 规范，该共享配置中的 types 校验和 cz-conventional-changelog 中默认使用的 types 完全一致，当然除了校验 types 是否符合 Angular 规范的提交说明，也会校验内容的格式信息，可以查看 [Rules](https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-conventional#rules) 了解细节。我们通过以下命令进行安装使用：

``` bash
# 安装 commitlint 的 CLI 和共享配置 @commitlint/config-conventional
npm install --save-dev @commitlint/config-conventional @commitlint/cli
# 在项目根目录新建 commitlint.config.js 配置文件并配置 @commitlint/config-conventional 为共享配置
echo "module.exports = {extends: ['@commitlint/config-conventional']}" > commitlint.config.js
```


> 温馨提示：在 ESLint 中我们讲解了共享配置的概念，在此处可以将 commitlint 对比成 ESLint，将 commitlint-config-conventional 对比成 ESLint 的共享配置。本课程不再额外讲解 commitlint 的工作原理，感兴趣的同学可以自行了解。

安装并配置完成后，我们设置 husky 来新增 git 钩子：

``` bash
npx husky add .husky/commit-msg  'npx --no -- commitlint --edit ${1}'
```

> 温馨提示：关于 husky 和 commit-msg 钩子可以回顾上一节课程**提交规范**。


此时我们使用 `npm run cz` 进行提交说明时，husky 会执行 `commitlint` 校验命令来校验提交说明是否符合 Angular 规范，如果不符合规范则会放弃本次提交。我们可以用它来校验之前配置的自定义提交说明，如下所示：

``` bash
# 执行
npm run cz                                                                                   
# 打印
> micro-framework@1.0.6 cz
> git cz

cz-cli@4.3.0, cz-customizable@7.0.0

All lines except first will be wrapped after 100 characters.
? 选择一种提交类型: 特性:    一个新的特性
? 选择一个 scope (可选): 工程设计
? 短说明:
 新增 commitlint
? 长说明，使用"|"换行：
 用于校验 commit 是否符合 Angular 规范
? 关联关闭的 issue，例如：#31, #34(可选):
 

###--------------------------------------------------------###
特性(工程设计): 新增 commitlint

用于校验 commit 是否符合 Angular 规范
###--------------------------------------------------------###

? 确定提交说明? Yes
→ No staged files match any configured task.
⧗   input: 特性(工程设计): commitlint

用于校验 commit 是否符合 Angular 规范
# 提示没有 subject
✖   subject may not be empty [subject-empty]
# 提示没有 type
✖   type may not be empty [type-empty]

✖   found 2 problems, 0 warnings
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint

husky - commit-msg hook exited with code 1 (error)
git exited with error code 1
```

可以发现自定义提交说明改变了原有 Angular 规范的 types 的值导致校验失败。一种方式是将 cz-customizable 回退成 cz-conventional-changelog 进行提交说明。如果还是想要使用 cz-customizable 定制提交说明，则可以自行设计共享配置或者使用 [commitlint-config-cz](https://github.com/whizark/commitlint-config-cz) 对自定义提交说明进行校验：

``` bash
# 安装共享配置
npm install commitlint-config-cz --save-dev
# 更改配置
echo "module.exports = {extends: ['cz']}" > commitlint.config.js
```

我们假设团队协作的新人对具有校验功能的项目进行 `git commit` 提交：

``` bash
# 执行（使用不符合自定义规则的提交说明）
git commit -m "feat: hello"
→ No staged files match any configured task.
⧗   input: feat: hello
# 校验失败，type 必须是 .cz-config.js 中汉化的 type 
✖   type must be one of [特性, 修复, 文档, 格式, 重构, 性能, 测试, 工具, 回滚, 开发中] [type-enum]

✖   found 1 problems, 0 warnings
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint

husky - commit-msg hook exited with code 1 (error)
```

我们使用 `npm run cz` 进行提交，此时可以校验通过：

``` bash
# 执行
npm run cz

# 打印
> micro-framework@1.0.6 cz
> git cz

cz-cli@4.3.0, cz-customizable@7.0.0

All lines except first will be wrapped after 100 characters.
? 选择一种提交类型: 特性:    一个新的特性
? 选择一个 scope (可选): 工程设计
? 短说明:
 新增  commitlint
? 长说明，使用"|"换行：
 使用 commitlint 来校验提交说明是否符合规范
? 关联关闭的 issue，例如：#31, #34(可选):
 

###--------------------------------------------------------###
特性(工程设计): 新增  commitlint

使用 commitlint 来校验提交说明是否符合规范
###--------------------------------------------------------###

? 确定提交说明? Yes
→ No staged files match any configured task.
[demo/changelog-commitlint c03edc3] 特性(工程设计): 新增  commitlint
 6 files changed, 2327 insertions(+), 238 deletions(-)
 create mode 100755 .husky/commit-msg
 create mode 100644 commitlint.config.js
```

> 温馨提示：示例源码可以从 [demo/changelog-commitlint](https://github.com/ziyi2/micro-framework/tree/demo/changelog-commitlint) 分支获取。开发者有什么方式可以绕过上述校验规则呢？


## 变更日志

使用了 commitizen（cz-customizable） + commitlint（commitlint-config-cz）的组合之后，可以确保团队协作的过程中都生成符合 Augular 规范的提交说明。生成了规范的提交说明之后可以使用 [conventional-changelog-cli](https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli) 自动生成变更日志：

``` bash
npm install --save-dev conventional-changelog-cli
```

安装完成后在 `package.json` 中新增 CLI 命令：

``` json
"scripts": {
  "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"
}
```

> 温馨提示：可以查看 Vue 代码的 `package.json`，使用的也是 conventional-changelog 工具，注意该工具的 CLI 参数，有些参数是增量式生成日志，这里是对日志进行全量覆盖处理。

执行 `npm run changelog` 之后会在根目录下自动生成 [CHANGELOG.md](https://github.com/ziyi2/micro-framework/blob/demo/changelog/CHANGELOG.md) 文件：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ab44754f1734857bbd334abd8e1ce4c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1480&s=894772&e=png&b=ffffff)

需要注意，从上述变更日志可以发现 Angular 规范中的 Body 被日志忽视，由于 Body 不是必须的，因此尽量详细书写 subject 短说明（本课程示例中的短说明写的太短，已经无法说明 commit 提交的目的，导致变更日志看起来不够详细。。。）。

除此之外，上述变更日志中出现了大量重复的 commit 提交说明，有没有什么方式可以合并提交说明呢？合并提交说明对于代码 CR 和 PR 都是非常有用的能力。

> 温馨提示：示例源码可以从 [demo/changelog](https://github.com/ziyi2/micro-framework/tree/demo/changelog) 分支获取。


## 小结

本课程先讲解了 Angular 规范的提交说明，然后详细讲解了 commitizen 和适配器的工作原理和作用，并讲解了在团队协作的过程中如何进行提交说明的校验，从而最终可以生成规范的变更日志。在设计的过程中，推荐使用 cz-conventional-changelog 和 @commitlint/config-conventional 的组合规范提交说明，如果需要对提交说明进行汉化处理，则可以使用 cz-customizable 和 commitlint-config-cz 的组合。在下一个课程中，我们重点讲解如何进行单元测试。
