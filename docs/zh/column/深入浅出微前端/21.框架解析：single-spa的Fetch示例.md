在上一个课程中，我们讲解了 single-spa 的动态 Script 方案，并设计了通用 SDK `single-spa-lifecycle` 的微应用生命周期函数获取方案，这种获取方案存在一定的耦合性，因为主应用需要感知和维护微应用的应用标识。在本课程中，我们会讲解 single-spa 的 Fetch 请求方案，并设计一个更加解耦的微应用生命周期函数获取方案。为了设计这种通用的方案，我们需要对微应用进行额外的 Webpack 配置，因此需要额外了解 Webpack 的部分运行时原理。


## 为什么需要了解 Webpack 运行时原理

在 qiankun 官方文档[配置微应用的打包工具](https://qiankun.umijs.org/zh/guide/getting-started#2-%E9%85%8D%E7%BD%AE%E5%BE%AE%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7)中为了让主应用能识别微应用暴露出来的生命周期函数，需要微应用的 Webpack 增加如下配置：

``` javascript
// webpack 5.x
const packageName = require('./package.json').name;

module.exports = {
  output: {
    // library 和 libraryTarget 用于暴露微应用的生命周期函数
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    // chunkLoadingGlobal 用于代码分离
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
};

// webpack 4.x
const packageName = require('./package.json').name;


module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  },
};
```

在上述 Webpack 配置中，`output.library` 和 `output.libraryTarget` 用于暴露微应用的生命周期函数，因此可以使得主应用配合 qiankun 框架实现彻底解耦的微应用生命周期函数获取方案。为此，我们需要先了解上述 Webpack 配置的运行时原理，从而帮助我们分析和设计一个基于通用生命周期函数获取方式的 Fetch 微前端方案。

> 温馨提示：在下一个课程中我们会重点讲解 `output.chunkLoadingGlobal` 配置的运行原理，从而使大家深入了解[代码分离](https://webpack.docschina.org/guides/code-splitting/)的微前端设计方案。

## Webpack 运行时 `library` 配置分析

### `library` 配置示例

我们首先需要分析 `output.library` 配置生成的产物，示例代码的目录结构如下所示：

``` bash
.
├── dist                # 构建目录
│   └── main.js
├── src                 # 源文件目录
│   └── index.js
├── index.html          # 网页代码，用于运行构建代码进行测试
├── package.json        # 项目描述文件
└── webpack.config.js   # webpack 配置文件
```

> 温馨提示：示例源码可以从 webpack-runtime-analyze 的 [demo/library](https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/library) 分支获取。

为了可以在全局 `window` 对象上暴露属性 `window.myLibrary`，需要在 Webpack 中使用 [output.library](https://webpack.docschina.org/configuration/output/#outputlibrary) 配置，如下所示：

``` javascript
// webpack.config.js
module.exports = {
  output: {
    // 导出的变量将会挂载在 window.myLibrary 上
    library: 'myLibrary',
  }
};
```

假设在 `src/index.js` 源码中导出了 single-spa 需要的生命周期函数：

``` javascript
// src/index.js
// 注意 single-spa 中需要加载 async 函数
export async function bootstrap() {
  console.log("bootstrap");
}

export async function mount() {
  console.log("mount");
}

export async function unmount() {
  console.log("unmount");
}

export async function update() {
  console.log("update");
}
```

为了方便分析 Webpack 的运行时代码，这里采用开发态进行构建：

``` json
// package.json
"scripts": {
  // 开发态构建
  "start": "webpack --mode=development",
},
```

执行构建命令 `npm run start` 后会在 `dist/main.js` 中生成构建代码，将其加入 `index.html`：

``` html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 加载 Webpack 构建后的代码 -->
    <script src="./dist/main.js"></script>
    <script>
      // 用于验证是否在 window 上暴露了 myLibrary 库属性
      console.log(window.myLibrary);
      // 模拟 single-spa 执行 myLibrary 上的生命周期函数
      window.myLibrary.bootstrap();
    </script>
  </body>
</html>
```

在浏览器中打开 `index.html` 查看打印信息，可以发现在 `window.myLibrary` 上可以获取 `src/index.js` 导出的生命周期函数：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c1255d496f3485693a7a8a7f41511de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=882&s=233077&e=png&b=fefefe)

### `library` 配置运行时分析

我们重点来分析一下 `dist/main.js` 构建代码，如下所示：

``` javascript
// 根据 output.library 配置的库名称
// 定义全局库属性 window.myLibrary
var myLibrary;

// 自执行匿名函数，包含了 Webpack 的运行时代码和开发者的源代码模块
(() => {
  // webpackBootstrap
  "use strict";

  // 定义模块化映射对象 
  // __webpack_modules__  = {"模块路径": "模块化包装函数" }}
  var __webpack_modules__ = {
    // "./src/index.js" 属性的值是一个箭头函数
    // 该箭头函数在本课程中被称为模块化包装函数
    "./src/index.js": (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      // 使用 eval 执行 src/index.js 对应的源代码包装模块
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n  console.log("bootstrap");\n}\n\nasync function mount() {\n  console.log("mount");\n}\n\nasync function unmount() {\n  console.log("unmount");\n}\n\nasync function update() {\n  console.log("update");\n}\n\n//# sourceURL=webpack://myLibrary/./src/index.js?'
      );
    },
  };

  // The require scope
  // 定义一个 Webpack 运行时对象
  // 该对象定义的方法会在 src/index.js 对应的模块化包装函数中使用
  var __webpack_require__ = {};

  /* webpack/runtime/define property getters */
  (() => {
    // define getter functions for harmony exports
    // 函数名称
    // __webpack_require__.d

    // 函数作用
    // 用于定义 harmony 模块（ES2015 模块）的 exports 导出对象
    // 将源文件模块导出的对象赋值给模块化导出对象 __webpack_exports__
    
    // 参数说明
    // exports： 模块化导出对象 __webpack_exports__
    // definition： 源文件中的导出对象（例如 src/index.js 中导出的生命周期函数）

    // 举个例子
    // 如果在 src/index.js 中导出了 bootstrap、mount、unmount、update 四个函数
    // 那么 definition 对象就是 { bootstrap, mount, unmount, update }
    __webpack_require__.d = (exports, definition) => {
      // 遍历源文件中导出对象的属性
      for (var key in definition) {
        if (
          // 检查 definition 对象是否有 key 属性
          __webpack_require__.o(definition, key) &&
          // 检查 exports 对象是否有 key 属性
          !__webpack_require__.o(exports, key)
        ) {
          // 为 exports 对象定义 key 属性，属性值为 definition 对象的 key 属性值
          // 即将 src/index.js 中导出的 bootstrap 等函数添加到 __webpack_exports__ 对象中
          Object.defineProperty(exports, key, {
            // enumerable: true 表示该属性可以被枚举
            enumerable: true,
            // 设置 getter 函数，该函数返回 definition 对象的 key 属性值
            get: definition[key],
          });
        }
      }
    };
  })();

  /* webpack/runtime/hasOwnProperty shorthand */
  (() => {
    // 函数名称
    // __webpack_require__.o

    // 函数作用
    // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）
    
    // 参数说明
    // obj： 需要被检查的对象
    // prop： 需要被检查的属性
    __webpack_require__.o = (obj, prop) =>
      // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）
      Object.prototype.hasOwnProperty.call(obj, prop);
  })();

  /* webpack/runtime/make namespace object */
  (() => {
    // define __esModule on exports

    // 函数名称
    // __webpack_require__.r

    // 函数作用
    // 该函数用于定义 ES6 模块的标准行为
    // 即为模块化导出对象 __webpack_exports__ 定义 __esModule 属性值等
    // 可用于识别 __webpack_exports__ 的模块性质

    // 参数说明
    // exports： 模块化导出对象 __webpack_exports__
    __webpack_require__.r = (exports) => {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        // 为 exports 对象定义属性 Symbol.toStringTag，值为 "Module"
        
        // Symbol.toStringTag
        // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag

        // ES6 模块的标准行为
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
        // console.log(Object.prototype.toString.call(exports)); // [object Module]
      }
      // exports.__esModule = true
      // 这是一个约定，用于标记这个模块是一个 ES 模块。
      // 其他模块在导入该模块时可以知道它是一个 ES 模块，从而使用正确的导入语法
      Object.defineProperty(exports, "__esModule", { value: true });

      // 为什么使用 Object.defineProperty 而不是直接 exports.__esModule = true 呢？
      // 因为 Object.defineProperty 有一个特性 configurable
      // 当 configurable 为 false 时，该属性不可被删除，也不可被修改
      // 这样可以防止其他模块修改 __esModule 的值，从而保证了 __esModule 的值为 true
      
      // Object.defineProperty 被用于在 exports 对象上定义 __esModule 属性，
      // 这个属性是不可枚举的，这意味着它不会出现在 for-in 循环或 Object.keys 方法中。
      
      // 这个属性也是不可写的，这意味着你不能改变它的值。
      // 这些特性都是通过 Object.defineProperty 方法来实现的
      // { configurable: false, enumerable: false, value: true, writable: false }
      console.log(Object.getOwnPropertyDescriptor(exports, "__esModule")); 
    };
  })();

  // startup
  // Load entry module and return exports
  // This entry module can't be inlined because the eval devtool is used.

  // 定义 __webpack_exports__ 导出对象
  // 由于这里只有一个 src/index.js 模块，因此只需要一个导出对象
  var __webpack_exports__ = {};


  // 获取模块化映射对象中映射路径对应的模块化包装函数（箭头函数）
  // 传入 __webpack_exports__ 模块化导出对象、__webpack_require__ 模块化运行时对象
  // 执行模块化包装函数
  // 内部会将 src/index.js 的生命周期函数通过 __webpack_require__.d 赋值给 __webpack_exports__
  __webpack_modules__["./src/index.js"](
    0,
    __webpack_exports__,
    __webpack_require__
  );

  // 此时将 __webpack_exports__ 赋值给 myLibrary
  // 因此可以通过 myLibrary 执行 src/index.js 导出的生命周期函数
  // 例如执行 window.myLibrary.bootstrap
  myLibrary = __webpack_exports__;
})();
```

为了使得大家在学习时达成共识，这里使用固定术语来描述 Webpack 的运行时对象：

-   `__webpack_modules__`：模块化映射对象（建立模块路径和模块包装函数的映射关系）
-   `__webpack_require__`：模块化运行时对象（在模块化包装函数中使用）
-   `__webpack_exports__`：模块导出对象

除此之外，本课程将 `__webpack_modules__` 中模块路径映射的箭头函数称为**模块化包装函数**，例如 `./src/index.js` 模块路径对应的模块化包装函数如下所示：

``` javascript
// var __webpack_modules__ = {"./src/index.js": "模块化包装函数" };

// 其中模块化包装函数如下所示，是一个箭头函数
// 传入 module、__webpack_exports__ 以及 __webpack_require__ 参数
// 由于只有一个模块，因此 Webpack 没有开辟 module 对象（__unused_webpack_module = 0）
(__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  // 为了方便调试，使用 eval 执行源代码模块
  eval(
    '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n  console.log("bootstrap");\n}\n\nasync function mount() {\n  console.log("mount");\n}\n\nasync function unmount() {\n  console.log("unmount");\n}\n\nasync function update() {\n  console.log("update");\n}\n\n//# sourceURL=webpack://myLibrary/./src/index.js?'
  );
};
```

上述 `eval` 代码在 `src/index.js` 源码的基础上进行了模块化包装，传入了模块导出对象 `__webpack_exports__`，主要利用模块化运行时对象 `__webpack_require__` 处理：

``` javascript
 // eval 代码等同于以下代码

// 定义 ES 模块的标准行为：为 __webpack_exports__ 模块化导出对象设置 esModule 属性为 true
// 可以通过标准行为识别 __webpack_exports__ 为 ES 模块，例如：
// __webpack_exports__.__esModule = true
// Object.prototype.toString.call(__webpack_exports__) = '[object Module]'
__webpack_require__.r(__webpack_exports__);

// 为 __webpack_exports__ 对象定义源码中的 ES 模块导出值
// 内部使用了 Object.defineProperty 进行属性劫持处理
// 通过 __webpack_exports__.bootstrap 可以访问到 bootstrap 函数
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */ bootstrap: () => /* binding */ bootstrap,
  /* harmony export */ mount: () => /* binding */ mount,
  /* harmony export */ unmount: () => /* binding */ unmount,
  /* harmony export */ update: () => /* binding */ update,
  /* harmony export */
});
async function bootstrap() {
  console.log("bootstrap");
}

async function mount() {
  console.log("mount");
}

async function unmount() {
  console.log("unmount");
}

async function update() {
  console.log("update");
}
```

我们重新来分析一下 Webpack 的主运行时代码 `dist/main.js` 和模块化包装函数中的 `eval` 代码，简化后的代码如下所示：

``` javascript
var myLibrary;

(() => {
  // 模块化映射对象
  var __webpack_modules__ = {
    "./src/index.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      // 为 __webpack_exports__ 模块化导出对象定义 ES 标准行为
      // 例如：__webpack_exports__.__esModule = true
      __webpack_require__.r(__webpack_exports__);
      // 将 src/index.js 导出的生命周期函数赋值给 __webpack_exports__ 模块化导出对象
      // 例如：__webpack_exports__.bootstrap = bootstrap
      __webpack_require__.d(__webpack_exports__, {
        bootstrap: () => /* binding */ bootstrap,
      });
      async function bootstrap() {
        console.log("bootstrap");
      }
      // ...
    },
  };

  // 模块化运行时对象
  var __webpack_require__ = {};
  (() => {
    __webpack_require__.d = function () {};
  })()
  
  (() => {
    __webpack_require__.o = function () {};
  })()
  
  (() => {
    __webpack_require__.r = function () {};
  })();

  // 模块导出对象
  var __webpack_exports__ = {};

  // 执行模块化代码，将模块内部的导出对象挂载到 __webpack_exports__ 上
  __webpack_modules__["./src/index.js"](
    0,
    __webpack_exports__,
    __webpack_require__
  );

  // 将 __webpack_exports__ 挂载到 myLibrary 上
  myLibrary = __webpack_exports__;
})();
```




整体的执行流程如下所示：

-   定义全局库属性 `window.myLibrary`
-   定义模块化映射对象 `__webpack_modules__`(内部包含 `src/index.js` 模块化包装代码)
-   定义模块化运行时对象 `__webpack_require__` 以及 `d`、`o` 和 `r` 等方法
-   定义模块化导出对象 `__webpack_exports__`
-   根据 `__webpack_modules__` 执行 `src/index.js` 对应的模块化包装函数（ `eval` 代码）
    -   执行 `__webpack_require__.r` 定义 `__webpack_exports__` 的 ES 模块标准行为
    -   执行 `__webpack_require__.d` 将当前模块的导出值赋值给 `__webpack_exports__` 
-   将模块化导出对象 `__webpack_exports__` 赋值给 `window.myLibrary`

上述构建代码的运行时流程如下所示：

![Webpack 运行时分析-流程图.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8854109487f043aa93c2a46d7f3f83bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4374&h=2331&s=642076&e=png&b=ffffff)

> 温馨提示：如果图片不清晰，可以点击放大查看或者在浏览器中右键并选择**在新标签页中打开图片**查看。

我们重新来回顾一下 `index.html` 的使用，通过执行 `dist/main.js` 可以实现将 `src/index.js` 导出的生命周期函数赋值给 `window.myLibrary`，从而可以通过 `window.myLibrary.bootstrap()` 执行，如下所示：

``` html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 加载 Webpack 构建后的代码 -->
    <script src="./dist/main.js"></script>
    <script>
      // 用于验证是否在 window 上暴露了 myLibrary 库属性
      console.log(window.myLibrary);
      // 模拟 single-spa 执行 myLibrary 上的生命周期函数
      window.myLibrary.bootstrap();
    </script>
  </body>
</html>
```

### devtool 配置说明

上述 `src/index.js` 源码对应的构建代码在模块化包装函数对应的 `eval` 中执行，可能很多同学比较疑惑为什么需要在 `eval` 中执行？其实是为了加快 Webpack 的编译速度，并可以在 Chrome DevTools 调试面板中映射出源码对应的文件目录，从而方便开发者进行代码调试。我们来看下 Chrome DevTools 调试面板，可以发现 `src/index.js` 被编译后的代码在调试面板的 `myLibrary/src/index.js` 映射目录，如下所示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5167a40d1d934c5d9d2c7eb7c73a9f18~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1638&h=1058&s=591955&e=png&b=fefefe)

>温馨提示：Chrome DevTools 会将 `output.library` 的配置 `myLibrary` 定义为调试映射目录的根目录。

我们重新来回顾一下模块化包装函数 `eval` 部分，如下所示：

``` javascript
var __webpack_modules__ = {
    "./src/index.js": (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      // 使用 eval 执行代码模块
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n  console.log("bootstrap");\n}\n\nasync function mount() {\n  console.log("mount");\n}\n\nasync function unmount() {\n  console.log("unmount");\n}\n\nasync function update() {\n  console.log("update");\n}\n\n//# sourceURL=webpack://myLibrary/./src/index.js?'
      );
  }
}
```

默认情况下 `eval` 中的代码都是字符串，难以进行调试，但是在 Webpack 构建代码的尾部增加了一个 `//# sourceURL` 的注释后（查看上图中的蓝框部分），可以使得 Chrome DevTools 识别该注释并将 `eval` 对应的字符串单独抽离成一个可调试的映射文件，如下所示：

``` javascript
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bootstrap: () => (/* binding */ bootstrap),
/* harmony export */   mount: () => (/* binding */ mount),
/* harmony export */   unmount: () => (/* binding */ unmount),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
async function bootstrap() {
  console.log("bootstrap");
}

async function mount() {
  console.log("mount");
}

async function unmount() {
  console.log("unmount");
}

async function update() {
  console.log("update");
}

// 以下注释是一个调试标准，可以被 Chrome DevTools 识别
//# sourceURL=webpack://myLibrary/./src/index.js?
```

> 温馨提示：`sourceURL` 主要为 `eval` 函数或者 `new Function` 构造器执行的字符串动态代码定义一个调试文件，从而可以在 Chrome DevTools 的 Sources 面板中展示该文件并用于断点调试，关于 sourceURL 详细介绍可以查看 [Name eval() calls with #sourceURL（中文版）](https://developer.chrome.com/docs/devtools/javascript/source-maps?hl=zh-cn#sourceurl_and_displayname)。

在这里我们可以修改上述 `sourceURL` 对应的文件映射路径，并查看 Chrome DevTools 的路径变化，例如：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/328984d0807b47b7995d8218a8f535b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1624&h=1044&s=606620&e=png&b=fdfdfd)

需要注意该注释遵循了 [Source Map Revision 3 Proposal](https://sourcemaps.info/spec.html) 规范，从规范中我们可以发现除了使用 `sourceURL` 进行注释之外，还可以使用 `sourceMappingURL` 进行注释。上述 `eval` 对应的调试代码没有完全和源码一致，为了使得 Chrome DevTools 的调试代码和源码一致，需要使用 Webpack 生成 Source Map 文件并借助 `sourceMappingURL` 注释。

为了生成 Source Map 文件，需要在 Webpack 的配置文件中新增 [devtool](https://webpack.docschina.org/configuration/devtool/) 配置字段，例如：

``` javascript
module.exports = {
  output: {
    library: "hello",
  },
  // devtool 包含多种配置类型，例如 eval、eval-cheap-source-map 等
  // 在 development 模式下默认配置是 eval
  // 不同的配置会影响 Webpack 构建 (build) 和重新构建 (rebuild) 的速度
  devtool: "source-map",
};
```

>温馨提示：Webpack 中 [devtool](https://webpack.docschina.org/configuration/devtool/) 配置主要用于支持 Chrome DevTools 调试工具。在 devlopment 模式下，Webpack 的 [devtool](https://webpack.docschina.org/configuration/devtool/#devtool) 配置默认为 `eval`，此时会在打包后的代码中包含 `eval` 函数，使用 `eval` 模式时 Webpack  的构建速度很快，因此推荐在开发环境下使用该调试模式。 在 production 模式下，`devtool` 默认为 `false`，此时不会在打包后生成任何调试信息。当然，有些监控工具为了可以定位详细的错误信息，会要求开发者上传 Souce Map 文件，但是切忌将 Source Map 调试文件发布到线上环境。

执行构建后会生成 `dist/main.js.map` 文件，并会在 `dist/main.js` 的底部生成 `sourceMappingURL` 注释，该注释用于告诉浏览器当前执行的脚本文件关联的源映射（source map）文件的位置。源映射是一种数据格式，它提供了编译后的代码（比如经过压缩或者转译的代码）到源代码的映射信息。当 JavaScript 代码被浏览器执行时，如果存在 `sourceMappingURL` 注释，Chrome DevTools 将利用这一信息来还原构建前的源代码，从而帮助开发者进行源码调试，`dist/main.js` 构建代码如下所示：

``` javascript
var myLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!**********************!*\
  !*** ./src/index.js ***!
  **********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bootstrap: () => (/* binding */ bootstrap),
/* harmony export */   mount: () => (/* binding */ mount),
/* harmony export */   unmount: () => (/* binding */ unmount),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
async function bootstrap() {
  console.log("bootstrap");
}

async function mount() {
  console.log("mount");
}

async function unmount() {
  console.log("unmount");
}

async function update() {
  console.log("update");
}
myLibrary = __webpack_exports__;
/******/ })()
;
// 生成了一个识别 map 文件的调试注释
//# sourceMappingURL=main.js.map
```

源映射文件 `dist/main.js.map` 如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d674b28581c74f688040e91cbe08af58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=984&s=1270168&e=png&b=212121)

> 温馨提示：如果想额外了解 `sourceMappingURL` 对应的源代码位置映射原理，可以查看 [什么是源代码映射？](https://web.dev/articles/source-maps?hl=zh-cn)和  [JavaScript Source Maps 简介](https://developer.chrome.com/blog/sourcemaps?hl=zh-cn#how-does-the-source-map-work)。

最终可以在 Chrome DevTools 调试面板中进行源码调试：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a04538b0851d4ad6b26bd37f57952afd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=906&s=499370&e=png&b=fefefe)

## Webpack 运行时 `libraryTarget` 配置分析

尽管在 Webpack 中暴露 `window.myLibrary` 属性后可以在浏览器中引入构建脚本来获取对应的生命周期函数，但是开发者可以随意定义该属性的名称（例如 `window.yourLibrary`），如果主子应用没有对属性名称进行约定，在主应用中很难设计通用的微应用生命周期获取方案。

在 qiankun 的 Webpack 配置中，除了配置 `output.library`，还需要配置 `output.libraryTarget` 为 `umd`，使其通过 UMD （Universal Module Definition，通用模块定义）规范进行导出：

``` javascript
// webpack.config.js
module.exports = {
  output: {
    library: "myLibrary",
    libraryTarget: "umd",
  }
};
```

> 温馨提示：配置 `library: 'myLibrary'` 后构建脚本只能通过 `<script>` 标签引入执行并通过 `window.myLibrary` 获取生命周期，而 Webpack 导出 UMD 规范后可以使得构建脚本在原有 `<script>` 标签引入方式的基础上，增加 CommonJS、AMD 等环境的引入，从而使得构建脚本能够兼容更多的运行环境。如果对 UMD 不清楚，可以查看 [What are UMD modules？](https://jameshfisher.com/2020/10/04/what-are-umd-modules/)。

构建后的脚本仍然可以在浏览器中通过 `window.myLibrary` 进行访问，如下所示：

``` javascript
// 这里导出了 UMD 规范的代码，可以在浏览器中直接使用
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  else if (typeof define === "function" && define.amd) define([], factory);
  else if (typeof exports === "object") exports["myLibrary"] = factory();
  // 通过 <script> 标签引入会执行如下代码
  // window.myLibrary = factory()
  // 这里的 root 在浏览器中指代的是 window 对象
  else root["myLibrary"] = factory();
})(self, () => {
  return (() => {
    // webpackBootstrap
    "use strict";
    var __webpack_modules__ = {
      "./src/index.js": (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n  console.log("bootstrap");\n}\n\nasync function mount() {\n  console.log("mount");\n}\n\nasync function unmount() {\n  console.log("unmount");\n}\n\nasync function update() {\n  console.log("update");\n}\n\n//# sourceURL=webpack://myLibrary/./src/index.js?'
        );
      },
    };

    // The require scope
    var __webpack_require__ = {};

    /* webpack/runtime/define property getters */
    (() => {
      // define getter functions for harmony exports
      __webpack_require__.d = (exports, definition) => {
        for (var key in definition) {
          if (
            __webpack_require__.o(definition, key) &&
            !__webpack_require__.o(exports, key)
          ) {
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key],
            });
          }
        }
      };
    })();

    /* webpack/runtime/hasOwnProperty shorthand */
    (() => {
      __webpack_require__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop);
    })();

    /* webpack/runtime/make namespace object */
    (() => {
      // define __esModule on exports
      __webpack_require__.r = (exports) => {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module",
          });
        }
        Object.defineProperty(exports, "__esModule", { value: true });
      };
    })();

    // startup
    // Load entry module and return exports
    // This entry module can't be inlined because the eval devtool is used.
    var __webpack_exports__ = {};
    __webpack_modules__["./src/index.js"](
      0,
      __webpack_exports__,
      __webpack_require__
    );

    return __webpack_exports__;
  })();
});
```

我们可以对构建代码进行简化，之前我们分析了构建代码的模块化运行时，这些代码的执行没有任何变化，只是将其封装在了一个工厂函数 `factory` 中，如下所示：

``` javascript
// 这里导出了 UMD 规范的代码，从而支持了 CommonJS、AMD 和浏览器运行环境
(function webpackUniversalModuleDefinition(root, factory) {
  // 通过判断环境来导出不同的模块
  // 1. 如果是 CommonJS 规范的环境，则使用 module.exports 导出
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  // 2. 如果是 AMD 规范的环境，则使用 define 导出
  else if (typeof define === "function" && define.amd) define([], factory);
  // 3. 在 CommonJS-like 环境中导出模块，但不是 Node.js 环境
  else if (typeof exports === "object") exports["myLibrary"] = factory();
  // 4. 如果浏览器环境或其他环境，则设置 window.myLibrary = factory();
  else root["myLibrary"] = factory();
  // self 是一个全局对象，它在各种环境中都有定义
  // 包括浏览器的 window 环境、Web Workers、Service Workers 等。
  // 在浏览器环境中，self 和 window 是等价的，都指向全局的 Window 对象。
  // 使用 self 而不是 window，是为了让代码能在各种环境中运行，而不仅仅是浏览器环境。
})(self, () => {
  // 通过 IIFE 的方式自执行模块化运行时代码
  return (() => {

    // 模块化映射对象
    var __webpack_modules__ = {
      "./src/index.js": (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
          bootstrap: () => /* binding */ bootstrap,
        });

        async function bootstrap() {
          console.log("bootstrap");
        }

        // ...
      },
    };

    // 模块化运行时对象
    var __webpack_require__ = {};
    (() => {
      __webpack_require__.d = function () {};
    })()
    
    (() => {
      __webpack_require__.o = function () {};
    })()
    
    (() => {
      __webpack_require__.r = function () {};
    })();

    // 模块导出对象
    var __webpack_exports__ = {};

    // 执行模块化代码，将模块内部的导出对象挂载到 __webpack_exports__ 上
    __webpack_modules__["./src/index.js"](
      0,
      __webpack_exports__,
      __webpack_require__
    );

    // 模块化运行时代码
    // 大部分代码和之前分析的 dist/main.js 运行时一致
    // factory 工厂函数最终返回模块化导出对象，即 window.myLibrary = __webpack_exports__
    return __webpack_exports__;
  })();
});

```

> 温馨提示：在源代码的 ES Module 中引入上述 UMD 规范的代码后，Webpack 是通过什么方式来识别 UMD 模块并进行加载的呢？这里可以先构建一个 UMD 的模块出来，然后重新加载该 UMD 模块进行二次构建，最后分析构建后的代码。


我们重新回顾一下仅使用 `output.library` 的简化代码，如下所示：

``` javascript
var myLibrary;

(() => {
  // 模块化映射对象
  var __webpack_modules__ = {
    "./src/index.js": (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        bootstrap: () => /* binding */ bootstrap,
      });

      async function bootstrap() {
        console.log("bootstrap");
      }

      // ...
    },
  };

  // 模块化运行时对象
  var __webpack_require__ = {};
  (() => {
    __webpack_require__.d = function () {};
  })()(() => {
    __webpack_require__.o = function () {};
  })()(() => {
    __webpack_require__.r = function () {};
  })();

  // 模块导出对象
  var __webpack_exports__ = {};

  // 执行模块化代码，将模块内部的导出对象挂载到 __webpack_exports__ 上
  __webpack_modules__["./src/index.js"](
    0,
    __webpack_exports__,
    __webpack_require__
  );

  // 将 __webpack_exports__ 挂载到 myLibrary 上
  myLibrary = __webpack_exports__;
})();
```

配置 `output.libraryTarget` 为 `umd` 后，构建代码会先执行 `factory()` 返回模块化导出对象 `__webpack_exports__`，最后将模块化导出对象赋值给 `window.myLibrary`，而仅使用 `output.library` 配置则会在起始位置先声明 `var myLibrary`。


## 如何获取生命周期函数

了解了 `output.library & output.libraryTarget` 的配置和 Webpack 的运行时原理后，我们可以重点分析一下两者的差异和规律，探索如何建立一套通用的微应用生命周期函数获取方案，从而减少主应用和微应用识别过程的耦合性。

如果主应用在不知晓微应用配置 `output.library = "myLibrary"`（`myLibrary` 可以是任意值） 的情况下能够自动识别出微应用的全局属性 `window.myLibrary`，那么就可以执行微应用导出的 `window.myLibrary.bootstrap`，从而识别出 single-spa 所需要的生命周期函数。关键在于如何自动识别出 `window.myLibrary`？

由于 `window` 全局对象默认内置了很多属性，因此在应用的起始位置声明 `var myLibrary` 不会使得 `window` 变量的第一个属性是 `myLibrary`，而如果后续的应用代码中存在声明的全局属性，那么也不会是最后一个全局属性，因此只配置 `output.library` 的情况下无法按顺序识别出 `myLibrary`。但是如果在代码执行的最后对 `window.myLibrary` 进行声明和赋值，那么可以在代码执行完毕后立即对 `window` 属性按顺序进行遍历，从而识别出最后声明的属性 `window.myLibrary`，因此在配置 `output.library = "myLibrary"` 的基础上新增 `output.libraryTarget = "umd"` 配置后，可以按顺序遍历属性识别出 `myLibrary`。

> 温馨提示：这里所说的识别出 `window` 最后声明的属性，必须要在当前应用代码 `window.myLibrary = factory()` 执行完毕后立即进行属性遍历。因为应用代码中可能存在即将要执行的宏任务和微任务，这些任务中可能存在全局属性声明，所以这个遍历的方法不能放在微任务或者宏任务中进行处理。

主应用可以在微应用代码执行完毕后立即对 `window` 属性按顺序进行遍历，最后一个获取的属性即为微应用导出的属性。通用的识别逻辑如下所示：

``` javascript
function getAppLifeCycles() {
  // 由于使用 UMD 进行微应用的构建
  // 挂载全局属性的动作是在内部微应用的代码执行完毕后
  // 例如 root["myLibrary"] = factory()
  // 这里的 factory 包含了内部微应用代码的执行
  
  // Object.keys()的返回顺序如下：
  // 数字键（整数索引），按照升序排列。
  // 字符串键，按照它们被添加到对象的顺序。
  // 符号键，按照它们被添加到对象的顺序。
  
  // 由于 Object.keys() 只返回字符串键，因此只需要关心数字键和字符串键。
  // 数字键会被视为数组索引并按照数值升序排列，
  // 字符串键则会按照它们创建时的顺序排列。
  // 符号键不会被 Object.keys() 返回，但如果要获取它们，可以使用 Object.getOwnPropertySymbols()。

  // 注意，这里的“数字键”指的是那些可被转换为 32 位无符号整数的字符串键
  // 它们属于数组索引的范围，即在 0 到 2^32-1 之间的整数。
  // 对于这些数字键，即使它们是作为对象的属性添加的，它们也会被当作数组索引并按照数值排序。
  // 其他非数字的字符串键则按照它们添加到对象的顺序进行枚举。

  // for...in
  // 需要注意和 for...in 的区别，for...in 还能遍历原型链上的属性
  
  const keys = Object.keys(window);
  const app = window[keys[keys.length - 1]];
  let lifeCycles = {};
  Object.keys(app).forEach((key) => {
    const lifecycle = app[key];
    if (lifecycle && typeof lifecycle === "function") {
      // 将子应用的所有 lifeCycle 函数进行包装，包装成返回 Promise 的
      lifeCycles[key] = async (...args) => {
        console.log(`[main-app] ${key} start`);
        await lifecycle(...args);
        console.log(`[main-app] ${key} end`);
      };
    }
  });
  return lifeCycles;
}
```

其中 `Object.keys` 可以获取到对象的属性，不会遍历原型链上的属性，并且字符串键会按照它们创建时的顺序排列，是按顺序遍历属性的重要 API。关于 `Object.keys` 获取对象自身属性的返回顺序可以查看 [ECMAScript 2015 标准 `Object.keys (O)`](https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-object.keys)：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05158ff7c71447c78fd03fd0ae0edc64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1802&h=536&s=283819&e=png&b=fdfdfc)

上述执行步骤的重点是 `nameList` 对应的 [EnumerableOwnNames (O)](https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-enumerableownnames)：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/991fb9952511458ab069adf575a7a7df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1776&h=894&s=510053&e=png&b=fdfdfc)

上述操作用于获取对象所有可枚举的自有属性名称，返回按特定顺序排列的字符串列表：

- 确保传入的 O 是一个对象（只有对象才有属性）
- 获取对象 O 的 `[[OwnPropertyKeys]]()`（不包含原型链上继承的属性），存储在 `ownKeys` 中
- 创建一个新的空列表 `names`，用于存储最终的结果
- 遍历 `ownKeys` 中的每一个键：
    -  如果键的类型是字符串（不包含 `Symbol` 类型的属性），获取该键对应的[属性描述符](https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p)`[[GetOwnProperty]](key)`，存储在 `desc` 中（包含了属性的值、是否可写、是否可枚举、是否可配置等信息）
    -  如果 `desc` 不是 `undefined`（属性确实存在），并且 `desc` 的 [[Enumerable]] 属性是 `true`（属性可枚举），那么就把这个键添加到 `names` 列表中
- 对 `names` 列表中的元素进行排序，使它们的相对顺序与通过在对象 O 上调用 [[Enumerate]] 内部方法返回的迭代器产生的顺序相同。
- 返回 `names` 列表

上述第 6 步的排序还依赖第 2 步 `[[OwnPropertyKeys]]()` 返回的顺序结果，因此我们重点来看下 `[[OwnPropertyKeys]]()` 的[定义](https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys)：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bce71b4912e4e759bbbe365104b496d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1702&h=586&s=352065&e=png&b=fcfcfb)


上述方法用于获取对象的所有自有属性的键，返回的是一个按特定顺序排列的列表:

- 创建一个新的空列表 `keys`，用于存储最终的结果
- 遍历对象 O 的所有自有属性键：
    - 如果键 P 是一个整数索引，那么按照升序将 P 添加到 `keys` 列表的末尾。主要应用于数组，因为数组的键就是整数索引。
    - 如果键 P 是一个字符串，但不是整数索引，那么按照它们被添加到对象的顺序将 P 添加到 `keys` 列表的末尾。
    - 如果键 P 是一个 `Symbol` 类型，那么按照它们被添加到对象的顺序将 P 添加到 `keys` 列表的末尾。
- 返回 `keys` 列表，这个列表包含了对象 O 的所有自有属性的键，按照特定的顺序排列。


综上所述，`Object.keys` 可以按添加的顺序遍历自身的可枚举的字符串键的属性，并且不会枚举原型链上继承的属性以及 `Symbol` 键类型的属性。

> 温馨提示：感兴趣的同学可以查看一下 `for...in` 的[定义](https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-for-in-and-for-of-statements-static-semantics-early-errors)，并对比一下和 `Object.keys` 定义的差异，上述获取生命周期函数的识别算法能用 `for...in` 代替  `Object.keys` 吗？


## Fetch 示例

了解了 Webpack 配置的运行时原理以及如何识别微应用的生命周期函数后，我们可以设计一个更加解耦的微应用生命周期函数获取方案。整体的目录结构如下所示：

``` bash
├── packages  
│   ├── main-app/                # 主应用
│   ├── react-app/               # React 微应用
│   ├── single-spa/              # single-spa 5.9.5 版本
│   └── vue-app/                 # Vue 微应用
└── lerna.json                   # Lerna 配置
```

> 温馨提示：示例源码可以从 micro-framework 的 [demo/single-spa-fetch](https://github.com/ziyi2/micro-framework/tree/demo/single-spa-fetch) 分支获取。

Fetch 方案示例的实现流程如下所示，当主应用切换路由时会先失活没有匹配路由的微应用，执行相应的 `unmount` 函数卸载微应用，然后会激活匹配路由的微应用，通过 Fetch 请求获取微应用的脚本文本，然后使用 `eval` 执行脚本代码，并立即获取执行代码后的微应用生命周期函数，最后执行 `mount` 函数挂载应用，从而实现监听路由切换微应用的功能：

![yuque_diagram (1).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962e429015594661b434977c82d08b27~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2326&h=860&s=274412&e=png&b=fefefe)


### 主应用设计

首先来看下 Fetch 示例的实现效果，如下所示，点击左侧的导航切换路由，使用 single-spa 监听路由的变化来切换微应用：

![录屏2024-02-22 09.29.28.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac467e38156944d79a5bc90efadb6194~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2054&h=1014&s=1272994&e=gif&f=96&b=fbfbfb)

> 温馨提示：切换路由的时候可以通过 Network 发现使用 Fetch 请求获取了微应用的 JS 脚本文本。在控制台还可以查看微应用通过 UMD 导出的全局属性名称。除此之外，在 single-spa 源码的各个阶段植入了很多打印信息，可以根据打印信息来感性了解 single-spa 的内部运行机制。

主应用的目录结构如下所示：

``` bash
├── src                  
│   ├── index.js            # 入口文件，包含了 single-spa 的注册和 React 路由             
│   ├── App.js              # 主应用布局，包含了导航和内容区的布局设计           
│   └── utils/              # 工具方法
│        ├── micros.js      # 微应用数据信息（Mock 后端数据结构）      
│        └── single-spa.ts  # single-spa 的注册 API 封装

```

在 `src/utils/micros.js` 中定义了微应用列表的数据结构（在真实业务场景中这个数据会更复杂，并且可以从服务端进行动态加载），该数据主要用于注册 single-spa 的微应用、生成 React 路由和主应用导航，如下所示：

``` typescript
// src/utils/micros.js
// 微应用容器元素的 ID
export const MICRO_APP_CONTAINER_ID = "micro-app-container";

export const MICRO_APP_ROUTER = {
  REACT: "react",
  VUE: "vue",
};

// 菜单信息，这里用于 Mock 后端数据
// 真实业务可能是一个树状的带权限的菜单信息
export const mockMicroApps = [
  {
    // 应用标识
    name: "react",
    // 菜单名称
    title: "React Micro App",
    // NPM 包名称
    app: "react-micro-app",
    // 激活路由
    router: MICRO_APP_ROUTER.REACT,
  },
  {
    name: "vue",
    title: "Vue Micro App",
    app: "vue-micro-app",
    router: MICRO_APP_ROUTER.VUE,
  },
];
```

主应用在初始化时需要消费微应用列表数据，在初始化时使用 single-spa 注册微应用并生成对应的 React 路由：

``` typescript
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App.tsx";
import reportWebVitals from "./reportWebVitals.js";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { registerMicroApps, fetchApp } from "./utils/single-spa.ts";
import { MICRO_APP_CONTAINER_ID, mockMicroApps } from "./utils/micros.ts";

// 对 single-spa 的注册 API 进行了二次封装，支持传入数组进行批量注册
registerMicroApps(
  // 根据后端提供的动态数据批量注册微应用
  mockMicroApps.map((item) => ({
    name: item.name,
    app: () => {
      // 通过 Fetch 请求方式获取
      return fetchApp(item.entry);
    },
    activeWhen: item.router,
    customProps: {
      // 向微应用传递需要挂载的容器元素 ID
      container: MICRO_APP_CONTAINER_ID,
    },
  }))
);

const router = createBrowserRouter([
  {
    path: "/",
    // <App /> 中提供了左侧导航栏和右侧内容区域的布局结构
    element: <App />,
    // children 中的元素会被渲染到 <App /> 的 <Outlet /> 中
    // <Outlet> 是 react-router-dom 提供的一个组件，用于渲染子路由：https://reactrouter.com/en/main/components/outlet

    // 遍历迭代 mockMicroApps 中的数据，生成对应的路由配置
    // 这里的路由配置和微应用注册 API 中的 activeWhen 一致
    children: mockMicroApps.map((item) => ({
      path: item.router,
      // 微应用的容器元素，用于渲染微应用
      element: <div id={MICRO_APP_CONTAINER_ID}></div>,
    })),
  },
]);

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(<RouterProvider router={router} />);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

在 `src/utils/single-spa.ts` 中重点看下 `fetchApp` 的实现，通过 `window.fetch` 获取微应用的 JS 脚本文本进行动态执行，执行完成后立马获取相应的生命周期函数：

``` typescript
// 这里使用 npm link 进行连接调试
import { start, registerApplication } from "single-spa/src/single-spa";
import { LifeCycles, RegisterApplicationConfig } from "single-spa";

// 对 single-spa 的 registerApplication 进行二次封装，使其可以接收一个数组，批量注册子应用
export function registerMicroApps(apps: RegisterApplicationConfig[]) {
  // @ts-ignore
  // 如果不开启 __DEV__，single-spa 的源码无法正常运行
  window.__DEV__ = true;
  apps.forEach(registerApplication);
  start();
}

export function getAppLifeCycles() {
  // 使用 UMD 进行子应用的构建，挂载全局变量的动作是在内部微应用的代码执行完毕后
  // 例如 root["myLibrary"] = factory(), 这里的 factory 包含了内部微应用代码的执行
  // 因此这里通过遍历全局对象的属性顺序拿到子应用的生命周期函数

  // Object.keys 可以获取到对象的属性
  // 对象自身属性的返回顺序查看 ECMAScript 2015 标准：
  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys

  // 按照这个规范，Object.keys() 的返回顺序如下：

  // 数字键（整数索引），按照升序排列。
  // 字符串键，按照它们被添加到对象的顺序。
  // 符号键，按照它们被添加到对象的顺序。
  // 由于 Object.keys() 只返回字符串键，因此只需要关心数字键和字符串键。
  // 数字键会被视为数组索引并按照数值升序排列，而字符串键则会按照它们创建时的顺序排列。
  // 符号键不会被 Object.keys() 返回，但如果要获取它们，可以使用 Object.getOwnPropertySymbols()。

  // 注意，这里的“数字键”指的是那些可被转换为32位无符号整数的字符串键，它们属于数组索引的范围，即在0到2^32-1之间的整数。
  // 对于这些数字键，即使它们是作为对象的属性添加的，它们也会被当作数组索引并按照数值排序。其他非数字的字符串键则按照它们添加到对象的顺序进行枚举。

  // 需要注意和 for...in 的区别，for...in 还能遍历原型链上的属性

  // for...in
  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-for-in-and-for-of-statements-static-semantics-early-errors

  const keys = Object.keys(window);
  const lifeCycles = window[keys[keys.length - 1]];
  // 打印微应用 UMD 构建导出的全局属性
  console.info(
    "%c当前 window 对象的最后一个属性是：%c" + keys[keys.length - 1],
    "color: blue; font-weight: bold; font-size: 20px;",
    "color: red; font-weight: bold; font-size: 20px;"
  );
  return lifeCycles as LifeCycles;
}

export async function fetchApp(url: string) {
  const res = await window.fetch(url);
  const text = await res.text();

  // 为什么 qiankun 更加推荐使用 eval 而不是 script 呢？
  // 错误处理：(0, eval) 执行的代码若出现错误，可以通过 try-catch 语句捕获异常进行处理，而 script 标签注入的代码需要通过监听 error 事件来处理异常。
  // 执行时机：使用 script.textContent 插入并执行代码的时机可以被精确控制，因为它发生在你将 script 元素添加到 DOM 的那一刻。而使用 (0, eval) 执行的代码通常是立即执行的，一旦调用，代码就会运行。
  // 性能: 对于大型应用，qiankun 需要动态加载和卸载子应用，script 标签的插入和删除可能会导致性能问题，而 (0, eval) 可以更容易地控制这些操作。
  // 安全性: 使用 script 标签可能会导致某些安全性问题，比如内容安全策略（CSP）的违反，而 (0, eval) 可以更容易地遵守这些策略。
  // 兼容性: 在某些老旧浏览器中，动态插入 script 标签可能会遇到兼容性问题，使用 (0, eval) 可以提供更一致的跨浏览器行为。
  // 调试: <script> 标签内的代码或通过其 src 属性加载的外部脚本在浏览器的开发者工具中通常有更好的调试体验，可以提供源代码映射。
  // (0, eval) 执行的代码在调试时可能更加困难，特别是如果执行的是压缩或动态生成的代码字符串，那么可能难以找到代码出错的具体位置。

  // 使用 <script> 标签插入内联代码可能会遇到 CSP 限制，因为 CSP 可以禁止执行页面上的内联脚本作为一种安全措施。
  // 现在 Chrome 开发工具可以调试 eval() 内的代码，但是必须等代码执行一次后才出现在源面板中。

  // 使用 script 元素执行
  // const script = document.createElement("script");
  // script.textContent = text;
  // document.head.appendChild(script);

  // 使用 eval 执行
  // (0, eval) 和 eval 的区别是什么？为什么需要使用 (0, eval) 执行？
  (0, eval)(text);

  // 执行微应用的代码后立即获取对应的生命周期函数
  return getAppLifeCycles();
}
```

最后在 `<App>` 中对主应用进行布局设计，将左侧设计成能够切换路由的导航，导航的信息来源于微应用数据列表，右侧设计成用于渲染微应用的内容区：

``` jsx
// src/App.js
import { Outlet, Link } from "react-router-dom";
import "./App.css";
import { mockMicroApps } from "./utils/micros";

function App() {
  return (
    <div className="app">
      <div className="app-nav">
        <p>Micro App List</p>
        <nav>
          <ul>
            {/* 遍历微应用的数据列表生成导航路由信息 */}
            {mockMicroApps.map((item) => (
              <li key={item.name}>
                <Link to={item.router}>{item.title}</Link>
              </li>
            ))}
          </ul>
        </nav>
      </div>
      <div className="app-content">
        {/* 这里的 <Outlet /> 会被 <RouterProvider router={router} /> 中 router 提供的 children 进行替换 */}
        {/* 所以本质上会被微应用的容器元素 <div id={MICRO_APP_CONTAINER_ID}></div> 替代  */}
        <Outlet />
      </div>
    </div>
  );
}

export default App;
```

### 微应用设计

在了解了 Webpack 的运行原理后，为了可以在主应用中通过 `getAppLifeCycles` 按顺序遍历获取微应用导出的全局属性，需要在微应用中新增如下 Webpack 配置：

``` javascript
// webpack 5.x
const packageName = require('./package.json').name;

module.exports = {
  output: {
    // library 和 libraryTarget 用于暴露微应用的生命周期函数
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
  },
};

// webpack 4.x
const packageName = require('./package.json').name;


module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
  },
};
```

本课程的 React 示例需要在 `config/webpack.config.js` 中新增如下配置：

``` javascript
// config/webpack.config.js
module.exports = function(webpackEnv) {
  // ...

  // common function to get style loaders
  const getStyleLoaders = (cssOptions, preProcessor) => {
    const loaders = [
      // 注释掉抽离 CSS 样式的插件功能
      // isEnvDevelopment && require.resolve("style-loader"),
      // isEnvProduction && {
      //   loader: MiniCssExtractPlugin.loader,
      //   // css is located in `static/css`, use '../../' to locate index.html folder
      //   // in production `paths.publicUrlOrPath` can be a relative path
      //   options: paths.publicUrlOrPath.startsWith(".")
      //     ? { publicPath: "../../" }
      //     : {},
      // },
      
      require.resolve("style-loader"),
      {
        loader: require.resolve("css-loader"),
        options: cssOptions,
      },
      // ...
    ].filter(Boolean);
    // ...
    return loaders;
  };
  
  return {
    output: {
      // ...
      
      // 需要确保唯一性
      library: "reactMicroApp",
      // 构建输出 UMD 规范
      libraryTarget: "umd",
    },

    module: {
      rules: [
        {
          oneOf: [
            // TODO: Merge this config once `image/avif` is in the mime-db
            // https://github.com/jshttp/mime-db
            {
              test: [/.avif$/],
              mimetype: "image/avif",
              // 内联处理
              // https://webpack.js.org/guides/asset-modules/#inlining-assets
              type: 'asset/inline',
            },
            // "url" loader works like "file" loader except that it embeds assets
            // smaller than specified limit in bytes as data URLs to avoid requests.
            // A missing `test` is equivalent to a match.
            {
              test: [/.bmp$/, /.gif$/, /.jpe?g$/, /.png$/],
              // 内联处理
              type: 'asset/inline',
            },
            {
              test: /.svg$/,
              // 内联处理
              type: 'asset/inline',

              // 注释
              
              // use: [
              //   {
              //     loader: require.resolve("@svgr/webpack"),
              //     options: {
              //       prettier: false,
              //       svgo: false,
              //       svgoConfig: {
              //         plugins: [{ removeViewBox: false }],
              //       },
              //       titleProp: true,
              //       ref: true,
              //     },
              //   },
              //   {
              //     loader: require.resolve("file-loader"),
              //     options: {
              //        name: "static/media/[name].[hash].[ext]",
              //     },
              //   },
              // ],
              
              issuer: {
                and: [/.(ts|tsx|js|jsx|md|mdx)$/],
              },
            },
          ]
        }
      ].filter(Boolean),
    },

    plugins: [
      
      // ...
      
      // 构建单个 JS 脚本
      new webpack.optimize.LimitChunkCountPlugin({
        maxChunks: 1,
      }),
    ].filter(Boolean),
  }
}
```

> 温馨提示：这里构建输出单个 JS Bundle，因此不需要额外配置代码分离的 `output.chunkLoadingGlobal` 或者 `output.jsonpFunction`。除此之外，为了保证全局属性的唯一性（防止冲突），可以在配置 `output.library` 时采用 [uuid](https://github.com/uuidjs/uuid) 设置唯一性。


同时在 React 微应用的入口文件中导出生命周期函数，如下所示：

``` typescript
// src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
// import reportWebVitals from './reportWebVitals';

let root;

// 判断是否在 single-spa 的环境中运行
// 如果不是，那么说明不在微前端的环境中，可以独立启动
if (!window.singleSpaNavigate) {
  root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

/**
 * bootstrap 只会在微应用首次激活时调用一次
 * 微应用重新激活时会直接调用 mount 周期函数，不会再重复触发 bootstrap。
 * 通常情况下这里不需要进行任何处理，初始化的代码可以放在当前入口文件的顶层处理
 * 除非会执行微应用的 unload 动作，然后需要再次执行 bootstrap，可能需要在此做一些必要的初始化动作
 * 注意这里的周期函数不是 async 函数，在主应用中引入该周期函数后需要进行 async 处理
 */

// 注意这里的每一个生命周期函数必须是 async 函数
export async function bootstrap() {
  console.log("[React 子应用] bootstrap excuted");
}

/**
 * 微应用每次激活时都会调用 mount 周期函数，通常在这里执行微应用的渲染
 */
export async function mount(props) {
  console.log("[React 子应用] mount excuted, props: ", props);
  // 在 single-spa 的注册 API 中会通过 customProps 传递 container 微应用容器元素 ID
  // 因此这里将微应用挂载在主应用的容器元素上
  root = ReactDOM.createRoot(document.getElementById(props.container));
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}

/**
 * 微应用每次失活时会调用 unmount 周期函数，通常在这里执行微应用的卸载
 */
export async function unmount(props) {
  console.log("[React 子应用] unmount excuted, props: ", props);
  root && root.unmount();
}

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
// reportWebVitals();

```

Vue 示例也需要进行更改，首先使其支持构建单个 Bundle 文件：

``` javascript
// vue.config.js
const { defineConfig } = require("@vue/cli-service");
module.exports = defineConfig({
  transpileDependencies: true,
  css: { extract: false },
  configureWebpack: {
    optimization: {
      splitChunks: false,
    },
    output: {
      // 需要确保唯一性，可以使用 uuid 来设置
      library: "vueMicroApp",
      // 构建输出 UMD 规范
      libraryTarget: "umd",
    },
  },
  
  // 需要注意主应用和微应用端口不同形成了跨域
  // 为了通过 fetch 请求微应用的 JS 脚本，需要微应用的开发态服务支持跨域
  // 上一个课程通过 <script> 标签的方式加载天然支持跨域
  devServer: {
    headers: {
      "Access-Control-Allow-Origin": "*",
    },
  },
});
```

> 温馨提示：React 微应用的 `config/webpackDevServer.config.js` 默认已经设置了跨域配置，因此不需要额外进行配置。

同时在 Vue 微应用的入口文件中导出生命周期函数，如下所示：

``` typescript
// src/main.js
import { createApp } from "vue";
import App from "./App.vue";
let app;

// 判断是否在 single-spa 的环境中运行
// 如果不是，那么说明不在微前端的环境中，可以独立启动
if (!window.singleSpaNavigate) {
  app = createApp(App);
  app.mount("#app");
}

// 注意这里的每一个生命周期函数必须是 async 函数
export async function bootstrap() {
  console.log("[Vue 子应用] bootstrap excuted");
}

export async function mount(props) {
  console.log("[Vue 子应用] mount excuted, props: ", props);
  app = createApp(App);
  app.mount(`#${props.container}`);
}

export async function unmount(props) {
  console.log("[Vue 子应用] unmount excuted, props: ", props);
  app && app.unmount();
}
```

## 小结

本课程讲解了 Fetch 请求方案的实现示例，重点讲解了如何实现解耦的微应用生命周期函数获取方案。为了实现该方案，需要额外进行 Webpack 配置，因此还讲解了 Webpack 配置对应的运行时原理。为了加深大家对本课程的理解，可以额外思考一下，上一个课程的 Script 示例是否可以参考本课程的主应用示例通过 `getAppLifeCycles`来获取生命周期函数？在下一个课程中，我们会讲解代码分离的 single-spa 微前端示例。

