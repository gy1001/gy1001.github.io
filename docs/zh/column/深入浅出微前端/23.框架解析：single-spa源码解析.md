在之前的四个课程中，我们重点讲解了如何使用 single-spa 设计微前端，这使得大家对于 single-spa 有了感性认知，本课程接下来重点讲解 single-spa 的内部运行原理，为了解 qiankun 的使用和内部运行原理奠定基础。

> 温馨提示：为了防止源码解析偏差，本课程讲解的 single-spa 源码基于 5.9.5 版本。

# 为什么需要解析源码

在使用 qiankun 或者 single-spa 的过程中，大家经常会遇到微前端框架无法正常加载微应用的情况，在这种情况下框架通常会给出错误提示，例如微应用没有导出生命周期函数：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b275f07f69041a6b94d025e741b2511~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2272\&h=682\&s=353714\&e=png\&a=1\&b=faf3f2)
single-spa 会给出 `application ${appName} died in status ${status}：${errorMessage}` 错误提示，当然上述错误示例相对简单，而有些信息看起来比较隐晦，很难一眼看出微应用无法加载的根本原因。为此，我们可以了解微应用框架的内部运行机制，帮助我们快速进行问题排查。

除此之外，了解框架源码也会使我们在使用框架时更加得心应手，可以更好的结合 Vue 或者 React 框架的路由来实现微应用的切换，例如：single-spa 如何感知 Vue 或者 React 框架路由的变化从而切换微应用？它是如何保证框架路由的代码执行完毕后再执行微应用的加载和卸载？接下来我们以上一个课程的 Fetch 示例来重点讲解 single-spa 的内部运行原理。


# 阅读建议

single-spa 的源码解析主要分为三个部分：**源码剖析**、**场景剖析**、**状态和事件剖析**。如果你觉得源码剖析太枯燥，可以先大致扫一下 single-spa 有哪些函数，这些函数的作用是什么。然后在场景剖析中详细了解这些函数的执行流程，有了完整的执行流程概念后，如果还想深入了解内部的运行机制，可以重新回来阅读源码剖析中的代码注释。

# 源码剖析

整个 single-spa 源码可以被分为几个主要部分，如下所示：

- `applications`：注册微应用并解析微应用的注册参数
- `start`：启动微应用的生命周期函数执行
- `navigation`：处理导航事件、根据导航变化计算和执行微应用的变化
- `lifecycles`：异步执行微应用的生命周期函数以及相应的错误处理

> 温馨提示：源码解析不包含 single-spa 的 `parcels` 部分，感兴趣的同学需要自行了解。示例源码可以从 micro-framework 的 [analyze/single-spa](https://github.com/ziyi2/micro-framework/tree/analyze/single-spa) 分支获取。

## `applications` 解析

### `registerApplication` 入参解析

`registerApplication` 是 single-spa 对外提供的注册 API，它可以通过对象或者函数两种方式进行调用，在主应用中的使用如下所示：

```javascript
// single-spa-config.js  
// 引入 single-spa 的 NPM 库包
import { registerApplication, start } from 'single-spa';  
  
// 函数调用方式，需要提供四个参数
registerApplication(  
  // 参数 1：微应用名称标识
  'app2',  
  // 参数 2：微应用加载逻辑 / 微应用对象，必须返回 Promise
  () => import('src/app2/main.js'),  
  // 参数 3：微应用的激活条件
  (location) => location.pathname.startsWith('/app2'),  
  // 参数 4：传递给微应用的 props 数据
  { some: 'value' }  
);  
  
// 对象调用方式，只需要一个对象参数
// 更加清晰，易于阅读和维护，无须记住参数的顺序
registerApplication({  
  // name 参数
  name: 'app1',  
  // app 参数，必须返回 Promise
  app: () => import('src/app1/main.js'),  
  // activeWhen 参数
  activeWhen: '/app1',  
  // customProps 参数
  customProps: {  
    some: 'value',  
  }  
});  
```

在使用库包 API 时可以通过 signle-spa 对外提供的 TypeScript 声明进行参数的自动提示，这里可以查看 [typings/single-spa.d.ts](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/typings/single-spa.d.ts#L163) 的 `registerApplication` 参数声明：

```javascript
// typings/single-spa.d.ts

// 函数调用方式，需要提供四个参数
export function registerApplication<ExtraProps extends CustomProps = {}>(
    // 参数 1：微应用名称标识
    appName: string,
    // 参数 2：微应用加载逻辑 / 微应用对象
    applicationOrLoadingFn: Application<ExtraProps>,
    // 参数 3：微应用的激活条件
    activityFn: ActivityFn,
    // 参数 4：传递给微应用的 props 数据
    // 由于外部可以传入自定义数据，因此需要一个泛型可以让外部对该参数进行自定义声明
    customProps?: ExtraProps | CustomPropsFn<ExtraProps>
): void;

// 对象调用方式，只需要一个对象参数
export function registerApplication<ExtraProps extends CustomProps = {}>(
    config: RegisterApplicationConfig<ExtraProps>
): void;

// 对象调用方式的参数声明
export type RegisterApplicationConfig<ExtraProps extends CustomProps = {}> = {
  // 参数 1：微应用名称标识
  name: string;
  // 参数 2：微应用加载逻辑 / 微应用对象
  app: Application<ExtraProps>;
  // 参数 3：微应用的激活条件
  activeWhen: Activity;
  // 参数 4：传递给微应用的 props 数据
  customProps?: ExtraProps | CustomPropsFn<ExtraProps>;
};
```

> 温馨提示：从上述函数调用方式和对象调用方式可以发现参数 3 的声明存在差异，在函数调用中声明的是 `ActivityFn（函数方式）`，而在对象调用方式中则是 `Activity`，而其余参数声明相同。

#### 参数 2

参数 2 主要是在首次激活微应用时获取微应用的生命周期函数。我们来看下参数 2 声明的 `Application<ExtraProps>`，从下述代码可以发现参数 2 可以是一个微应用生命周期对象 `LifeCycles<ExtraProps>`，也可以是一个返回 `Promise<LifeCycles<ExtraProps>>` 的函数，其中 `LifeCycles<ExtraProps>` 必须包含 `boostrap`、`mount` 和 `unmount` 等属性，这些属性的值 `LifeCycleFn<ExtraProps>` 也必须是 `async` 函数。如下所示：

```javascript
// 参数 2 app 的详细声明
type Application<ExtraProps = {}> =
  // 可以是 LifeCycles<ExtraProps>
  // 这里先忽略 <ExtraProps>，会在参数 4 中进行讲解
  | LifeCycles<ExtraProps>
  // 也可以是一个返回了 LifeCycles<ExtraProps> 的 async 函数（注意需要返回 Promise）
  | ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>);
  
// LifeCycles<ExtraProps> 声明的是一个对象，
// 包含了微应用的生命周期
export type LifeCycles<ExtraProps = {}> = {
  // 这里可以是一个 LifeCycleFn<ExtraProps>，
  // 也可以是一个内含 LifeCycleFn<ExtraProps> 的数组
  bootstrap: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  // update 和 Parcel 息息相关，
  // 在 Application 中不会使用，这里可以先忽略
  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
};

// LifeCycleFn<ExtraProps> 是一个 async 函数（注意需要返回 Promise）
type LifeCycleFn<ExtraProps> = (
  config: ExtraProps & AppProps
) => Promise<any>;
```

因此参数 2 可以是以下四种数据格式：

```javascript
// LifeCycles<ExtraProps> 示例 1：对象形式
{
  // 每一个生命周期都是一个 async 函数
  async bootstrap(props) {
    console.log("app bootstraped");
  },
  async mount(props) {
    console.log("app mounted");
  },
  async unmount(props) {
    console.log("app unmounted");
  }
},

// LifeCycles<ExtraProps> 示例 2：对象形式
{
  // 每一个生命周期都是内含 async 函数的数组
  bootstrap: [
    async (props) => {
      console.log("app first bootstraped");
    },
    async (props) => {
      console.log("app second bootstraped");
    },
  ],
  mount: [
    async (props) => {
      console.log("app first mount");
    },
    async (props) => {
      console.log("app second mount");
    },
  ],
  unmount: [
    async (props) => {
      console.log("app first unmount");
    },
    async (props) => {
      console.log("app second unmount");
    },
  ],
};



// ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>) 
// 示例 1：函数形式
async (props) => {
  return {
    async bootstrap(props) {
      console.log("app bootstraped");
    },
    async mount(props) {
      console.log("app mounted");
    },
    async unmount(props) {
      console.log("app unmounted");
    }
  };
}

// ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>) 
// 示例 2：函数形式
async (props) => {
  return {
    // 每一个生命周期都是内含 async 函数的数组
    bootstrap: [
      async (props) => {
        console.log("app first bootstraped");
      },

      async (props) => {
        console.log("app second bootstraped");
      },
    ],
    mount: [
      async (props) => {
        console.log("app first mount");
      },

      async (props) => {
        console.log("app second mount");
      },
    ],
    unmount: [
      async (props) => {
        console.log("app first unmount");
      },

      async (props) => {
        console.log("app second unmount");
      },
    ],
  }
```

> 温馨提示：在 qiankun 中使用了上述哪种数据格式呢？为什么要使用这种数据格式呢？

#### 参数 3

参数 3 会在应用初始化或者路由变化时触发执行，主要用于判断微应用的激活和失活。每一个微应用都需要声明自己的激活判断条件，参数 3 的类型声明如下所示：

```javascript
// 函数调用方式
// 必须是函数，可以获取 location 参数，而且必须返回 boolean 用于判断是否激活微应用
type ActivityFn = (location: Location) => boolean;

// 对象调用方式
// 可以是一个函数、字符串、或者函数和字符串两种联合类型的数组
type Activity = ActivityFn | string | (ActivityFn | string)[];
```

参数 3 可以是以下几种格式：

```javascript
// 函数调用方式
(location) => {
  return location.pathname.startsWith('/react')
}

// 对象调用方式（字符串）
"/react"

// 对象调用方式（联合类型的数组）
[
  // 函数
  (location) => {
    return location.pathname.startsWith('/vue')
  },
  // 字符串
  "/vue"
]

```

#### 参数 4

当微应用激活或者失活时都会执行相应的生命周期函数，此时在主应用中注册微应用时可以将主应用的信息通过参数 4 传递给微应用的生命周期函数。微应用在执行生命周期函数时可以通过参数的方式获取传递信息，从而实现和主应用的简单通信。我们来看下参数 4 的类型声明：

```javascript
// 在外部使用 registerApplication 的时候可以定义参数 4 customProps 的接口类型
// 这里使用了 ExtraProps 这个泛型来传递外部声明的接口
export function registerApplication<ExtraProps extends CustomProps = {}>(
  // 参数 2 也会涉及到 customProps，因此这里需要传递泛型 ExtraProps
  applicationOrLoadingFn: Application<ExtraProps>,
  // 可以是对象，也可以是一个函数
  customProps?: ExtraProps | CustomPropsFn<ExtraProps>
): void;

// 如果 customProps 是函数，那么必须返回外部声明的接口类型 ExtraProps
type CustomPropsFn<ExtraProps extends CustomProps = CustomProps> = (
  name: string,
  location: Location
) => ExtraProps;

type Application<ExtraProps = {}> =
  // 可以发现在参数 2 中需要返回的生命周期对象里传入了 customProps 对应的泛型 ExtraProps
  | LifeCycles<ExtraProps>
  | ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>);

// 这里继续传递  customProps 对应的泛型 ExtraProps
export type LifeCycles<ExtraProps = {}> = {
  bootstrap: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;
};

type LifeCycleFn<ExtraProps> = (
  // 从这里可以发现每一个生命周期函数都可以获取 customProps 的数据
  // customProps 会和 single-spa 内置的其他数据一起传递给生命周期函数
  config: ExtraProps & AppProps
) => Promise<any>;
```

> 温馨提示：在上述 TypeScript 声明中 `ExtraProps` 是一个[泛型](https://www.tslang.cn/docs/handbook/generics.html)，如果你对泛型不了解，可以先查阅官网文档。

可能上面这个声明看起来有点复杂，我们可以看下如何使用：

```typescript
// 以下采用 typescript 语法
import { registerApplication, AppProps } from "single-spa";

interface ICustomProps {
  hello: string;
}

// 使用 ICustomProps 代替通用类型（泛型）ExtraProps
registerApplication<ICustomProps>({
  name: "vue",
  app: { 
    // 在生命周期函数中可以通过 props 参数获取 customProps 的数据
    // props 参数会包含 hello 属性
    async bootstrap(props: ICustomProps & AppProps) {
      console.log(props.hello); // 111
      console.log("app bootstraped");
    },
    async mount(props) {
      console.log("app mounted");
    },
    async unmount(props) {
      console.log("app unmounted");
    }
  },
  activeWhen: "/vue",
  
  // customProps 必须符合 ICustomProps 的接口声明
  customProps: {
    hello: "111", // ICustomProps 声明中有一个字符串类型的 hello 属性
  },
});
```

### `registerApplication` 解析

主应用在初始化时需要通过 `registerApplication` 注册微应用，它的源码如下所示：

```javascript
// src/applications/apps.js
/**
 * @
 * @description 注册微应用
 * @export
 * @param appNameOrConfig 应用名称或者应用配置对象
 * @param appOrLoadApp  应用对象或者加载应用的函数，返回值是一个 Promise
 * @param activeWhen  一个函数或者字符串，用于判断应用是否激活
 * @param customProps 一个对象，用于传递自定义属性
 */
export function registerApplication(
  appNameOrConfig,
  appOrLoadApp,
  activeWhen,
  customProps
) {
  console.log(
    "[applications/apps.js - registerApplication] registerApplication 函数开始执行， app: ",
    appNameOrConfig
  );

  // 对注册应用的参数进行格式化
  const registration = sanitizeArguments(
    appNameOrConfig,
    appOrLoadApp,
    activeWhen,
    customProps
  );

  // 如果已经注册了同名的应用，那么抛出异常
  if (getAppNames().indexOf(registration.name) !== -1)
    throw Error(
      formatErrorMessage(
        21,
        __DEV__ &&
          `There is already an app registered with name ${registration.name}`,
        registration.name
      )
    );

  // 将注册应用缓存到 apps 数组中
  apps.push(
    // Object.assign() 的兼容性处理
    assign(
      {
        // 加载错误的时间
        loadErrorTime: null,
        // 应用的初始状态
        status: NOT_LOADED,
        parcels: {},
        devtools: {
          overlays: {
            options: {},
            selectors: [],
          },
        },
      },
      // 格式化后的注册应用参数
      registration
    )
  );

  if (isInBrowser) {
    // 支持 jQuery 的路由事件监听
    ensureJQuerySupport();
    console.log(
      "[applications/apps.js - registerApplication] 在 registerApplication 中准备执行 reroute 函数..."
    );
    reroute();
  }
}
```

### `sanitizeArguments` 解析

该函数主要对 `registerApplication` 的四个入参进行格式化，从而为微应用的加载、路由匹配以及参数传递进行前置准备，如下所示：

``` javascript
// src/applications/apps.js

/**
 * @description 对注册应用的参数进行格式化
 * @param appNameOrConfig 应用名称或者应用配置对象
 * @param appOrLoadApp 应用对象或者加载应用的函数，返回值是一个 Promise
 * @param activeWhen 一个函数或者字符串，用于判断应用是否激活
 * @param customProps 一个对象，用于传递自定义属性
 * @returns {Object} 返回格式化后的注册应用参数，例如 { name: 'app1', app: loadApp, activeWhen, customProps }
 */
function sanitizeArguments(
  appNameOrConfig,
  appOrLoadApp,
  activeWhen,
  customProps
) {
  // registerApplication 的参数可以是两种形式：
  // 1. 函数 API: single-spa.registerApplication(name, loadApp, activeWhen, customProps);
  // 2. 对象 API: single-spa.registerApplication({ name: 'app1', app: loadApp, activeWhen, customProps });

  // 如果 appNameOrConfig 是一个对象，表示使用对象 API
  const usingObjectAPI = typeof appNameOrConfig === "object";

  const registration = {
    name: null,
    loadApp: null,
    activeWhen: null,
    customProps: null,
  };

  // 如果使用对象 API，那么 appNameOrConfig 就是一个对象
  if (usingObjectAPI) {
    // 对 registerApplication 的首个参数进行格式校验（其余三个参数不需要校验）
    // 1. name 必须是字符串
    // 2. app 必须是对象或者函数
    // 3. activeWhen 必须是函数或者字符串
    // 4. customProps 必须是对象
    validateRegisterWithConfig(appNameOrConfig);
    registration.name = appNameOrConfig.name;
    registration.loadApp = appNameOrConfig.app;
    registration.activeWhen = appNameOrConfig.activeWhen;
    registration.customProps = appNameOrConfig.customProps;

    // 如果使用函数 API，那么 appNameOrConfig 是一个字符串
  } else {
    // 对 registerApplication 的四个参数进行格式校验
    validateRegisterWithArguments(
      appNameOrConfig,
      appOrLoadApp,
      activeWhen,
      customProps
    );
    registration.name = appNameOrConfig;
    registration.loadApp = appOrLoadApp;
    registration.activeWhen = activeWhen;
    registration.customProps = customProps;
  }

  // 对注册应用的 loadApp 参数进行格式化，统一成返回 Promise 的函数
  registration.loadApp = sanitizeLoadApp(registration.loadApp);
  // 对注册应用的 customProps 参数进行格式化，如果没有传递，则默认为空对象
  registration.customProps = sanitizeCustomProps(registration.customProps);
  // 对注册应用的 activeWhen 参数进行格式化，统一成路由匹配函数
  registration.activeWhen = sanitizeActiveWhen(registration.activeWhen);

  return registration;
}

/**
 * @description 对注册应用的 loadApp 参数进行格式化，统一为一个返回 Promise 的函数
 * @param loadApp 应用对象或者加载应用的函数，返回值是一个 Promise
 * @returns {Function} 返回一个返回 Promise 的函数
 */
function sanitizeLoadApp(loadApp) {
  // 如果 loadApp 是一个对象，转化成返回 Promise 的函数
  // 例如：{ bootstrap, mount, unmount } 
  // --> () => Promise.resolve({ bootstrap, mount, unmount })
  if (typeof loadApp !== "function") {
    return () => Promise.resolve(loadApp);
  }

  // 如果 loadApp 是一个函数，直接返回 loadApp
  return loadApp;
}

/**
 * @description 对注册应用的 customProps 参数进行格式化，如果没有传递，则默认为空对象
 * @param customProps 一个对象，用于传递自定义属性
 * @returns {Object} 返回格式化后的 customProps 参数
 */
function sanitizeCustomProps(customProps) {
  return customProps ? customProps : {};
}

/**
 * @description 对注册应用的 activeWhen 参数进行格式化，统一为路由匹配函数
 * @param activeWhen 一个函数或者字符串，用于判断应用是否激活
 * @returns {Function} 返回匹配路由的函数
 */
function sanitizeActiveWhen(activeWhen) {
  // 如果 activeWhen 不是数组，转化成数组
  let activeWhenArray = Array.isArray(activeWhen) ? activeWhen : [activeWhen];
  // 对 activeWhen 数组中的每一项进行格式化，统一为函数
  activeWhenArray = activeWhenArray.map((activeWhenOrPath) =>
    typeof activeWhenOrPath === "function"
      ? activeWhenOrPath
      : // 如果 activeWhenOrPath 是字符串，转化成函数
        pathToActiveWhen(activeWhenOrPath)
  );

  return (location) =>
    // 判断当前路由是否匹配 activeWhenArray 数组中的任意一项
    activeWhenArray.some((activeWhen) => activeWhen(location));
}

/**
 * @description 对 path 进行格式化，统一为一个匹配路由的函数
 * @export
 * @param path 一个字符串，用于匹配路由
 * @param exactMatch 一个布尔值，用于判断是否精确匹配
 * @returns {Function} 返回匹配路由的函数
 */
export function pathToActiveWhen(path, exactMatch) {
  // 根据 path 和 exactMatch 参数，动态组装需要匹配路由的正则表达式
  const regex = toDynamicPathValidatorRegex(path, exactMatch);

  return (location) => {
    // compatible with IE10
    let origin = location.origin;
    if (!origin) {
      origin = `${location.protocol}//${location.host}`;
    }
    // 判断当前路由是否匹配 path
    // 1. location.href: http://localhost:8080/react/path/to/something?name=123#/home
    // 2. location.origin: http://localhost:8080
    // 3. location.search: ?name=123
    // 4. location.hash: #/home
    // 5. route: /react/path/to/something
    const route = location.href
      .replace(origin, "")
      .replace(location.search, "")
      .split("?")[0];
    return regex.test(route);
  };
}

/**
 * @description 根据 path 和 exactMatch 参数，动态组装需要匹配路由的正则表达式
 *
 * @example
 * toDynamicPathValidatorRegex("/react") => /^\/react(\/.*)?(#.*)?$/i
 *
 * 正则：
 * /^\/react(\/.*)?(#.*)?$/i
 *
 * 详细说明：
 * 1. ^：匹配输入的开始
 * 2. \/react：匹配字符串 /react
 * 3. (\/.*)?：匹配零次或一次以 / 开头的任意字符串
 * 4. (#.*)?：匹配零次或一次以 # 开头的任意字符串，例如 hash 路由
 * 5. $：匹配输入的结束
 * 6. i：不区分大小写
 *
 * 匹配示例：
 * 1. /react
 * 2. /react/path/to/something
 * 3. /react#hash
 * 4. /react/path/to/something#hash
 *
 * @example
 * toDynamicPathValidatorRegex("/react/:id") => /^\/react\/[^/]+\/?/i
 *
 * 正则：
 * /^\/react\/[^/]+\/?/i
 *
 * 详细说明：
 * 1. ^：匹配输入的开始
 * 2. \/react\/：匹配字符串 /react/
 * 3. [^/]+：匹配一次或多次不包含 / 的任意字符，可以匹配 /react/ 后面的一段路径
 * 4. \/?：匹配零次或一次 /，可以匹配路径的结束 / 或者没有结束 /
 * 5. i：不区分大小写
 *
 * 匹配示例：
 * 1. /react/123
 * 2. /react/123/
 * 3. /react/123/path/to/something
 * 4. /react/123/path/to/something/
 * 5. /react/123#hash
 * 6. /react/123#hash/
 *
 * @param path 一个字符串，用于匹配路由
 * @param exactMatch 一个布尔值，用于判断是否精确匹配
 * @returns {RegExp} 返回匹配路由的正则表达式
 */

function toDynamicPathValidatorRegex(path, exactMatch) {
  let lastIndex = 0,
    inDynamic = false,
    regexStr = "^";

  if (path[0] !== "/") {
    path = "/" + path;
  }

  // 遍历 path，判断 path 中是否包含动态路由
  for (let charIndex = 0; charIndex < path.length; charIndex++) {
    const char = path[charIndex];
    const startOfDynamic = !inDynamic && char === ":";
    const endOfDynamic = inDynamic && char === "/";
    if (startOfDynamic || endOfDynamic) {
      // 如果 path 中包含动态路由，那么 inDynamic 为 true
      appendToRegex(charIndex);
    }
  }

  appendToRegex(path.length);
  return new RegExp(regexStr, "i");

  function appendToRegex(index) {
    const anyCharMaybeTrailingSlashRegex = "[^/]+/?";
    // escapeStrRegex 函数用于转义字符串中的特殊字符
    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));

    regexStr += inDynamic
      ? anyCharMaybeTrailingSlashRegex
      : commonStringSubPath;

    if (index === path.length) {
      if (inDynamic) {
        if (exactMatch) {
          // Ensure exact match paths that end in a dynamic portion don't match
          // urls with characters after a slash after the dynamic portion.
          regexStr += "$";
        }
      } else {
        // For exact matches, expect no more characters. Otherwise, allow
        // any characters.
        const suffix = exactMatch ? "" : ".*";

        regexStr =
          // use charAt instead as we could not use es6 method endsWith
          regexStr.charAt(regexStr.length - 1) === "/"
            ? `${regexStr}${suffix}$`
            : `${regexStr}(/${suffix})?(#.*)?$`;
      }
    }

    inDynamic = !inDynamic;
    lastIndex = index;
  }

  function escapeStrRegex(str) {
    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js
    return str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
}
```

## `start` 解析

在主应用中通过 `registerApplication` 函数注册完所有的微应用后，会调用 `start` 函数启动，启动后微应用的生命周期函数才会被 single-spa 执行，而在启动之前只能对微应用进行加载和解析生命周期函数处理。`start` 函数执行后会标记 single-spa 的启动标识 `started`，后续`reroute` 函数可使用该标识判断是否要执行微应用的生命周期函数，如下所示：

``` javascript
let started = false;

/**
 * @description 启动 single-spa 应用
 * @export
 * @param opts
 */
export function start(opts) {
  console.log("[start.js]: start 函数开始执行...");
  // 标记 single-spa 已经启动
  started = true;

  // 如果 opts.urlRerouteOnly 为 true，执行 setUrlRerouteOnly 函数
  // urlRerouteOnly 在后续的监听路由变化中讲解
  if (opts && opts.urlRerouteOnly) {
    setUrlRerouteOnly(opts.urlRerouteOnly);
  }
  // 如果是在浏览器环境中，执行 reroute 函数
  if (isInBrowser) {
    console.log("[start.js]: 在 start 中准备执行 reroute 函数...");
    reroute();
  }
}

// 判断 single-spa 是否已经启动
export function isStarted() {
  return started;
}

if (isInBrowser) { 
  // 一般注册完所有的微应用后就需要立马调用 start 函数启动 single-spa
  // 如果没有调用 start 函数则给出警告提示
  setTimeout(() => {
    if (!started) {
      console.warn(
        formatErrorMessage(
          1,
          __DEV__ &&
            `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted.`
        )
      );
    }
  }, 5000);
}
```


## `navigation` 解析

### `reroute` 解析

`registerApplication` 和 `start` 都会调用 `reroute` 函数，该函数主要是在微应用需要发生变化时触发，它会通过 `getAppChanges` 判断需要变化的微应用列表，然后根据外部是否调用了 `start` 函数来判断执行微应用的批量加载 `loadApps` 还是执行所有微应用的变化 `performAppChanges`：

``` javascript
// src/navigation/reroute.js

/**
 * @description 重新路由
 * 触发的时机：
 * 1. 当浏览器的 url 发生变化
 * 2. 当调用 start() 方法后
 * 3. 当调用 registerApplication() 方法后
 * 4. 当调用 navigateToUrl() 方法后
 * 5. 当调用 triggerAppChange() 方法后
 * 6. 当调用 unloadApplication() 方法后
 * 7. 当调用 loadApplication() 方法后
 * 8. 当调用 mountRootParcel() 方法后
 * 9. 当调用 unmountRootParcel() 方法后
 *
 * 总结：
 * retoute 主要是在微应用需要发生变化时触发，
 * 比如新增、删除、更新、加载、彻底卸载（unload）、卸载、挂载应用等。
 *
 * @export
 * @param [pendingPromises=[]] 等待应用变化的 Promise 数组
 * @param eventArguments 事件参数
 * @returns {*}
 */
export function reroute(pendingPromises = [], eventArguments) {
  // eslint-disable-next-line no-console
  console.log("[navigation/reroute.js - reroute]: reroute 函数开始执行...");

  // 如果当前正在执行 performAppChanges 处理应用变化，
  // 则将 eventArguments 存储到 peopleWaitingOnAppChange 数组中
  
  // 如果 performAppChanges 函数还未执行完毕，
  // 但是再次调用了 reroute 函数，
  // 那么会等待 performAppChanges 函数执行完毕
  
  // 在 performAppChanges 函数执行完毕后，
  // 会调用 finishUpAndReturn 函数，
  // 如果 peopleWaitingOnAppChange 数组中有数据，
  // 则会再次执行 reroute 函数
  // 因此这里主要用于延迟执行 reroute 函数
  if (appChangeUnderway) {
    return new Promise((resolve, reject) => {
      // 将 resolve、reject、eventArguments 存储到 peopleWaitingOnAppChange 数组中
      
      // 当 performAppChanges 函数执行完毕后，
      // 会调用 finishUpAndReturn 函数，
      // 如果 peopleWaitingOnAppChange 数组中有数据，
      // 则会再次执行 reroute 函数
      peopleWaitingOnAppChange.push({
        resolve,
        reject,
        eventArguments,
      });
    });
  }

  // 获取当前应用的变化情况
  // 1. appsToUnload: 需要彻底卸载的应用
  // 2. appsToUnmount: 需要卸载的应用
  // 3. appsToLoad: 需要加载的应用
  // 4. appsToMount: 需要挂载的应用
  const { appsToUnload, appsToUnmount, appsToLoad, appsToMount } =
    getAppChanges();
  let appsThatChanged,
    navigationIsCanceled = false,
    oldUrl = currentUrl,
    newUrl = (currentUrl = window.location.href);

  // 如果已经调用了 start 函数启动
  if (isStarted()) {
    // 设置当前应用变化正在进行中，避免多次同时触发应用变化
    appChangeUnderway = true;
    appsThatChanged = appsToUnload.concat(
      appsToLoad,
      appsToUnmount,
      appsToMount
    );
    console.log(
      "[navigation/reroute.js - reroute]: appsToUnload 数据: ",
      appsToUnload
    );
    console.log(
      "[navigation/reroute.js - reroute]: appsToUnmount 数据: ",
      appsToUnmount
    );
    console.log(
      "[navigation/reroute.js - reroute]: appsToLoad 数据: ",
      appsToLoad
    );
    console.log(
      "[navigation/reroute.js - reroute]: appsToMount 数据: ",
      appsToMount
    );
    console.log(
      "[navigation/reroute.js - reroute]: 准备执行 performAppChanges..."
    );
    return performAppChanges();
    // 如果还没有启动
    // 调用 singleSpa.registerApplication() 方法后，
    // 还没有调用 singleSpa.start() 方法之前会走到这里
  } else {
    appsThatChanged = appsToLoad;
    console.log("[navigation/reroute.js - reroute]: 准备执行 loadApps...");
    return loadApps();
  }
  
  
  /**
   * @description 如果外部监听
   * single-spa:before-routing-event 事件
   * 并调用了 cancelNavigation 方法，则取消导航
   */
  function cancelNavigation() {
    navigationIsCanceled = true;
  }
  
  /**
   * @description 加载应用
   * @returns
   */
  function loadApps() {
    // ...
  }
  
  /**
   * @description 执行应用变化
   * @returns {*}
   */
  function performAppChanges() {
    // ...
  }
  
  /**
   * @description performAppChanges 函数执行完毕后，
   * 执行 finishUpAndReturn 函数
   * @returns {*}
   */
  function finishUpAndReturn() {
    // ...
  }
  
  /* We need to call all event listeners that have been delayed because they were
   * waiting on single-spa. This includes haschange and popstate events for both
   * the current run of performAppChanges(), but also all of the queued event listeners.
   * We want to call the listeners in the same order as if they had not been delayed by
   * single-spa, which means queued ones first and then the most recent one.
   */
  function callAllEventListeners() {
     // ...
  }
  
  /**
   * @description 获取自定义事件详情信息
   * @param isBeforeChanges 是否在应用变化之前
   * @param extraProperties 额外的属性，例如 { cancelNavigation }
   * @returns {Object} 自定义事件详情信息
   */
  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {
    // ...
  }
}
```

#### `getAppChanges` 解析

`reoute` 函数会先执行 `getAppChanges` 计算需要变化的微应用列表，如下所示：

``` javascript
// src/applications/apps.js

/**
 * @description 计算应用的变更情况
 * @export
 * @returns {Object} 返回变更的应用，
 * 例如 { appsToUnload, appsToUnmount, appsToLoad, appsToMount }
 */
export function getAppChanges() {
  const appsToUnload = [],
    appsToUnmount = [],
    appsToLoad = [],
    appsToMount = [];

  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds
  const currentTime = new Date().getTime();

  apps.forEach((app) => {
    // 判断应用是否应该激活
    // 1. 如果应用的状态是 SKIP_BECAUSE_BROKEN，那么不需要激活
    // 2. 通过 shouldBeActive 函数判断应用是否应该激活
    const appShouldBeActive =
      app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);

    // 状态机（即将进行状态转换），对应用进行分类
    switch (app.status) {
      // 应用之前的状态是 LOAD_ERROR
      case LOAD_ERROR:
        // 判断应用是否要加载：如果应用之前加载失败，此时被激活，
        // 并且加载失败的时间超过 200 毫秒，那么即将重新加载应用
        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {
          appsToLoad.push(app);
        }
        break;

      // 应用之前的状态是 NOT_LOADED 或者 LOADING_SOURCE_CODE
      // 1. 注册应用后，应用的初始状态是 NOT_LOADED
      case NOT_LOADED:
      case LOADING_SOURCE_CODE:
        // 判断应用是否要加载：如果应用被激活，那么即将加载应用
        if (appShouldBeActive) {
          appsToLoad.push(app);
        }
        break;
      // 应用之前的状态是 NOT_BOOTSTRAPPED 或者 NOT_MOUNTED
      case NOT_BOOTSTRAPPED:
      case NOT_MOUNTED:
        // 判断应用是否要彻底卸载
        // 1. 如果应用被激活
        // 2. 如果确实被标记了要彻底卸载，
        // 在 lifecycles/unload.js 中会维护 appsToUnload 对象，
        // 用于标记应用是否要彻底卸载
        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {
          appsToUnload.push(app);
          // 判断应用是否要挂载：如果应用被激活，那么即将挂载应用
        } else if (appShouldBeActive) {
          appsToMount.push(app);
        }
        break;

      // 应用之前的状态是 MOUNTED
      case MOUNTED:
        // 判断应用是否要卸载：如果应用失活，那么即将卸载应用
        if (!appShouldBeActive) {
          appsToUnmount.push(app);
        }
        break;
      // all other statuses are ignored
    }
  });

  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };
}
```

> 温馨提示：这里可以结合后续的**状态和事件剖析**加深对于微应用的状态变更理解。

#### `loadApps` 解析

通过执行 `getAppChanges` 函数可以计算出需要批量加载的 `appsToLoad` 数组，如果主应用初始化时还未执行 `start` 函数启动，那么 `reroute` 会调用 `loadApps` 进行批量加载：

``` javascript
// src/navigation/reroute.js

/**
   * @description 加载应用
   * @returns
   */
  function loadApps() {
    console.log("[navigation/reroute.js - loadApps]: loadApps 开始执行...");
    
    // 开启微任务，异步执行微应用的加载函数，
    // 例如等待主应用的 React 路由执行完毕
    return Promise.resolve().then(() => {
      console.log(
        "[navigation/reroute.js - loadApps]: loadApps 的 Promise.resolve 开始执行..."
      );

      // 批量执行 appsToLoad 数组中的 app.loadApp 方法（registerApplication 的第二个参数 app）
      const loadPromises = appsToLoad.map(toLoadPromise);

      return (
        Promise.all(loadPromises)
          .then(callAllEventListeners)
          .then(() => {
            console.log(
              "[navigation/reroute.js - loadApps]: 所有子应用的 app.loadApp 方法（registerApplication 的第二个参数 app）执行完毕。"
            );
          })
          // there are no mounted apps, before start() is called, so we always return []
          .then(() => [])
          .catch((err) => {
            callAllEventListeners();
            throw err;
          })
      );
    });
  }
```

> 温馨提示：这里暂时先忽略 `toLoadPromise`，会在后续统一讲解。

#### `performAppChanges` 解析

通过执行 `getAppChanges` 函数可以计算出需要批量处理的 `appsToUnload、appsToUnmount、appsToLoad、appsToMount` 等数组，如果主应用初始化时已经执行 `start` 函数启动，那么 `reroute` 会调用 `performAppChanges` 对所有微应用的 `unload`、`unmount`、`loadApp`、`bootstrap` 以及 `mount` 等所有生命周期函数进行批量异步执行：

``` javascript
/**
   * @description 执行应用变化
   * @returns {*}
   */
  function performAppChanges() {
    console.log(
      "[navigation/reroute.js - performAppChanges]: performAppChanges 开始执行..."
    );
    
    // 开启微任务，异步执行应用变化，
    // 例如等待主应用的 React 路由执行完毕
    return Promise.resolve().then(() => {
      console.log(
        "[navigation/reroute.js - performAppChanges]: performAppChanges 的 Promise.resolve 开始执行..."
      );
      // https://github.com/single-spa/single-spa/issues/545
      // 如果没有应用发生变化，则触发 single-spa:before-no-app-change 事件
      // 如果有应用发生变化，则触发 single-spa:before-app-change 事件
      window.dispatchEvent(
        new CustomEvent(
          appsThatChanged.length === 0
            ? "single-spa:before-no-app-change"
            : "single-spa:before-app-change",
          getCustomEventDetail(true)
        )
      );

      console.log(
        "[navigation/reroute.js - performAppChanges]: 触发 window.dispatchEvent 的 single-spa:before-routing-event 事件， event: ",
        getCustomEventDetail(true, { cancelNavigation })
      );

      // 通过监听 single-spa:before-routing-event 事件，
      // 可以取消导航
      window.dispatchEvent(
        new CustomEvent(
          "single-spa:before-routing-event",
          getCustomEventDetail(true, { cancelNavigation })
        )
      );

      // 如果外部监听了 single-spa:before-routing-event 事件，
      // 并且调用了 cancelNavigation 方法，则取消导航
      if (navigationIsCanceled) {
        window.dispatchEvent(
          new CustomEvent(
            "single-spa:before-mount-routing-event",
            getCustomEventDetail(true)
          )
        );
        // 结束 performAppChanges 函数的执行
        finishUpAndReturn();
        // 重新导航到旧的 url
        navigateToUrl(oldUrl);
        return;
      }

      // 批量执行 appsToUnload 数组中的 app.unload 方法
      const unloadPromises = appsToUnload.map(toUnloadPromise);
      console.log(
        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 unloadPromises 数据: ",
        unloadPromises
      );

      // 批量执行 appsToUnmount 数组中的 app.unmount 方法
      const unmountUnloadPromises = appsToUnmount
        .map(toUnmountPromise)
        // unmount 执行完毕后，再执行 unload
        .map((unmountPromise) => unmountPromise.then(toUnloadPromise));

      // 将所有的 toUnmountPromise 和 toUnloadPromise 方法合并到 allUnmountPromises 数组中
      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);
      const unmountAllPromise = Promise.all(allUnmountPromises);

      console.log(
        "[navigation/reroute.js - performAppChanges]: 准备执行所有子应用的 toUnmountPromise 和 toUnloadPromise 方法..."
      );
      // 等待所有的 toUnmountPromise 和 toUnloadPromise 方法执行完毕
      unmountAllPromise.then(() => {
        // 触发 single-spa:before-mount-routing-event 事件
        window.dispatchEvent(
          new CustomEvent(
            "single-spa:before-mount-routing-event",
            getCustomEventDetail(true)
          )
        );
      });

      console.log(
        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 unmountAllPromise 数据: ",
        unmountAllPromise
      );

      /* We load and bootstrap apps while other apps are unmounting, but we
       * wait to mount the app until all apps are finishing unmounting
       */
      // 批量执行 appsToLoad 数组中的 app.loadApp 方法（registerApplication 的第二个参数 app）
      // 这里不会等待 unmountAllPromise 执行完毕，而是直接执行
      const loadThenMountPromises = appsToLoad.map((app) => {
        console.log(
          "[navigation/reroute.js - performAppChanges]: 准备执行子应用的 app.loadApp 方法（registerApplication 的第二个参数 app）...",
          app.name,
          app.status
        );
        // 执行 app.loadApp 方法（registerApplication 的第二个参数 app）
        return toLoadPromise(app).then((app) => {
          console.log(
            "[navigation/reroute.js - performAppChanges]: 子应用的 app.loadApp 方法执行完毕，准备执行子应用的周期函数 bootstrap 和 mount ...",
            app.name,
            app.status
          );
          // load 之后，需要执行 bootstrap 和 mount
          tryToBootstrapAndMount(app, unmountAllPromise);
        });
      });

      console.log(
        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的  loadThenMountPromises 数据: ",
        loadThenMountPromises
      );

      /* These are the apps that are already bootstrapped and just need
       * to be mounted. They each wait for all unmounting apps to finish up
       * before they mount.
       */
      // 批量执行 appsToMount 数组中的 app.bootstrap 和 app.mount 方法
      const mountPromises = appsToMount
        // 过滤掉 appsToLoad 数组中的 app
        .filter((appToMount) => appsToLoad.indexOf(appToMount) < 0)
        .map((appToMount) => {
          console.log(
            "[navigation/reroute.js - performAppChanges]: appsToMount 准备执行子应用的周期函数 bootstrap 和 mount ..."
          );
          // 执行 app.bootstrap 和 app.mount 方法
          return tryToBootstrapAndMount(appToMount, unmountAllPromise);
        });

      console.log(
        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 mountPromises 数据: ",
        mountPromises
      );

      return unmountAllPromise
        .catch((err) => {
          callAllEventListeners();
          throw err;
        })
        .then(() => {
          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation
           * events (like hashchange or popstate) should have been cleaned up. So it's safe
           * to let the remaining captured event listeners to handle about the DOM event.
           */
          callAllEventListeners();

          return Promise.all(loadThenMountPromises.concat(mountPromises))
            .catch((err) => {
              pendingPromises.forEach((promise) => promise.reject(err));
              throw err;
            })
            .then(finishUpAndReturn);
        });
    });
  }
```

> 温馨提示：这里暂时先忽略 `toLoadPromise`、`toUnloadPromise` 等微应用的生命周期函数异步执行处理，会在后续统一讲解。

#### `getCustomEventDetail` 解析

通过 single-spa 调用 `window.dispatchEvent` 发送事件时会携带各个微应用需要变更的状态信息，此时需要通过 `getCustomEventDetail` 函数进行计算，如下所示：

``` javascript
 /**
   * @description 获取自定义事件详情信息
   * @param isBeforeChanges 是否在应用变化之前
   * @param extraProperties 额外的属性，例如 { cancelNavigation }
   * @returns {Object} 自定义事件详情信息
   */
  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {
    const newAppStatuses = {};
    const appsByNewStatus = {
      // for apps that were mounted
      [MOUNTED]: [],
      // for apps that were unmounted
      [NOT_MOUNTED]: [],
      // apps that were forcibly unloaded
      [NOT_LOADED]: [],
      // apps that attempted to do something but are broken now
      [SKIP_BECAUSE_BROKEN]: [],
    };

    // 如果在应用变化之前，则获取应用的状态
    if (isBeforeChanges) {
      appsToLoad.concat(appsToMount).forEach((app, index) => {
        addApp(app, MOUNTED);
      });
      appsToUnload.forEach((app) => {
        addApp(app, NOT_LOADED);
      });
      appsToUnmount.forEach((app) => {
        addApp(app, NOT_MOUNTED);
      });
    } else {
      appsThatChanged.forEach((app) => {
        addApp(app);
      });
    }

    // 发送事件时包装的详细信息
    const result = {
      detail: {
        newAppStatuses,
        appsByNewStatus,
        totalAppChanges: appsThatChanged.length,
        originalEvent: eventArguments?.[0],
        oldUrl,
        newUrl,
        navigationIsCanceled,
      },
    };

    // 如果有额外的属性，则添加到 result.detail 对象中
    if (extraProperties) {
      assign(result.detail, extraProperties);
    }

    return result;

    /**
     * @description 添加应用
     * @param app 应用
     * @param status 状态
     */
    function addApp(app, status) {
      // 获取应用的名称
      const appName = toName(app);
      // 获取应用的状态
      status = status || getAppStatus(appName);
      // 将应用的状态添加到 newAppStatuses 对象中
      newAppStatuses[appName] = status;
      // 将应用的名称添加到 appsByNewStatus 对象中
      // 例如：appsByNewStatus = { MOUNTED: ['app1', 'app2'], NOT_MOUNTED: ['app3', 'app4'] }
      const statusArr = (appsByNewStatus[status] =
        appsByNewStatus[status] || []);
      statusArr.push(appName);
    }
  }
```

#### `callAllEventListeners` 解析

在 `loadApps` 中批量异步加载微应用后会执行 `callAllEventListeners` 延迟触发微应用因未加载代码执行而错过的 `hashchange` 和 `popstate` 导航事件。同理在 `performAppChanges` 中也会等待所有微应用的 `unmount` 和 `unload` 执行完毕后再延迟触发执行导航事件，一旦微应用在卸载时移除了相应的监听器，延迟执行则能够确保这些事件不会被监听执行：

``` javascript
 /* We need to call all event listeners that have been delayed because they were
   * waiting on single-spa. This includes haschange and popstate events for both
   * the current run of performAppChanges(), but also all of the queued event listeners.
   * We want to call the listeners in the same order as if they had not been delayed by
   * single-spa, which means queued ones first and then the most recent one.
   */
   
  // 延迟执行 hashchange 和 popstate 事件的监听器
  // 1.在微应用激活时触发了 `popstate` 事件，
  // 但是此时微应用的代码还没有加载完成，
  // 这会使得微应用错过事件监听，
  // 因此在 loadApps 执行完毕后会执行 callAllEventListeners。
  
  // 2.如果微应用失活时正好触发了 `popstate` 事件，
  // 微应用可能希望在卸载时移除监听 `hashchange` 和 `popstate` 事件，
  // 此时 single-spa 可以将事件延迟到微应用卸载后执行，
  // 这样微应用在卸载后因为移除了相应的监听事件并不会触发事件的监听执行，
  // 所以 performAppChanges 会在所有微应用 `unmount` 和 `unload` 后
  // 才延迟执行 callAllEventListeners。
  function callAllEventListeners() {
    console.log(
      "[navigation/reroute.js - callAllEventListeners]: callAllEventListeners 中的 pendingPromises 数据： ",
      pendingPromises
    );
    pendingPromises.forEach((pendingPromise) => {
      callCapturedEventListeners(pendingPromise.eventArguments);
    });

    callCapturedEventListeners(eventArguments);
  }
```

> 温馨提示：关于 `callCapturedEventListeners` 可以查看后续的 `navigation-events` 解析。

#### `finishUpAndReturn` 解析

`finishUpAndReturn` 函数会在用户调用 `cancelNavigation` 取消导航和 `performAppChanges` 中所有微应用的 `load` 和 `mount` 生命周期函数执行完毕后触发，它主要用于触发 single-spa 的内置事件、清除 `performAppChanges` 正在执行的标志位以及执行被延迟的 `reroute` 函数：


``` javascript
function finishUpAndReturn() {
    console.log(
      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 开始执行..."
    );

    const returnValue = getMountedApps();
    console.log(
      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 中的 returnValue 数据: ",
      returnValue
    );
    pendingPromises.forEach((promise) => promise.resolve(returnValue));
    console.log(
      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 中的 pendingPromises 数据: ",
      pendingPromises
    );

    try {
      const appChangeEventName =
        appsThatChanged.length === 0
          ? "single-spa:no-app-change"
          : "single-spa:app-change";
      window.dispatchEvent(
        new CustomEvent(appChangeEventName, getCustomEventDetail())
      );
      window.dispatchEvent(
        new CustomEvent("single-spa:routing-event", getCustomEventDetail())
      );
    } catch (err) {
      /* We use a setTimeout because if someone else's event handler throws an error, single-spa
       * needs to carry on. If a listener to the event throws an error, it's their own fault, not
       * single-spa's.
       */
      setTimeout(() => {
        throw err;
      });
    }

    /* Setting this allows for subsequent calls to reroute() to actually perform
     * a reroute instead of just getting queued behind the current reroute call.
     * We want to do this after the mounting/unmounting is done but before we
     * resolve the promise for the `reroute` function.
     */
    // 设置 appChangeUnderway 为 false，表示应用变化已经结束
    appChangeUnderway = false;
    
    // 在 performAppChanges 函数异步执行期间，
    // 如果调用了 reroute 函数，
    // 那么会将 eventArguments 存储到 peopleWaitingOnAppChange 数组中
    // 等待 performAppChanges 函数执行完毕后延迟执行 reroute 函数
    if (peopleWaitingOnAppChange.length > 0) {
      /* While we were rerouting, someone else triggered another reroute that got queued.
       * So we need reroute again.
       */
      const nextPendingPromises = peopleWaitingOnAppChange;
      peopleWaitingOnAppChange = [];
      console.log(
        "[navigation/reroute.js - finishUpAndReturn]: 在 finishUpAndReturn 中准备执行 reroute 函数..."
      );
      reroute(nextPendingPromises);
    }

    return returnValue;
  }
```

### `navigation-events` 解析

除了页面初始化加载时需要通过 `start` 函数调用 `reroute` 实时激活和加载微应用，在页面路由发生变化时也需要调用 `reroute` 变化微应用，因此 single-spa 需要监听导航事件的变化以及框架的路由变化：

``` javascript
import { reroute } from "./reroute.js";
import { find } from "../utils/find.js";
import { formatErrorMessage } from "../applications/app-errors.js";
import { isInBrowser } from "../utils/runtime-environment.js";
import { isStarted } from "../start.js";

/* We capture navigation event listeners so that we can make sure
 * that application navigation listeners are not called until
 * single-spa has ensured that the correct applications are
 * unmounted and mounted.
 */
// 在 single-spa 中会捕获导航事件监听器，进行延迟执行
// 例如微应用 A 在 unmount 中移除了 hashchange 事件监听器，
// 在微应用 A  unmount 时触发了 hashchange 事件，
// 为了防止微应用 A 执行 hashchange 事件，
// 需要在 single-spa 中提前捕获 hashchange 事件，
// 等待微应用 A unmount 完成后再延迟执行 hashchange 事件监听器

// capturedEventListeners 用于存储捕获的事件监听器
const capturedEventListeners = {
  hashchange: [],
  popstate: [],
};

export const routingEventsListeningTo = ["hashchange", "popstate"];

export function navigateToUrl(obj) {
  let url;
  if (typeof obj === "string") {
    url = obj;
  } else if (this && this.href) {
    url = this.href;
  } else if (
    obj &&
    obj.currentTarget &&
    obj.currentTarget.href &&
    obj.preventDefault
  ) {
    url = obj.currentTarget.href;
    obj.preventDefault();
  } else {
    throw Error(
      formatErrorMessage(
        14,
        __DEV__ &&
          `singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`
      )
    );
  }

  const current = parseUri(window.location.href);
  const destination = parseUri(url);

  if (url.indexOf("#") === 0) {
    window.location.hash = destination.hash;
  } else if (current.host !== destination.host && destination.host) {
    if (process.env.BABEL_ENV === "test") {
      return { wouldHaveReloadedThePage: true };
    } else {
      window.location.href = url;
    }
  } else if (
    destination.pathname === current.pathname &&
    destination.search === current.search
  ) {
    window.location.hash = destination.hash;
  } else {
    // different path, host, or query params
    window.history.pushState(null, null, url);
  }
}

/**
 * @description 在 single-spa 中延迟执行捕获的事件监听器（批量加载微应用后、批量 unmount 微应用后）
 * @export
 * @param eventArguments 事件参数
 */
export function callCapturedEventListeners(eventArguments) {
  console.log(
    "[navigation/navigation-events.js - callCapturedEventListeners]: callCapturedEventListeners 函数开始执行...",
    eventArguments
  );
  // 如果 eventArguments 存在，
  // 则会执行 capturedEventListeners 中对应事件类型的监听器
  
  // 注意这里的 eventArguments 由 createPopStateEvent 函数创建，
  // 是一个 PopStateEvent 实例
  // 例如触发流程：
  // history.pushState（React 或者 Vue 框架路由变化） 
  // -> patchedUpdateState -> createPopStateEvent 
  // -> window.dispatchEvent 
  // -> window.addEventListener 
  // -> urlReroute -> reroute 
  // -> performAppChanges -> 批量 unmount 执行完毕 
  // -> callCapturedEventListeners
  if (eventArguments) {
    const eventType = eventArguments[0].type;
    if (routingEventsListeningTo.indexOf(eventType) >= 0) {
      // 遍历 capturedEventListeners 中对应事件类型的监听器，执行监听器
      capturedEventListeners[eventType].forEach((listener) => {
        try {
          // The error thrown by application event listener should not break single-spa down.
          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did
          listener.apply(this, eventArguments);
        } catch (e) {
          setTimeout(() => {
            throw e;
          });
        }
      });
    }
  }
}

let urlRerouteOnly;

// 设置 urlRerouteOnly 变量，如果为 true，
// 则只有 url 变化时才会执行 reroute 函数

// 在 start 函数中可以传递 opts.urlRerouteOnly 参数触发执行 setUrlRerouteOnly 函数
export function setUrlRerouteOnly(val) {
  urlRerouteOnly = val;
}

// urlReroute 函数，会携带事件参数，
// 携带事件参数的 urlReroute 函数最终会执行 callCapturedEventListeners 函数
function urlReroute() {
  console.log(
    "[navigation/navigation-events.js - urlReroute]: 在 urlReroute 中准备执行 reroute 函数..."
  );
  // 最终会将 arguments 传递给 callCapturedEventListeners 函数
  reroute([], arguments);
}

/**
 * @description 重写 window.history.pushState 和 window.history.replaceState 方法
 * @param updateState window.history.pushState 或 window.history.replaceState
 * @param methodName pushState 或 replaceState
 * @returns {*}
 */
function patchedUpdateState(updateState, methodName) {
  return function () {
    const urlBefore = window.location.href;
    // 执行原生的 pushState 或 replaceState 方法
    // 这里也是为什么 React 框架和 Vue 框架路由变化后，
    // single-spa 能够触发微应用激活和失活的主要原因
    const result = updateState.apply(this, arguments);
    const urlAfter = window.location.href;

    // 如果 urlRerouteOnly 为 true，
    // 则只会判断 url 是否发生变化，
    // 如果发生变化，则执行 reroute 函数
    
    // 如果为 false, 则不管 url 是否发生变化，
    // 都会执行 reroute 函数
    if (!urlRerouteOnly || urlBefore !== urlAfter) {
      if (isStarted()) {
        // fire an artificial popstate event once single-spa is started,
        // so that single-spa applications know about routing that
        // occurs in a different application
        // 在 single-spa 启动之后，
        // 触发人工的 popstate 事件，
        // 以便 single-spa 延迟执行事件监听器
        window.dispatchEvent(
          createPopStateEvent(window.history.state, methodName)
        );
      } else {
        // do not fire an artificial popstate event before single-spa is started,
        // since no single-spa applications need to know about routing events
        // outside of their own router.
        // 在 single-spa 启动之前，
        // 不要触发人工的 popstate 事件，
        // 因为没有启动微前端，
        // 没有微应用需要 unmount 或者 mount，
        // 也就不需要延迟执行事件监听器
        console.log(
          "[navigation/navigation-events.js - patchedUpdateState]: 在 patchedUpdateState 中准备执行 reroute 函数..."
        );
        reroute([]);
      }
    }

    return result;
  };
}

/**
 * @description 创建 popstate 事件
 * @param state
 * @param originalMethodName
 * @returns {*}
 */
function createPopStateEvent(state, originalMethodName) {
  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49
  // We need a popstate event even though the browser doesn't do one by default when you call replaceState, so that
  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and
  // singleSpaTrigger=<pushState|replaceState> on the event instance.
  let evt;
  try {
    // 创建 popstate 事件
    evt = new PopStateEvent("popstate", { state });
  } catch (err) {
    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299
    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd
    evt = document.createEvent("PopStateEvent");
    evt.initPopStateEvent("popstate", false, false, state);
  }
  evt.singleSpa = true;
  evt.singleSpaTrigger = originalMethodName;
  return evt;
}

if (isInBrowser) {
  // We will trigger an app change for any routing events.
  // 监听 hashchange 事件，执行 urlReroute 函数
  window.addEventListener("hashchange", (event) => {
    console.log(
      "[navigation/navigation-events.js - hashchange]: 在 hashchange 中准备执行 urlReroute 函数..."
    );
    urlReroute(event);
  });
  // 监听 popstate 事件，执行 urlReroute 函数
  window.addEventListener("popstate", (event) => {
    console.log(
      "[navigation/navigation-events.js - popstate]: 在 popstate 中准备执行 urlReroute 函数..."
    );
    urlReroute(event);
  });

  // Monkeypatch addEventListener so that we can ensure correct timing
  const originalAddEventListener = window.addEventListener;
  const originalRemoveEventListener = window.removeEventListener;
  // 重写 window.addEventListener 方法，用于捕获 hashchange 和 popstate 事件监听器
  window.addEventListener = function (eventName, fn) {
    if (typeof fn === "function") {
      if (
        // 如果是 hashchange 或者 popstate 事件，
        // 并且 capturedEventListeners 中没有对应事件监听器
        // 则将事件监听器添加到 capturedEventListeners 中
        routingEventsListeningTo.indexOf(eventName) >= 0 &&
        !find(capturedEventListeners[eventName], (listener) => listener === fn)
      ) {
        capturedEventListeners[eventName].push(fn);
        return;
      }
    }

    // 如果不是 hashchange 或者 popstate 事件，
    // 或者 capturedEventListeners 中已经存在对应事件监听器，
    // 则执行原生的 addEventListener 方法
    return originalAddEventListener.apply(this, arguments);
  };

  // 重写 window.removeEventListener 方法，
  // 用于移除 hashchange 和 popstate 事件监听器
  window.removeEventListener = function (eventName, listenerFn) {
    if (typeof listenerFn === "function") {
      if (routingEventsListeningTo.indexOf(eventName) >= 0) {
        capturedEventListeners[eventName] = capturedEventListeners[
          eventName
        ].filter((fn) => fn !== listenerFn);
        return;
      }
    }

    return originalRemoveEventListener.apply(this, arguments);
  };

  // 重写 window.history.pushState 方法，
  // 用于捕获 React 或者 Vue 框架路由变化
  window.history.pushState = patchedUpdateState(
    window.history.pushState,
    "pushState"
  );
  // 重写 window.history.replaceState 方法，
  // 用于捕获 React 或者 Vue 框架路由变化
  window.history.replaceState = patchedUpdateState(
    window.history.replaceState,
    "replaceState"
  );

  if (window.singleSpaNavigate) {
    console.warn(
      formatErrorMessage(
        41,
        __DEV__ &&
          "single-spa has been loaded twice on the page. This can result in unexpected behavior."
      )
    );
  } else {
    /* For convenience in `onclick` attributes, we expose a global function for navigating to
     * whatever an <a> tag's href is.
     */
    window.singleSpaNavigate = navigateToUrl;
  }
}

function parseUri(str) {
  const anchor = document.createElement("a");
  anchor.href = str;
  return anchor;
}
```

## `lifecycles` 解析

### `toLoadPromise` 解析

`toLoadPromise` 本质上不是微应用提供的生命周期函数，而是注册加载 API 时需要提供的激活加载函数，它可以在 single-spa 调用 `start` 函数后加载，也可以在初始化微应用的路由被激活时触发加载：

``` javascript
export function toLoadPromise(app) {
  console.log(
    "[lifecycles/load.js - toLoadPromise]: toLoadPromise 函数开始执行...",
    app.name,
    app.status
  );

  // 开启微任务，异步执行微应用的加载函数
  return Promise.resolve().then(() => {
    console.log(
      "[lifecycles/load.js - toLoadPromise]: toLoadPromise Promise.resolve 开始执行, 开始检测 app.loadPromise 是否已经执行过。",
      app.name,
      app.status
    );

    // 如果 app.loadPromise 存在，
    // 直接返回 app.loadPromise
    // 这里可以确保同一个 app 只会执行一次 loadApp 方法

    // 例如注册微应用时会调用 loadApps 方法，
    // 会执行微应用的 toLoadPromise，
    // 此时会缓存 app.loadPromise
    
    // 而启动 start 函数最终调用 performAppChanges 时还会执行微应用的 toLoadPromise
    // 为了避免重复执行 app.loadPromise 方法，
    // 这里会直接返回 app.loadPromise（Promise 对象）
    if (app.loadPromise) {
      console.log(
        "[lifecycles/load.js - toLoadPromise]: 已经执行过 app.loadPromise，直接返回对应的 Promise 结果。",
        app.name,
        app.status
      );
      return app.loadPromise;
    }

    // 如果 app.status 不是 NOT_LOADED 和 LOAD_ERROR，直接返回 app
    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {
      return app;
    }

    // 将 app.status 设置为 LOADING_SOURCE_CODE
    app.status = LOADING_SOURCE_CODE;

    let appOpts, isUserErr;

    console.log(
      "[lifecycles/load.js - toLoadPromise]: app.loadPromise 开始执行...",
      app.name,
      app.status
    );

    // 使用 app.loadPromise 缓存 app 的加载，
    // 避免在 loadApps 以及 performAppChanges 时重复加载
    return (app.loadPromise = Promise.resolve()
      .then(() => {
        console.log(
          "[lifecycles/load.js - toLoadPromise]: 在 Promise.resolve 中开始执行 app.loadPromise...",
          app.name,
          app.status
        );

        console.log(
          "[lifecycles/load.js - toLoadPromise]: 准备执行 app.loadApp（registerApplication 的第二个参数 app）...",
          app.name,
          app.status
        );
        // 这里的 loadApp 其实就是 registerApplication 的第二个参数
        // 在主应用中使用 window.fetch 获取子应用的资源，
        // 执行后需要返回 Promise，
        // 并且返回的是子应用的生命周期函数对象
        const loadPromise = app.loadApp(getProps(app));
        // 如果 loadPromise 不是 Promise 对象，抛出异常
        if (!smellsLikeAPromise(loadPromise)) {
          // The name of the app will be prepended to this error message inside of the handleAppError function
          // app.loadApp 返回的不是 Promise 对象，抛出异常
          isUserErr = true;
          throw Error(
            formatErrorMessage(
              33,
              __DEV__ &&
                `single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(
                  app
                )}', loadingFunction, activityFunction)`,
              toName(app)
            )
          );
        }

        // 这里的 val 其实就是 loadApp 的 Promise 返回值
        // 也就是 registerApplication 的第二个参数 app 的返回值
        
        // 例如：() => import("react-micro-app")，
        // 返回的是一个 Promise
        
        // 例如：() => Promise.resolve({ bootstrap: async () => {}, mount, unmount })，
        // 返回的是一个 Promise
        
        // 所以 val 就是各个子应用的生命周期函数组成的对象，
        // 例如：{ bootstrap: async () => {}, mount, unmount }
        return loadPromise.then((val) => {
          console.log(
            "[lifecycles/load.js - toLoadPromise]: app.loadApp 执行完成，开始检测子应用的生命周期函数是否符合要求...",
            app.name,
            app.status
          );

          app.loadErrorTime = null;

          appOpts = val;

          let validationErrMessage, validationErrCode;

          if (typeof appOpts !== "object") {
            validationErrCode = 34;
            if (__DEV__) {
              validationErrMessage = `does not export anything`;
            }
          }

          // 判断 appOpts 的 bootstrap、mount、unmount 是否符合要求
          if (
            // ES Modules don't have the Object prototype
            // ES 模块没有 Object 原型
            Object.prototype.hasOwnProperty.call(appOpts, "bootstrap") &&
            !validLifecycleFn(appOpts.bootstrap)
          ) {
            validationErrCode = 35;
            if (__DEV__) {
              validationErrMessage = `does not export a valid bootstrap function or array of functions`;
            }
          }

          if (!validLifecycleFn(appOpts.mount)) {
            validationErrCode = 36;
            if (__DEV__) {
              validationErrMessage = `does not export a mount function or array of functions`;
            }
          }

          if (!validLifecycleFn(appOpts.unmount)) {
            validationErrCode = 37;
            if (__DEV__) {
              validationErrMessage = `does not export a unmount function or array of functions`;
            }
          }

          const type = objectType(appOpts);

          if (validationErrCode) {
            let appOptsStr;
            try {
              appOptsStr = JSON.stringify(appOpts);
            } catch {}
            console.error(
              formatErrorMessage(
                validationErrCode,
                __DEV__ &&
                  `The loading function for single-spa ${type} '${toName(
                    app
                  )}' resolved with the following, which does not have bootstrap, mount, and unmount functions`,
                type,
                toName(app),
                appOptsStr
              ),
              appOpts
            );
            handleAppError(validationErrMessage, app, SKIP_BECAUSE_BROKEN);
            return app;
          }

          if (appOpts.devtools && appOpts.devtools.overlays) {
            app.devtools.overlays = assign(
              {},
              app.devtools.overlays,
              appOpts.devtools.overlays
            );
          }

          // 设置 app 的状态为 NOT_BOOTSTRAPPED
          app.status = NOT_BOOTSTRAPPED;
          // 将 appOpts 中的周期函数扁平化
          app.bootstrap = flattenFnArray(appOpts, "bootstrap");
          app.mount = flattenFnArray(appOpts, "mount");
          app.unmount = flattenFnArray(appOpts, "unmount");
          app.unload = flattenFnArray(appOpts, "unload");
          app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);

          // 删除 app.loadPromise，表明 app.loadPromise 已经执行完成
          // 下一次执行 toLoadPromise 时会重新执行 app.loadPromise
          delete app.loadPromise;

          console.log(
            "[lifecycles/load.js - toLoadPromise]:  app.loadApp 返回的周期函数解析完成，所有周期函数符合要求。",
            app.name,
            app.status
          );

          return app;
        });
      })
      .catch((err) => {
        delete app.loadPromise;

        let newStatus;
        if (isUserErr) {
          // 经常会在微前端中出现这种情况，执行 app.loadApp 时返回的不是 Promise 对象
          // 这里会将 app 的状态设置为 SKIP_BECAUSE_BROKEN
          newStatus = SKIP_BECAUSE_BROKEN;
        } else {
          // 如果 app.loadApp 执行失败，将 app 的状态设置为 LOAD_ERROR
          newStatus = LOAD_ERROR;
          app.loadErrorTime = new Date().getTime();
        }
        handleAppError(err, app, newStatus);

        return app;
      }));
  });
}
```

### `toBootstrapPromise` 解析

``` javascript
export function toBootstrapPromise(appOrParcel, hardFail) {
  console.log(
    "[lifecycles/bootstrap.js - toBootstrapPromise]: toBootstrapPromise 函数开始执行...",
    appOrParcel.name,
    appOrParcel.status
  );
  // 开启微任务，异步执行微应用的加载函数
  return Promise.resolve().then(() => {
    console.log(
      "[lifecycles/bootstrap.js - toBootstrapPromise]: toBootstrapPromise Promise.resolve 开始执行...",
      appOrParcel.name,
      appOrParcel.status
    );

    // 如果 appOrParcel.status 不是 NOT_BOOTSTRAPPED，直接返回 appOrParcel
    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {
      return appOrParcel;
    }

    // 将 appOrParcel.status 设置为 BOOTSTRAPPING
    appOrParcel.status = BOOTSTRAPPING;

    if (!appOrParcel.bootstrap) {
      // Default implementation of bootstrap
      return Promise.resolve().then(successfulBootstrap);
    }

    console.log(
      "[lifecycles/bootstrap.js - toBootstrapPromise]: 准备执行子应用的 bootstrap 周期函数...",
      appOrParcel.name,
      appOrParcel.status
    );
    // 执行子应用的 bootstrap 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）
    return reasonableTime(appOrParcel, "bootstrap")
      .then(successfulBootstrap)
      .catch((err) => {
        if (hardFail) {
          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);
        } else {
          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);
          return appOrParcel;
        }
      });
  });

  function successfulBootstrap() {
    // boostrap 生命周期函数执行成功, 将 appOrParcel.status 设置为 NOT_MOUNTED
    appOrParcel.status = NOT_MOUNTED;
    console.log(
      "[lifecycles/bootstrap.js - toBootstrapPromise]: 子应用的 bootstrap 周期函数执行成功",
      appOrParcel.name,
      appOrParcel.status
    );
    return appOrParcel;
  }
}
```

### `toMountPromise` 解析

``` javascript
export function toMountPromise(appOrParcel, hardFail) {
  console.log(
    "[lifecycles/mount.js - toMountPromise]: toMountPromise 函数开始执行...",
    appOrParcel.name,
    appOrParcel.status
  );

  // 开启微任务，异步执行微应用的加载函数
  return Promise.resolve().then(() => {
    console.log(
      "[lifecycles/mount.js - toMountPromise]: toMountPromise Promise.resolve 开始执行...",
      appOrParcel.name,
      appOrParcel.status
    );

    // 如果 appOrParcel.status 不是 NOT_MOUNTED，
    // 直接返回 appOrParcel
    if (appOrParcel.status !== NOT_MOUNTED) {
      return appOrParcel;
    }

    // 如果是第一次挂载子应用，
    // 触发 single-spa:before-first-mount 事件
    if (!beforeFirstMountFired) {
      window.dispatchEvent(new CustomEvent("single-spa:before-first-mount"));
      beforeFirstMountFired = true;
    }

    console.log(
      "[lifecycles/mount.js - toMountPromise]: 准备执行子应用的 mount 周期函数...",
      appOrParcel.name,
      appOrParcel.status
    );

    // 触发子应用的 mount 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）
    return reasonableTime(appOrParcel, "mount")
      .then(() => {
        // mount 生命周期函数执行成功, 
        // 将 appOrParcel.status 设置为 MOUNTED
        appOrParcel.status = MOUNTED;

        // 如果是第一次挂载子应用，触发 single-spa:first-mount 事件
        if (!firstMountFired) {
          window.dispatchEvent(new CustomEvent("single-spa:first-mount"));
          firstMountFired = true;
        }
        console.log(
          "[lifecycles/mount.js - toMountPromise]: 子应用的 mount 周期函数执行成功",
          appOrParcel.name,
          appOrParcel.status
        );

        return appOrParcel;
      })
      .catch((err) => {
        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN
        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it
        // instead of just doing a no-op.
        appOrParcel.status = MOUNTED;
        return toUnmountPromise(appOrParcel, true).then(
          setSkipBecauseBroken,
          setSkipBecauseBroken
        );

        function setSkipBecauseBroken() {
          if (!hardFail) {
            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);
            return appOrParcel;
          } else {
            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);
          }
        }
      });
  });
}
```

### `toUnmountPromise` 解析

``` javascript
export function toUnmountPromise(appOrParcel, hardFail) {
  console.log(
    "[lifecycles/unmount.js - toUnmountPromise]: 开始执行 toUnmountPromise 函数..."
  );

  // 开启微任务，异步执行微应用的卸载函数
  return Promise.resolve().then(() => {
    console.log(
      "[lifecycles/unmount.js - toUnmountPromise]: toUnmountPromise Promise.resolve 开始执行...",
      appOrParcel.name,
      appOrParcel.status
    );

    // 如果 appOrParcel.status 不是 MOUNTED，直接返回 appOrParcel
    if (appOrParcel.status !== MOUNTED) {
      return appOrParcel;
    }

    // 将 appOrParcel.status 设置为 UNMOUNTING
    appOrParcel.status = UNMOUNTING;

    // 没有涉及到 Parcel 的逻辑，这里暂时不用考虑
    const unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(
      (parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel()
    );

    let parcelError;

    return (
      Promise.all(unmountChildrenParcels)
        // 执行子应用的 unmount 函数
        .then(unmountAppOrParcel, (parcelError) => {
          // There is a parcel unmount error
          return unmountAppOrParcel().then(() => {
            // Unmounting the app/parcel succeeded, but unmounting its children parcels did not
            const parentError = Error(parcelError.message);
            if (hardFail) {
              throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);
            } else {
              handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);
            }
          });
        })
        .then(() => appOrParcel)
    );

    function unmountAppOrParcel() {
      console.log(
        "[lifecycles/unmount.js - toUnmountPromise]: 准备执行子应用的 unmount 周期函数...",
        appOrParcel.name,
        appOrParcel.status
      );

      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.
      // 执行子应用的 unmount 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）
      return reasonableTime(appOrParcel, "unmount")
        .then(() => {
          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount
          if (!parcelError) {
            // 如果子应用的 unmount 函数执行成功，将 appOrParcel.status 设置为 NOT_MOUNTED
            appOrParcel.status = NOT_MOUNTED;
          }

          console.log(
            "[lifecycles/unmount.js - toUnmountPromise]: 子应用的 unmount 周期函数执行成功",
            appOrParcel.name,
            appOrParcel.status
          );
        })
        .catch((err) => {
          if (hardFail) {
            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);
          } else {
            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);
          }
        });
    }
  });
}
```


### `toUnloadPromise` 解析

single-spa 对外提供了 `unloadApplication` 函数，如下所示：

``` javascript
/**
 * @description unload 应用
 * @export
 * @param appName 应用名称
 * @param [opts={ waitForUnmount: false }]
 * @returns {*}
 */
export function unloadApplication(appName, opts = { waitForUnmount: false }) {
  if (typeof appName !== "string") {
    throw Error(
      formatErrorMessage(
        26,
        __DEV__ && `unloadApplication requires a string 'appName'`
      )
    );
  }

  // 查找应用
  const app = find(apps, (App) => toName(App) === appName);
  if (!app) {
    throw Error(
      formatErrorMessage(
        27,
        __DEV__ &&
          `Could not unload application '${appName}' because no such application has been registered`,
        appName
      )
    );
  }

  // 获取应用的 unload 信息
  const appUnloadInfo = getAppUnloadInfo(toName(app));
  // 如果应用应用需要等待 unmount，那么将应用添加到 unload 列表中
  if (opts && opts.waitForUnmount) {
    // We need to wait for unmount before unloading the app
    // 如果当前应用已经在等待 unload，那么直接返回 appUnloadInfo.promise
    if (appUnloadInfo) {
      // Someone else is already waiting for this, too
      return appUnloadInfo.promise;
    } else {
      // We're the first ones wanting the app to be resolved.
      const promise = new Promise((resolve, reject) => {
        // 将应用添加到 unload 列表中
        addAppToUnload(app, () => promise, resolve, reject);
      });
      return promise;
    }
    // 否则，直接 unload 应用
  } else {
    /* We should unmount the app, unload it, and remount it immediately.
     */

    let resultPromise;

    // 如果当前应用已经在等待 unload
    if (appUnloadInfo) {
      // Someone else is already waiting for this app to unload
      resultPromise = appUnloadInfo.promise;
      /// 直接 unload 应用
      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);
    } else {
      // We're the first ones wanting the app to be resolved.
      resultPromise = new Promise((resolve, reject) => {
        // 将应用添加到去加载列表中
        addAppToUnload(app, () => resultPromise, resolve, reject);
        // 直接 unload 应用
        immediatelyUnloadApp(app, resolve, reject);
      });
    }

    return resultPromise;
  }
}

function immediatelyUnloadApp(app, resolve, reject) {
  // 执行微应用的 unmount 生命周期函数
  toUnmountPromise(app)
    // 执行微应用的 unload 生命周期函数
    .then(toUnloadPromise)
    .then(() => {
      resolve();
      setTimeout(() => {
        // reroute, but the unload promise is done
        console.log(
          "[applications/apps.js - immediatelyUnloadApp] 在 immediatelyUnloadApp 中准备执行 reroute 函数..."
        );
        reroute();
      });
    })
    .catch(reject);
}
```

当外部调用上述函数时会将需要 `unload` 的微应用先通过 `addAppToUnload` 添加到 `appsToUnload` 中，然后通过 `immediatelyUnloadApp` 立即执行 `toUnmountPromise`，如下所示：

``` javascript
const appsToUnload = {};

export function toUnloadPromise(app) {
  // 开启微任务，异步执行微应用的去加载函数
  return Promise.resolve().then(() => {
    // 如果外部调用 unloadApplication，
    // 那么 appsToUnload 中会有对应的 app 信息
    const unloadInfo = appsToUnload[toName(app)];
    // 如果不存在 unloadInfo，
    // 说明外部没有调用 unloadApplication 卸载应用，
    // 或者微应用 unloadInfo 发生了变化，直接返回 app
    if (!unloadInfo) {
      /* No one has called unloadApplication for this app,
       */
      return app;
    }

    // 如果 app.status 为 NOT_LOADED，
    // 说明 app 从未加载或者已经被卸载了，
    // 直接清理掉 app 的状态
    if (app.status === NOT_LOADED) {
      /* This app is already unloaded. We just need to clean up
       * anything that still thinks we need to unload the app.
       */
      finishUnloadingApp(app, unloadInfo);
      return app;
    }

    // 如果 app.status 为 UNLOADING，
    // 说明 app 正在卸载中，直接返回 unloadInfo.promise
    if (app.status === UNLOADING) {
      /* Both unloadApplication and reroute want to unload this app.
       * It only needs to be done once, though.
       */
      // 在 unloadApplication 和 reroute 中都会调用 toUnloadPromise，
      // 但是只需要执行一次（防止重复执行），
      // 所以直接返回 unloadInfo.promise
      return unloadInfo.promise.then(() => app);
    }

    // 如果 app.status 不是 NOT_MOUNTED 和 LOAD_ERROR，
    // 则说明 app 没有被 unmount
    
    // 这里需要等待 app unmount 完成后再执行 app unload 操作
    if (app.status !== NOT_MOUNTED && app.status !== LOAD_ERROR) {
      /* The app cannot be unloaded until it is unmounted.
       */
      return app;
    }

    // 如果 app.status 为 LOAD_ERROR，
    // 则说明 app 加载失败，不需要进行 unload 操作
    // 否则需要执行 app unload 操作
    const unloadPromise =
      app.status === LOAD_ERROR
        ? Promise.resolve()
        : // 注意使用 resonableTime 包裹，是为了添加执行的超时逻辑
          reasonableTime(app, "unload");

    // 将 app.status 设置为 UNLOADING，表示 app 正在卸载中
    app.status = UNLOADING;

    return unloadPromise
      .then(() => {
        // 如果 app 的 unload 函数执行成功，
        // 清理 app 的状态，
        // 删除 app 的生命周期函数，重置 app 的状态
        finishUnloadingApp(app, unloadInfo);
        return app;
      })
      .catch((err) => {
        errorUnloadingApp(app, unloadInfo, err);
        return app;
      });
  });
}

/**
 * @description 清理 app 的状态，删除 app 的生命周期函数，重置 app 的状态
 * @param app 应用
 * @param unloadInfo 微应用卸载信息
 */
function finishUnloadingApp(app, unloadInfo) {
  delete appsToUnload[toName(app)];

  // Unloaded apps don't have lifecycles
  // 删除 app 的生命周期函数
  delete app.bootstrap;
  delete app.mount;
  delete app.unmount;
  delete app.unload;

  // 重置 app 的状态为 NOT_LOADED
  app.status = NOT_LOADED;

  /* resolve the promise of whoever called unloadApplication.
   * This should be done after all other cleanup/bookkeeping
   */
  unloadInfo.resolve();
}

function errorUnloadingApp(app, unloadInfo, err) {
  delete appsToUnload[toName(app)];

  // Unloaded apps don't have lifecycles
  delete app.bootstrap;
  delete app.mount;
  delete app.unmount;
  delete app.unload;

  handleAppError(err, app, SKIP_BECAUSE_BROKEN);
  unloadInfo.reject(err);
}

/**
 * @description 将微应用添加到去加载列表中（外部调用 unloadApplication 时会触发）
 * @export
 * @param app 微应用
 * @param promiseGetter 获取微应用去加载 Promise 的函数
 * @param resolve Promise 的 resolve 函数
 * @param reject Promise 的 reject 函数
 */
export function addAppToUnload(app, promiseGetter, resolve, reject) {
  // 将微应用添加到去加载列表 appsToUnload 中
  appsToUnload[toName(app)] = { app, resolve, reject };
  Object.defineProperty(appsToUnload[toName(app)], "promise", {
    get: promiseGetter,
  });
}

/**
 * @description 获取微应用去加载信息
 * @export
 * @param appName 微应用名称
 * @returns {*} 微应用去加载信息
 */
export function getAppUnloadInfo(appName) {
  return appsToUnload[appName];
}
```


### `reasonableTime` 解析

`toLoadPromise`、`toBootstrapPromise` 以及 `toMountPromise` 等最终都会调用 `reasonableTime`，由于外部生命周期函数的执行不可控，single-spa 在 `reasonableTime` 中提供超时执行的计算逻辑，防止外部生命周期函数执行时间过长从而影响框架的稳定性，如下所示：

``` javascript
/**
 * @description 执行微应用的生命周期函数，并且设置超时时间
 * @export
 * @param appOrParcel 微应用信息
 * @param lifecycle 生命周期名称，例如：bootstrap、mount、unmount、unload
 * @returns {*}
 */
export function reasonableTime(appOrParcel, lifecycle) {
  console.log(
    "[applications/timeouts.js - reasonableTime]: 开始执行 reasonableTime 函数...",
    appOrParcel.name,
    appOrParcel.status,
    lifecycle
  );

  // 获取微应用的超时配置
  const timeoutConfig = appOrParcel.timeouts[lifecycle];
  // 获取超时时间
  const warningPeriod = timeoutConfig.warningMillis;
  const type = objectType(appOrParcel);

  // 返回一个 Promise 对象
  return new Promise((resolve, reject) => {
    let finished = false;
    let errored = false;

    console.log(
      `[applications/timeouts.js - reasonableTime]: 开始执行子应用的 ${lifecycle} 函数...`,
      appOrParcel.name,
      appOrParcel.status,
      getProps(appOrParcel)
    );

    // 执行微应用的生命周期函数
    // 在 toLoadPromise 函数中，
    // 已经获取并解析了微应用的生命周期函数，
    // 并且将其缓存到 app 对象中
    // 因此在这里可以执行 appOrParcel[lifecycle]

    // 和在 toLoadPromise 中执行 app.loadApp 函数一样，
    // 生命周期函数的执行也需要传入 props 参数（这是实现主应用和微应用通信的主要方式）
    appOrParcel[lifecycle](getProps(appOrParcel))
      .then((val) => {
        // 如果生命周期函数执行成功，将 finished 设置为 true，并且调用 resolve 函数
        finished = true;
        resolve(val);
      })
      .catch((val) => {
        finished = true;
        reject(val);
      });

    // 超时处理
    setTimeout(() => maybeTimingOut(1), warningPeriod);
    // 超时处理
    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);

    const errMsg = formatErrorMessage(
      31,
      __DEV__ &&
        `Lifecycle function ${lifecycle} for ${type} ${toName(
          appOrParcel
        )} lifecycle did not resolve or reject for ${timeoutConfig.millis} ms.`,
      lifecycle,
      type,
      toName(appOrParcel),
      timeoutConfig.millis
    );

    function maybeTimingOut(shouldError) {
      // 如果 finished 为 true，说明生命周期函数执行成功，不需要处理超时
      if (!finished) {
        if (shouldError === true) {
          errored = true;
          if (timeoutConfig.dieOnTimeout) {
            reject(Error(errMsg));
          } else {
            console.error(errMsg);
            //don't resolve or reject, we're waiting this one out
          }
        } else if (!errored) {
          const numWarnings = shouldError;
          const numMillis = numWarnings * warningPeriod;
          console.warn(errMsg);
          if (numMillis + warningPeriod < timeoutConfig.millis) {
            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);
          }
        }
      }
    }
  });
}
```


# 场景剖析

在本课程我们会通过以下几个简单场景来剖析 single-spa 的内部执行流程：

*   初始化没有激活微应用，例如直接访问 `http://localhost:3001/`
*   初始化激活 Vue 微应用，例如直接访问 `http://localhost:3001/vue`
*   初始化完成后切换微应用，例如从 `/vue` 切换到 `/react`

> 温馨提示：上述解析场景是常见的真实业务场景，例如在管理后台应用中，登录后的应用如果是微前端框架，登录后往往会先进入一个 dashboard 主页，这个主页如果是在主应用中设计，访问的路径是 `/`，此时没有激活任何 single-spa 微应用。用户在使用的过程中不断切换微应用，则会出现从 `/vue` 切换到 `/react` 的情况，而当用户停留在 `/vue` 并且再次刷新页面时则会出现初始化就需要立即激活某个微应用的场景。

## 初始化没有激活微应用

我们重新回顾 Fetch 示例的 single-spa 简化代码，如下所示：

```javascript
import { start, registerApplication } from "single-spa";

// 注册 React 微应用
registerApplication({
  name: 'react',
  // app 参数如果是函数，则必须返回 Promise 对象
  app: () => {
    return fetchApp([
      "http://localhost:3000/vendors.js",
      "http://localhost:3000/main.js",
    ])
  },
  // react 路由可以激活 React 微应用，
  // 从而执行 app 参数进行微应用的加载和执行
  activeWhen: 'react',
  customProps: {
    container: "micro-app-container"
  }
});

// 注册 Vue 微应用
registerApplication({
  name: 'vue',
  app: () => {
    return fetchApp([
      "http://localhost:8080/js/chunk-vendors.js",
      "http://localhost:8080/js/app.js", 
    ])
  },
  // vue 路由可以激活 Vue 微应用，从而执行 app 参数进行微应用的加载和执行
  activeWhen: 'vue',
  customProps: {
    container: "micro-app-container"
  }
});

start();
```

> 温馨提示：示例源码可以从 micro-framework 的 [analyze/single-spa](https://github.com/ziyi2/micro-framework/tree/analyze/single-spa) 分支获取。这里建议下载该代码查看 `pakcages/single-spa` 的源码，内部加入了源码注释，也可以直接调试源代码加深对于源码的理解。

其中 `fetchApp` 方法主要通过 `window.fetch` 来获取微应用的执行脚本：

```javascript
function async fetchApp(urls: string[]) {
  for (let url of urls) {
    const res = await window.fetch(url);
    const text = await res.text();
    // 使用 eval 执行
    (0, eval)(text);
  }
  
  // 执行微应用的代码后立即获取对应的生命周期函数
  const keys = Object.keys(window);
  const lifeCycles = window[keys[keys.length - 1]];
  return lifeCycles;
}
```

从上述代码可以发现，当我们将路由切换到 `/react` 时会激活 React 微应用，切换到 `/vue` 时会激活 Vue 微应用，但是当我们默认打开 `/` 时不会激活任何微应用。假设我们首次进入主应用时打开的地址是 `/`，此时没有激活任何微应用，我们来查看一下 single-spa 的执行流程，如下所示：

![no-app.svg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8c036adcb4e45ee94678100f762308c~tplv-k3u1fbpfcp-image.image#?w=3323\&h=4853\&s=152360\&e=svg\&a=1\&b=fdf2ce)

> 温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。

我们可以简化上述 UML 流程图，在主应用中使用 [registerApplication](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123) 注册微应用的执行流程如下所示，需要注意每注册一个微应用以下流程都会执行一遍：

![load-app-1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a637fb0cd1e4415f9cd46fdcdd87aac3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2258\&h=2411\&s=502049\&e=png\&b=fefcfc)

从上述执行流程可以发现，每注册一个微应用 single-spa 都会通过 [shouldBeActive](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/app.helpers.js#L27) 判断当前注册的微应用是否需要激活，如果在注册期间激活微应用则会将其加入 `appsToLoad` 数组，然后通过 [loadApps](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L142) 加载该微应用。

> 温馨提示：通过 `appsToLoad` 批量加载微应用时需要获取和解析微应用的生命周期函数，此时必须在执行微应用的代码后才能获取它所导出的生命周期函数。因此，微应用代码的执行时机不是在微应用加载之前（例如之前的 NPM 示例）就是在微应用加载的过程中实时执行（例如 Script 和 Fetch 示例）。

微应用注册完成后需要调用 single-spa 的 [start](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13) 函数启动，它的执行流程如下所示：

![start-1](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0947178c95374f2887e295ef9fb71564~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2702\&h=3350\&s=838827\&e=png\&b=fffefe)

从上述流程可以发现，通过 [registerApplication](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123) 注册微应用时只会执行微应用的加载逻辑（执行注册参数 `app`），但是调用 [start](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13) 函数启动后，single-spa 会调用 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174) 批量处理所有需要变化的微应用，除了会对激活的微应用批量进行异步加载，还会批量异步执行微应用的生命周期函数，包括 `bootstrap`、`mount`、`unmount` 以及 `unload`。

## 初始化激活 Vue 微应用

如果首次直接访问 `http://localhost:3001/vue`，那么需要激活 Vue 微应用。我们来查看一下 single-spa 的执行流程，如下所示：

![vue.svg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/412fb2d66dc64a2a8fefc801e66dbcbd~tplv-k3u1fbpfcp-image.image#?w=4966\&h=8156\&s=289967\&e=svg\&a=1\&b=fbf1cb)

从上述 UML 时序图可以看出 `toLoadPromise`、`toMountPromise`、`toBootstrapPromise`、`toUnloadPromise` 以及 `toUnmountPromise` 都是在微任务中异步执行，因此刷新 `/vue` 路由时可以确保主应用的同步代码先执行完毕，例如 Vue 或者 React 框架的路由代码，等框架的路由切换完成后，才会执行 single-spa 中微应用的生命周期函数，确保运行时序的正确性。

> 温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。

我们同样可以简化上述 UML 流程图，其中在主应用中使用 [registerApplication](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123) 注册微应用的执行流程如下所示，此时因为激活了 Vue 微应用，在注册 Vue 微应用时会异步加载该微应用，如下所示：

![load-app-2.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a63aa4a496464694be1c795f13c10805~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2695\&h=3527\&s=865258\&e=png\&b=fefbfb)

在加载 Vue 微应用的过程中应用的状态会发生 `NOT_LOADED` -> `LOADING_SOURCE_CODE` -> `NOT_BOOTSTRAPPED` 转变。

> 温馨提示：需要注意，在 `LOADING_SOURCE_CODE` 阶段经常会出错，此时会异步加载微应用并且解析微应用导出的生命周期函数，还会对这些生命周期函数进行格式校验，开发者在这个阶段一旦没有导出生命周期函数，或者导出的不是 `async` 函数，都会使得 single-spa 解析不到正确格式的生命周期函数而产生报错。

微应用注册完成后需要调用 single-spa 的 [start](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13) 函数启动，此时因为 Vue 微应用被激活，在 `start` 函数启动并且 Vue 微应用的生命周期函数解析完毕后，再次判断 Vue 微应用是否激活，如果仍然激活则会执行微应用的 `bootstrap` 和 `mount` 生命周期函数，从而可以渲染出 Vue 微应用，它的执行流程如下所示：

![start-2.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65e00f30d82048d390b3b473def56cbf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4167\&h=4478\&s=1469466\&e=png\&b=fffdfd)

完成 Vue 应用的激活、加载和渲染后，应用的状态会发生 `NOT_LOADED` -> `LOADING_SOURCE_CODE` -> `NOT_BOOTSTRAPPED` -> `BOOTSTRAPPING` -> `NOT_MOUNTED` -> `MOUNTED` 转变。

从上述流程可以发现，失活微应用的 `unmout`、`unload` 和激活微应用的 `loadApp`、`bootstrap` 同时执行，而激活微应用的 `mount` 则需要依赖所有失活微应用的 `unmount` 和 `unload` 执行完毕。除此之外，不管是在注册微应用还是 `start` 函数中，都会实时执行 [shouldBeActive](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/app.helpers.js#L27) 来判断应用的激活和失活情况，因此首次直接访问 `http://localhost:3001/vue` 时能够立即判断出需要激活的 Vue 微应用。

> 温馨提示：在 `loadApps` 中已经批量执行了 `toLoadPromise`，为什么在 `performAppChanges` 函数中还需要再次执行 `toLoadPromise`？主要是因为 `loadApps` 只会在应用初始化的注册阶段激活微应用时被执行，而后续的 `load` 处理需要依赖路由变化后 `performAppChanges` 执行。

## 初始化完成后切换微应用

首次直接访问 `http://localhost:3001/vue` 后，single-spa 会激活 Vue 微应用，然后会依次执行微应用的 `loadApp`、 `bootstrap` 以及 `mount`。当 Vue 微应用渲染后，我们可以切换路由来实现微应用的切换，此时如果点击导航从 `/vue` 路由切换到 `/react` 路由，我们来查看一下 single-spa 的执行流程，如下所示：

![vue-react.svg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d298d6a47046bcb3984e14d3fa5354~tplv-k3u1fbpfcp-image.image#?w=5086\&h=7173\&s=255417\&e=svg\&a=1\&b=fbf1c9)

> 温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。

从上述 UML 时序图可以看出，在 single-spa 中需要感知到 React 或者 Vue 框架的路由变化，从而实现微应用的切换。我们可以简化一下上述 UML 流程图，先来剖析一下 single-spa 是如何识别框架的路由变化，它的具体执行流程如下所示：

![nav.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06d23f96f5764a8f8610af0d626cf5c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3382&h=1959&s=494182&e=png&b=fefcfc)

signle-spa 在初始化时会先监听 [hashchagne](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L187) 和 [popstate](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L194) 事件的变化，一旦这些事件触发，并且检测到 URL 发生变化，则会调用 [urlReroute](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L110) 函数重新计算需要变化的微应用，最终会执行 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174)  函数批量处理微应用的卸载和加载。

> 温馨提示：通常情况下，`hashchage` 事件用于监听 `hash` 路由的变化（跟在 `＃` 符号后面的 URL 部分），例如点击锚链接元素、修改 `location.hash`、浏览器历史导航（前进、后退）、修改导航栏地址、调用 `location.replace`、`history.go`、`history.back` 以及 `history.forward` 等，而 `popstate` 事件用于监听历史记录的变化，例如浏览器历史导航（前进、后退）、调用 `history.go`、`history.back` 以及 `history.forward` 等。

但是上述监听事件无法处理 React 或者 Vue 框架的路由变化，因为这些框架是调用 `history.pushState` 或者 `history.replaceState` 来更改 URL 地址，而这两个 API 的执行并不会触发 `popstate` 事件。为了捕获框架的路由变化，single-spa 在初始化时会重写 [window.history.pushState](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L237) 和 [window.history.replaceState](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L242)。

当主应用通过 React Router DOM 的 `<Link>` 标签切换路由时，经过一系列的封装调用最终会抵达 `history.replaceState`，此时调用的是 single-spa 初始化后重写的 `replaceState`，然后会触发 [patchedUpdateState](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L124) 函数并[手动创建和分发 popstate 事件](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L164)，最终执行 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174) 函数进行微应用的加载和卸载处理。

除此之外，在 single-spa 的初始化中还会重写 [window.addEventListener](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L205) 和 [window.removeEventListener](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L223)， 这是为了捕获和延迟执行微应用注册的 `hashchange` 和 `popstate` 事件。例如在微应用激活时触发了 `popstate` 事件，但是此时微应用的代码还没有加载完成，这会使得微应用错过事件监听，因此在 [loadApps](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L142) 执行完毕后会执行 [callAllEventListeners](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L394)。而如果微应用失活时正好触发了 `popstate` 事件，微应用可能希望在卸载时移除监听 `hashchange` 和 `popstate` 事件，此时 single-spa 可以将事件延迟到微应用卸载后执行，这样微应用在卸载后因为移除了相应的监听事件并不会触发事件的监听执行，所以 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174) 会在所有微应用 `unmount` 和 `unload` 后才延迟执行 [callAllEventListeners](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L394)。

> 温馨提示：上述说明可以配合**源码剖析**的 `navigation` 解析一起理解。

从上述解析流程我们了解了 single-spa 对于导航事件的处理，当 React 发生从 `/vue` 到 `/react` 的路由变化时，single-spa 会执行 [patchedUpdateState](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L124) 函数并[手动创建和分发 popstate 事件](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L164)，然后调用 [urlReroute](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L110) 函数（携带 `event` 事件参数），最终执行 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174) 实现 Vue 微应用的卸载和 React 微应用的加载和渲染，最后因为携带了 `event` 参数而延迟执行 `hashchange` 和 `popstate` 事件。此时 [performAppChanges](https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174) 的执行流程如下所示：

![performAppChanges.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2574b908a8493d858b1534ac6583c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4659\&h=4584\&s=1839121\&e=png\&b=fffcfc)

在上述流程中可以发现，完成 Vue 应用的卸载后，应用的状态会发生从 `MOUNTED` -> `UNMOUNTING` -> `NOT_MOUNTED` 的转变，而完成 React 应用的加载和之前 Vue 状态的转变流程一致，会发生从  `NOT_LOADED` -> `LOADING_SOURCE_CODE` -> `NOT_BOOTSTRAPPED` -> `BOOTSTRAPPING` -> `NOT_MOUNTED` -> `MOUNTED` 转变。

> 温馨提示：single-spa 的所有生命周期函数执行都是在微任务中执行，这可以确保主应用框架路由的代码先执行完毕，然后处理微应用的加载和卸载。

# 状态和事件剖析

在**框架解析：引言**中我们讲解了在 MPA 的模式下前端天然可以做到小型应用的拆分，微应用只需要考虑如何根据导航进行跳转，在跳转的过程中无论是新开标签页还是在当前标签页切换应用，浏览器会处理标签页应用的状态的周期事件，如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440aa671d6fd473590ac1d1fd508327e~tplv-k3u1fbpfcp-zoom-1.image)

从上图可以发现，在标签页应用切换的过程中，浏览器控制了应用运行的**状态**和**事件**，其中部分应用状态由用户发起，包括激活、失活、隐藏和终止等，而部分应用的状态则是浏览器自行发起，包括冻结和丢弃。其实 single-spa 中微应用的切换和浏览器中标签页的切换非常相似，如下所示：

![yuque_diagram (44).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c4bcad3a4d496d93fe1803c8186dd6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3031&h=2535&s=622941&e=png&b=ffffff)

如果用户导航到了新的路由，当前 single-spa 在计算应用变化时会参考微应用当下的状态：

- 如果还未加载（`NOT_LOADED`）并匹配了路由，会准备加载，状态会变成 `LOADING_SOURCE_CODE`
- 如果正在加载中（`LOADING_SOURCE_CODE`）并匹配了路由，会继续加载（会命中重复执行）
- 如果已经加载失败（`LOAD_ERROR`）并匹配了路由，会继续加载，重试请求
- ... 

> 温馨提示：上图中的虚线指向的状态表明当前微应用在计算变化前所处的状态，而实线则表示微应用的状态变更。

由于部分事件的触发依赖多个状态的同时变更，因此单独将其进行展示，如下所示：

![yuque_diagram (46).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58401e7cafcf4e1cb64d1403c81c1955~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1578&h=2217&s=287311&e=png&b=ffffff)

在上述事件中，如果开发者监听了 `single-spa:before-routing-event` 事件并调用了事件传递的 `cancelNavigation` 函数取消导航，那么 single-spa 会立即触发 `single-spa:before-mount-routing-event` 事件，而如果没有取消导航，则在正常执行时会等待所有微应用的卸载 `unmount` 和彻底卸载 `unload` 执行完毕后再触发 `single-spa:before-mount-routing-event` 事件。


## 小结

本课程从场景剖析、状态和事件剖析、源码剖析三个方面详细讲解了 single-spa 的内部运行原理，如果还想深入了解内部原理，可以结合本课程提供的 [analyze/single-spa](https://github.com/ziyi2/micro-framework/tree/analyze/single-spa) 分支逐行调试源码。single-spa 内部的运行原理解析为了解 qiankun 内部的运行机制奠定了基础。在下一个课程中，我们会重点了解如何使用 qiankun 设计微前端。


