大家在学习的过程中会产生一些和微前端息息相关的问题，这些问题有的是小册内容里作者额外发散提问没有做出解答，但是从评论区可以发现很多同学比较感兴趣，有的问题则比较宏观，可能需要新开课程章节来回答，另外一些问题尽管和微前端息息相关，但是无法契合小册的任何一个课程，因此作者将这些问题单独在这里进行罗列并进行一一回复，希望对大家有所帮助。


> TODO：后面有没有章节讲讲 Webpack5 模块联邦（Module Federation）和实践

- 作者回复：会在小册中新增**方案了解：Module Federation 方案**
- 作者计划：小册主线课程更新完成后


> TODO：我感觉京东的 micro-app 也挺好的，能在后续章节也一并介绍一下吗

- 作者回复：会在小册中新增**源码分析：MicroApp**
- 作者计划：小册主线课程更新完成后

> TODO：希望可以多增加一点实战内容。

- 作者回复：会在小册中新增
    - **框架实战：single-spa 实战**
    - **框架实战：qiankun 实战**
- 作者计划：会在讲解源码分析前进行课程插入，从而方便大家更好的理解源码。


> TODO：小册有 monorepo 相关的吗

关于 Monorepo 在**方案了解：NPM 方案**作者给出了 Monorepo 相关的课程示例，具体可以查看仓库代码：https://github.com/ziyi2/micro-framework/tree/demo/npm-micro, 在该示例中主要使用了 Lerna 进行了处理。当然，课程中没有讲解 Monorepo 相关的具体知识，由于该知识暂时和课程相关性不大，所以暂时不考虑新增课程章节进行处理。


> 微前端、Monorepo、Module Federation（模块联邦），三者的本质区别是什么？如何理解可以避免三者在某些层面的共同特性上带来的认知干扰？

**Monorepo：** 在一些业务组件的开发中，可能会存在如下需求：

- 所有的业务组件支持单独发布 NPM 包版本，独立维护影响面小
- 这些业务组件互相之间可能会产生依赖，或者依赖了一些公共方法
- 希望在一个 Git 仓库中统一管理和维护这些业务组件
- 只需要一套可复用的开发态和构建配置

在没有 Monorepo 之前，一般开发业务组件的开发方案如下所示：

- 设计一个可复用的组件开发脚手架，每次新建业务组件时都需要新开单独的 Git 仓库，然后利用脚手架快速生成包含开发态和构建的组件开发解决方案。如果开发的一些业务组件还需要依赖公共方法，那么也需要抽离出这些公共方法，从而形成一个工具 NPM 库包。如果在开发态修改一个组件的问题时，还需要更改底层依赖的工具 NPM 库包，那么需要通过 `npm link` 进行联动，然后还需要独立发布这两个库包。

- 如果希望使用一个统一的 Git 仓库来管理所有的业务组件，并且还希望它们能单独发包。那么需要设计一些复杂的构建脚本，支持构建产物后可分别进入各个业务组件的产物目录进行独立发布，但是也需要考虑开发态和生产态对于依赖引入的路径问题，例如互相之间的依赖需要额外配置路径映射关系，从而使得开发态可以和生产态保持一致（开发态需要引入的是互相之间的相对目录路径，而生产态其实引入的是 NPM 库包）

上述问题可以通过 Monorepo 进行解决：

- 所有的组件都在同一个 Git 仓库中
- 可以对所有的组件进行统一版本发布，也可以单独发布各自的版本
- 不需要 `npm link` 进行依赖之间的互相引入关系处理，Monorepo 会自动进行处理
- 开发态和生产态可以天然保持一致性（当然如果希望开发态引入的是各个组件的源码而不是构建后的产物，而生产态引入的是各个组件的 NPM 包，其实是构建后的产物，那么需要额外做一些处理）

Monorepo 的目的是减少仓库项目的数量，提高代码的复用性，协同开发和跨 NPM 包的协同开发效率，总体上来说，Monorepo 技术是一种项目工程上的管理策略。在微前端的框架开发中，如果希望将沙箱技术、应用状态管理、性能优化、应用资源请求解析、通信技术等发布成独立的 NPM 包进行单独使用，或者进行整合使用，那么也可以通过 Monorepo 的技术进行开发。更多关于 Monorepo 的思考，可以查看[ Vue CLI 3 结合 Lerna 进行 UI 框架设计](https://juejin.cn/post/6844903817776103431)。


**Module Federation（模块联邦）：** Monorepo 是一种开发态项目管理策略，其中最具代表性的工具实现是 Lerna，而 Module Federation 则是一种运行时技术，它主要在运行时通过网络进行资源的动态加载，从而使得多个应用可以在运行时共享代码。我个人理解它的最佳场景是性能优化，例如在微前端中，假设多个子应用共享了 React、Redux、Moment、Ant Desigin 等可复用的库，通常情况下如果不做任何处理，那么每一个子应用的静态资源都会将上述这些库打进各自的 Bundle，从而在请求每一个子应用的静态资源时都会包含这些库，那么能否将子应用的这些共享库变成远程可动态加载的模块呢，从而可以通过缓存技术进行性能优化。例如大家在引入这些库的时候都是请求同一个静态资源模块，那么第 1 个子应用请求完 React 资源模块之后，第二个子应用再次请求 React 时就可以从缓存中获取了。除此之外，如果 Moment 在比较复杂的路由中才会使用到，那么通常情况下，用不到 Moment 资源时不会发起请求，从而通过动态按需加载来节省总体上的请求资源量。当然，在微前端中，也可以将子应用全部变成动态模块，从而在主应用中通过 Module Federation 进行运行时动态加载。总体而言，Module Federation 是一种实现模块共享和动态加载的运行时技术。补充一下，Module Federation 会面临着一种约束，例如在微前端中所有子应用如果要共享 React，那么需要约束同一个 React 版，当然，也可以发布多个 React 版本，然后各个子应用分别去依赖对应的 React 版本。

**微前端：** 微前端是一种架构模式，更多介绍请参考《深入浅出微前端》小册。需要注意的是，微前端也可以通过 Monorepo 的方式在开发态进行工程项目管理，例如所有的子应用希望共享同一套技术体系，或者这些子应用共享了需要实时可修改的工具模块，或者这些子应用是通过 NPM 方案进行整合。同时，微前端也可以在运行时借助 Module Federation 进行微应用的运行时模块拆分。


> 大佬！统一产品的大型应用，那权限系统也需要重新做集成吗 ？你们是如何做的呀？就是用户登录主应用后，主应用的左侧菜单和按钮权限，你们在主应用中是如何做的呀？

首先登录了以后，当前用户的登录态 Cookie 信息就种下了。 如果希望保持页面的性能，那么可以在服务端返回登录后的 HTML 时将用户的鉴权信息以及菜单信息通过类似于 `window.globalConfig` 进行模版填充，从而可以使得前端可以快速拿到相应的信息。当然，也可以通过渲染 HTML 后进行 Ajax 请求获取菜单以及其它权限信息进行处理。如果还需要一些额外的鉴权匹配并且还涉及到 Ajax 请求，那么可以统一放在请求拦截器里进行处理。


> 这么看低代码存在的有啥意义呢? 快速搭建最终又走向重构

我理解低代码应该有它的价值的，比如简单重复应用快速开发，减少人力成本，当然这是从技术角度出发的。从业务或者商业角度出发，比如智能表单，智能可视化，智能数据等，是可以创造更多的价值的，前提是低代码不能只是低代码，而是要走向特定业务领域。

> 请教一下，我采用的同域加载子应用的方案，在生产环境下存储共享没什么问题，但在开发环境下应该如何解决免登录的问题（在某个单独应用开发环境下相对于其他应用来说都属于跨域)，现阶段每个子应用都单独加的有登录逻辑，但是我想把登录抽离开，有好的解决方案嘛? 其实我主要就是想了解在开发环境下产生的问题应当如何处理，例如生产环境下我的主应用在站点A，子应用在站点B，我在开发环境调试主应用时，嵌入的子应用B站点就没办法共享主应用的登录令牌；同样的我本地单独调试子应用B时，也没有办法直接使用主应用A的登录模块来获取登录令牌。因为在生产环境下是没问题的，开发环境下因为互相跨域，所以产生了这些苦恼。不知道我说清楚了没有，希望得到作者大大的解答~

关于同域的解决方案，可以使用系统代理工具。调试时，将生产环境（或者测试环境）的主应用资源或者子应用资源通过系统代理或者其他代理工具（例如 XSwitch 插件）代理成本地资源地址，此时线上访问的应用不产生跨域问题，但是子应用或者主应用的资源使用了本地调试态的资源，从而可以进行开发和调试。关于如何使用系统代理工具，我会在[番外篇：如何提高效率](https://juejin.cn/book/7258893482318626868/section/7292031353426542619)中进行讲解。


> 通常在开发态时，为了使得主应用能够查看微应用 NPM 包的集成效果，在修改微应用后需要对微应用进行构建才能在主应用中查看微应用的修改效果。有没有方法可以做到主应用引入方式不变的情况下，在开发态引入的是微应用的源码（修改微应用的代码后不需要构建，直接在主应用中会热更新变更），而在生产态引入的是微应用构建后发布的 NPM 包?

需要注意，上述问题有一个前提，那就是引入 NPM 包所在的项目环境和被引入的包所在的项目环境需要的构建配置差异相对较小，否则前者在引入后者源码的时候还需要额外做一些构建配置。这个问题有很多解决方案，这里讲解一些解决思路：

- 1、从主应用角度出发，可以进行路径映射配置，例如在开发态进行 Webpack 的 `alias` 或者 TypeScript 的 `compilerOptions.paths` 配置，将 NPM 包的引入地址映射成开发态入口地址，如果配置了 `babel-loader`，那么编译时需要考虑不屏蔽 `node_modules` 下需要被引入源码的包，从而使得开发态时启动主应用加载的是对应的源码，而生产态则加载的是 NPM 包。
- 2、如果在 Monorepo 的模式下，主应用和子应用共享同一套构建配置时，那么可以在思路一的基础上新增一个主应用构建的环境变量，从而使得主应用仍然可以支持路径映射配置。当然，这样就会导致每加载一个子应用，可能需要额外加一个映射路径。此时，也可以考虑更改各个子应用的 `package.json` 中的 NPM 包入口地址 `main` 或者 `module` 使其指向开发态地址，当需要进行 NPM 发布时，可以通过脚本进行 `main` 的自动更改和恢复，例如利用 `npm publish` 的钩子进行 Node 脚本处理。






