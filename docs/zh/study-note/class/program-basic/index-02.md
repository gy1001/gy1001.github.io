# 编程基础-02

## 6 操作系统之基础篇

### 6.1 本章知识概要与学习计划

#### 6.1.1 操作系统的演进

1. 无操作系统
    - 人工操作
    - 用户独占
    - CPU 等待人工操作
    - 资源利用率低
2. 批处理系统
    - 无序等待人工操作
    - 批量输入任务
    - 资源利用率提升
    - 多道程序设计
3. 分时系统
    - 人机交互
    - 多用户共享
    - 及时调试程序
    - 资源利用率提升
4. 多道程序设计
    - 早期批处理系统只能一次处理一个任务
    - 多道程序设计使得批处理系统可以一次处理多个任务
    - 多道程序设计是指在计算机内存中同时存放多个程序
    - 多道程序设计在计算机的管理程序之下相互穿插运行
    - **对多道程序的管理是操作系统的重要功能**
5. 对多道程序的管理
    - 进程管理
    - 存储管理
    - 作业管理
    - 文件管理
    - 设备管理

### 6.2 操作系统概览

### 6.2.1 what & why

#### 6.2.1.1 **What**

> 管理软件、提供用户交互的软件系统

- 操作系统是管理计算机硬件和软件资源的**计算机程序**
- 管理配置内存、决定资源提供供需顺序、控制输入输出设备等
- 操作系统提供让用户和系统交互的**操作界面**
- 操作系统的种类是多种多样的，不局限于计算机
- 从手机到超级计算机，操作系统可简单也可复杂
- 在不同的设备上，操作系统可向用户呈现多种操作手段
- 常见的操作系统种类：Android、Ios、Windows、Linux、MacOs、华为鸿蒙

#### 6.2.1.2 **Why**：

- 我们不可能直接操作计算机硬件
- 设备种类繁多复杂，需要统一界面
- 操作系统的简易性使得更多人能够使用计算机

### 6.2.2 操作系统的基本功能

1. 操作系统统一管理着计算机资源
    - 处理器资源
    - 存储器资源
    - IO 设备资源
    - 文件资源
2. 操作系统实现了对计算机资源的抽象
    - 用户无需面向硬件接口编程
    - IO 设备管理软件，提供读写接口
    - 文件管理软件，提供操作文件接口
3. 操作系统提供了用户与计算机之间的接口
    - 图像窗口形式
    - 命令形式
    - 系统调用形式

### 6.2.3 操作系统相关概念

1. 并发性

   > 什么是并行，什么是并发

    - 并行是指两个或者多个事件可以在**同一时刻**发生
    - 并发是指两个或者多个事件可以在**同一时间间隔**发生

2. 共享性

    - 共享性表现为操作系统中的资源可供多个并发的程序共同使用
    - 这种共享使用的形式称之为资源共享
    - 多个程序可以同时使用主存资源
    - 资源共享根据属性可以分为两种方式
        - 互为共享形式
            - 当资源被程序 A 占用时，其他想使用的话只能等待
            - 只有进程 A 使用完成以后，其他进程才可以使用该资源
        - 同时访问形式
            - 某种资源在一段时间内被并发地被多个程序访问
            - 这种”同时“是宏观的，从宏观去看该资源可以被同时访问

3. 虚拟性

    - 虚拟性表现为把一个**物理实体**转变为若干个**逻辑实体**
    - 物理实体是真实存在的，逻辑实体是虚拟的
    - 虚拟的技术主要分为**时分复用技术**和**空分复用技术**
    - 时分复用技术：
        - 资源在时间上进行复用，不同程序并发使用
        - 多道程序分时使用计算机的硬件资源
        - 提高资源的利用率
        - 它又分为
            - 虚拟处理器技术
                - 借助多道程序设计技术
                - 为每个程序建立进程
                - 为买个程序分时复用处理器
            - 虚拟设备技术
                - 物理设备虚拟为多个逻辑设备
                - 每个程序占用一个逻辑设备
                - 多个程序通过逻辑设备并发访问
    - 空分复用技术
        - 充分复用技术用来实现虚拟磁盘、虚拟内存等
        - 提高资源的利用率，提升编程效率
        - 它又分为
            - 虚拟磁盘技术
                - 物理磁盘虚拟为逻辑磁盘
                - C、D、E 等逻辑盘
                - 使用起来更加安全、方便
            - 虚拟内存技术
                - 在逻辑上扩大程序的存储容量
                - 使用比实际内存更大的容量
                - 大大提升编程效率

4. 异步性

    - 在多道程序环境下，允许多个进程并发执行
    - 进程在使用资源时可能需要等待或放弃
    - 过程的执行并不是一气呵成，而是以走走停停的形式推进

### 6.3 进程管理之进程实体

#### 6.3.1 为什么需要进程

- 在没有配置 OS 之前，资源属于当前运行的程序
- 配置 OS 之后，引入**多道程序设计**的概念
- 合理的隔离资源、运行环境，提升资源利用率

因此可以说

- 进程是系统进行资源分配和调度的基本单位
- 进程作为程序独立运行的载体保障程序正常执行
- 进程的存在使得操作系统资源的利用率大幅度提升

#### 6.3.2 进程的实体

1. 主存中的进程形态

   > 分为：进程标识符、处理机状态、进程调度信息、程序控制信息

    - 标识符：唯一标记一个进程，用于区别其他进程
    - 状态：标记进程的进程状态，如：运行态
    - 优先级
    - 程序计数器：程序即将被执行的下一条指令的地址
    - 内存指针：程序代码、进程数据相关指针
    - 上下文数据：进程执行时处理器存储的数据
    - IO 状态信息：被进程 IO 操作所占用的文件列表
    - 记账信息：使用处理器时间、时钟数总和等

2. 进程控制块 PCB：

    - 用于描述和控制进程运行的通用数据结构
    - 记录进程当前状态和控制进程运行的全部信息
    - PCB 的使得进程是能够独立运行的基本单位
    - PCB 是操作系统进行调度经常会被读取的信息
    - PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内

3. 进程与线程

   > 一个进程可以有多个线程

    - 进程 process：
        - 进程是系统进行资源分配和调度的基本单位
        - 一个进程可以并发多个线程，每个线程执行不同的任务
    - 线程 thread：
        - 线程是操作系统进行运行调度的最小单位
        - 包含在进程之中，是进程中实际运行工作的单位

4. 区分

   |          | 进程               | 线程                 |
      | :------- | ------------------ | -------------------- |
   | 资源     | 资源分配的基本单位 | 不拥有资源           |
   | 调度     | 独立调度的基本单位 | 独立调度的最小单位   |
   | 系统开销 | 进程系统开销大     | 线程系统开销小       |
   | 通信     | 进程 PIC           | 读写同一进程数据通信 |

### 6.4 进程管理之五状态模型

#### 6.4.1 就绪

- 当进程被分配到除 CPU 以外所有必要的资源后
- 只要在获得 CPU 的使用权，就可以立即执行
- 其他资源都准备好、只差 CPU 资源的状态为**就绪状态**
- 在一个 系统中多个处于就绪状态的进程通常排成一个队列（叫做就绪队列，（会有一个或者多个就绪进程））

#### 6.4.2 执行

- 进程获得 CPU，其程序正在执行 称为执行状态
- 在单处理机中，在某个时刻只能有一个进程是处于执行状态

#### 6.4.3 阻塞

- 进程因某种原因：其他设备未就绪而无法继续执行
- 从而放弃 CPU 的状态称为阻塞状态
- 同样会有一个阻塞队列（会有一个或者多个阻塞进程）

#### 6.4.4 创建

> 创建进程时拥有 PCB，但是其他资源尚未就绪的状态称为创建状态
>
> 操作系统 提供 fork 函数接口创建进程

1. 分配 PCB
2. 插入就绪队列

#### 6.4.5 终止

> 进程结束由系统清理或者归还 PCB 的状态称为终止状态

1. 系统清理
2. PCB 归还

### 6.5 进程管理之进程同步

#### 6.5.1 为什么需要进程间同步

1. 生产者-消费者问题

   > 有一群生产者进程在生产产品，并将这些产品提供给了消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的的缓冲池，生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。

   单从生产者程序或者消费者程序去看是没有问题的，单两者并发执行时就可能出差错

2. 哲学家进餐问题

   > 有 5 个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有 5 个碗和 5 支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两支筷子，只有两支筷子都被他拿到的时候就能进餐，进餐完毕之后，放下左右筷子继续思考
   >
   > 拿起左边筷子，拿起右边筷子，进餐

3. - 根源问题是：彼此相互之间没有通信
- 如果生产者通知消费者我已经完成一件生产
- 哲学家向旁边哲学家说我要进餐了

> 对竞争资源在多进程间进行使用次序的协调
>
> 使得并发执行的多个进程之间可以有效使用资源和相互合作

#### 6.5.2 进程间同步的原则

1. 临界资源：

   > 临街资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时候，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

2. 原则

    - 空闲让进：资源无占用，允许使用
    - 忙则等待：资源有占用，请求进程等待
    - 有限等待：保证有限等待时间能够使用资源
    - 让权等待：等待时，进程需要让出 CPU

3. 进程同步的方法

    - 消息队列
    - 共享存储
    - 信号量

#### 6.5.3 线程同步

进程的线程共享进程资源，那么当多个线程并发使用进程资源时，会发生什么呢？

因此，进程内多线程也需要同步

线程同步的方法

- 互斥量
- 读写锁
- 自旋锁
- 条件变量

### 6.6 Linux 的进程管理

#### 6.6.1 Linux 进程的相关概念

1. 进程的类型

    - 前台进程
        - 前台进程就是具有终端，可以和用户交互的进程
    - 后台进程

      > 将需要执行的命令以 & 符号结束

        - 与前台进程相对，没有占用终端的就是后台进程
        - 后台程序基本上不用和用户交互，优先级比前台进程低

    - 守护进程

        - 守护进程（daemon）是特殊的后台进程
        - 很多守护进程在系统引导的时候启动，一直运行直到系统关闭
        - Linux 有很多典型的守护进程
        - 进程名字以 d 结尾的一般都是守护进程：crond、httpd、sshd、mysqld

2. 进程的标记

    - 进程 ID

        - 进程 ID 是进程的唯一标记，每个进程拥有不同的 ID
        - 进程 ID 表现为一个非负整数，最大值由操作系统限定
        - 操作系统提供 frok 函数接口创建进程
        - 父子进程关系可以通过 pstree 命令查看
        - ID 为 0 的进程为 idle 进程，是系统创建的第一个进程
        - ID 为 1 的进程为 lnit 进程，是 0 号进程的子进程，完成系统初始化
        - lnit 进程是所有用户进程的祖先进程

    - 进程的状态 标记

      | 状态符号 | 状态说明                                                |
           | -------- | ------------------------------------------------------- |
      | R        | TASK_RUNNING, 进程正处于运行状态                        |
      | S        | TASK_INTERRUPTIBLE, 进程正处于睡眠状态                  |
      | D        | TASK_UNINTERRUPTIBLE, 进程正在处于 IO 等待的睡眠时间    |
      | T        | TASK_STOPPED, 进程正处于暂停状态                        |
      | Z        | TASK_DEAD or EXIT_ZOMBIE 进程正处于推出状态，或僵尸状态 |

#### 6.6.2 操作 Linux 进程的相关命令

1. ps 命令
    - 常用于显示当前进程的状态
    - 通常配合 aux 参数或者 ef 参数和 grep 命令检索特定进程
2. top 命令
3. kill 命令
    - kill 命令发送指定信号给进程
    - kill -l 可以查看操作系统支持的信号
    - 只有(SIGKILL 9) 信号可以无条件终止进程，其他信号进程有权忽略

### 6.7 作业管理之进程调度

#### 6.7.1 进程调度概述

> 进程调度是指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权

- 保留旧进程的运行信息，请出旧进程（收拾包袱）
- 选择新进程，准备运行环境并分配 CPU（新进驻）

1. 几种机制概念

    - 就绪队列的排队机制
        - 将就绪进程按照一定的方式排列成队，以便调度程序可以最快找到就绪进程
    - 选择运行进程的委派机制

        - 调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它

    - 新老进程的上下文切换机制
        - 保存当前进程的上下文信息，装入被委派执行进程的运行上下文

2. 问题：进行进程调度时候，老进程还没有执行完成，该怎么办？按照老进程有没有执行完成可以分为两大类

    - 非抢占式的调度
    - 处理器一旦分配给某个进程，就让该进程一直使用下去
    - 调度程序不以任何原因抢占正在被使用的处理器
    - 直到进程完成工作或因为 IO 阻塞才会让出处理器
    - 抢占式的调度
        - 允许调度程序以一定的策略暂停当前运行的进程
        - 保存好旧进程的山下文信息，分配处理器给新进程

3. 区别

   | 类型     | 抢占式调度       | 非抢占式调度       |
      | -------- | ---------------- | ------------------ |
   | 系统开销 | 频繁切换，开销大 | 切换次数少，开销小 |
   | 公平性   | 相对公平         | 不公平             |
   | 应用     | 通用系统         | 专用系统           |

#### 6.7.2 进程调度算法

1. 先来先服务调度算法
2. 短进程优先调度算法
    - 调度程序优先选择就绪队列中估计运行时间最短的进程
    - 短进程优先调度算法不利于长作业进程的执行
3. 高优先权调度算法
    - 进程附带优先权，调度程序优化选择权重更高的进程
    - 高优先权优先调度算法使得紧迫的任务可以优先处理
4. 时间片轮转调度算法
    - 按照先来先服务的原则排列就绪进程
    - 每次从队列头部取出待执行进程，分配一个时间片执行
    - 是相对公平的调度算法，但是不能保证及时响应用户

### 6.8 作业管理之死锁

> 死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推荐下去。此时称系统处于死锁状态或者系统产生了死锁，这些永远在互相等待的进程称为死锁进程

#### 6.8.1 死锁的产生

1. 竞争资源
    - 共享资源数量不满足各个进程需求
    - 各个进程之间发生资源竞争导致死锁
    - 死锁的
2. 进程调度顺序不当
3. 死锁的四个必要条件
    - 互斥条件
        - 进程对资源的使用是排他性的使用
        - 某资源只能由一个进程使用，其他进程需要使用只能等待
    - 请求保持条件
        - 进程至少保持一个资源，又提出新的资源请求
        - 新资源被占用，请求被阻塞
        - 被阻塞的进程不释放自己保持的资源
    - 不可剥夺条件
        - 进程获得的资源在未完成使用前不能被剥夺
        - 获得的资源只能由进程自身释放
    - 环路等待条件
        - 发生死锁时，必然存在进程-资源环形链

#### 6.8.2 死锁的处理

1. 预防死锁的方法

   > 上一节死锁有四个必要条件，那么破坏其中之一 就可以

    - 摒弃请求保持条案
        - 系统规定进程运行之前，一次性申请所有需要的资源
        - 进程在运行期间不会提出资源请求，从而摒弃请求保持条件
    - 摒弃不可剥夺条件
        - 当一个进程请求新的资源得不到满足时，必须释放占有的资源
        - 进程运行时占有的资源可以被释放，意味着可以被剥夺
    - 摒弃环路等待条件
        - 可用资源线性排序，申请必须依照递增申请
        - 线性申请不再形成环路，从而摒弃了环路等待条件

2. 银行家算法

    - 是一个可操作的著名的避免死锁的算法
    - 以银行借贷系统分配策略为基础的算法
    - 假如
        - 客户申请的贷款是有限的，每次申请都需要声明最大资金量
        - 银行家在能够满足贷款时，都应该给用户贷款
        - 客户在使用贷款后，能够及时归还贷款
        - 需要几个结构: 已分配资源表、所需资源表、可分配资源表、还需分配资源表（所需资源表 - 已分配资源表）

### 6.9 存储管理之内存分配与回收

> 早期计算机编程并不需要过多的存储管理
>
> 随着计算机和程序越来越复杂，存储管理成为必要

1. 目的
    - 确保计算机有足够的内存处理数据
    - 确保程序可以从可用内存中获取一部分内存使用
    - 确保程序可以归还使用后的内存以供其他程序使用

#### 6.9.1 内存分配的过程

1. 单一连续分配
    - 单一连续分配是最简单的内存分配方式
    - 只能在单用户、单进程的操作系统中使用
2. 固定分区分配
    - 固定分区分配是支持多道程序的最简单存储分配方式
    - 内存空间被划分为若干固定大小的区域
    - 每个分区只提供一个程序使用，互不干扰
3. 动态分区分配
    - 根据进程实际需要，动态分配内存空间
    - 相关数据结构、分配算法
    - 涉及的数据结构
        - 动态分区空闲表数据结构
        - 动态分区空闲链数据结构
    - 动态分区分配算法
        - 首次适应算法（FF 算法）
            - 内存分配时从开始顺序查找适合内存区
            - 若没有合适的空闲区，则该次分配失败
            - 每次从头部开始，使得头部地址空间不断被划分
        - 最佳适应算法（BF 算法）
            - 最佳适应算法要求空闲区链表按照容量大小排序
            - 遍历空闲区链表找到最佳合适空闲区
        - 快速适应算法（QF 算法）
            - 快速适应算法要求有多个空闲区链表
            - 每个空闲区链表存储一种容量的空闲区

#### 6.9.2 内存回收的过程

1. 需要回收的区域与一块空闲区是连接在一起的，并且位于空闲区的后面
    - 不需要新建空闲链表节点
    - 只需要把回收区前面的空闲区容量增大为包括回收区的容量即可
2. 需要回收的区域与一块空闲区是连接在一起的，并且位于空闲区的前面
    - 将回收区与空闲区合并
    - 新的空闲区使用回收区的地址
3. 需要回收的区域位于两块空闲区之间的
    - 将两块空闲区和回收区进行合并
    - 新的空闲区使用最前面的空闲区的地址作为新的地址
4. 单一的回收区，没有链接任何空闲区
    - 为回收区创建新的空闲节点
    - 插入到相应的空闲区链表中去

### 6.10 存储管理之段页式存储管理

> 操作系统是如何管理进程的空间的呢？

#### 6.10.1 页式存储管理

> 字块是相对物理设备的定义
>
> 页面则是相对逻辑空间的定义

- 将进程逻辑空间等分成若干个大小的页面
- 相应的把物理内存空间分成与页面大小的物理块
- 以页面为单位把进程空间装进物理内存中分散的物理块
- 页面大小应该适中，过大难以分配，过小内存碎片过多
- 页面大小通常是 512B - 8k

> 页表记录进程逻辑空间与物理空间的映射

- 现代计算机系统中，可以支持非常大的逻辑地址空间(2^32 - 2^64) ，这样，页表就变得非常大，要占用非常大的内存空间，如 具有 32 位逻辑地址空间的分页系统，规定页面大小为 4kb, 则在每个进程页表中的页表项可达 1M（2^20 个），如果每个页表项占有 1Byte, 故每个进程仅仅页表就要占用 1MB 的内存空间
- 将进程逻辑空间等分成若干大小的页面
- 相应的把物理内存空间分成与页面大小的物理块
- 以页面为单位把进程空间装进物理内存中分散的物理块
- 注意：如果有一段连续的逻辑分布在多个页面中，将大大降低执行效率

#### 6.10.2 段式存储管理

- 将进程逻辑空间划分为若干段（非等分）
- 段的长度由连续逻辑的长度决定
- 主函数 MAIN、子程序端 X、子函数 Y 等

注意：段式存储和页式存储都离散地管理了进程的逻辑空间，

- 页是物理单位，段是逻辑单位
- 分页是为了合理利用空间，分段是满足用户要求
- 页大小由硬件固定，段长度可动态变化
- 页表信息是一维的，段表信息是二维的

#### 6.10.3 段页式存储管理

- 分页可以有效提高内存利用率(虽说存在页内碎片)
- 分段可以更好满足用户需求
- 两者结合，形成段页式存储管理
- 先将逻辑空间按段式管理分成若干端
- 再把段内空间按页式管理等分为若干页

### 6.11 存储管理之虚拟内存

> 问题：一个游戏十几个 G, 物理内存只有 4G, 那么这个游戏是怎么运行起来的？

#### 6.11.1 虚拟内存概述

- 有些进程实际需要的内存很大，超过物理内存的容量
- 多道程序设计，使得每个进程可用物理内存更加稀缺
- 不可能无限增加物理内存，物理内存总有不够的时候
- 虚拟内存是操作系统内存管理的关键技术
- 使得多道程序设计和大程序运行成为现实
- 把程序使用内存划分，将部分暂时不使用的内存放置在辅存

#### 6.11.2 程序的局部性原理

> 局部性原理是指 CPU 访问存储器时，无论是存取指令还是读取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。

- 程序运行时，无需全部装入内存，装载部分即可
- 如果访问页不在内存，则发出缺页中断，发起页面置换
- 从用户层面看，程序拥有很大的空间，即是虚拟内存
- 虚拟内存实际就是对物理内存的补充，速度接近于内存，成本接近于辅存。

#### 6.11.3 虚拟内存的置换算法

- 先进先出算法（FIFO）
- 最不经常使用算法（LFU）
- 最近最少使用算法（LRU）

其次

- 替换策略发生在 Cache-主存层次、主存-辅存层次
- Cache-主存层次的替换策略主要是为了解决**速度问题**
- 主存-辅存层次主要是为了解决**容量问题**

### 6.12 Linux 的存储管理

#### 6.12.1 Buddy 内存管理算法

> 目的是努力让内存分配与相邻内存合并并能快速进行

- buddy 算法是经典的内存管理算法
- 算法基于计算机处理二进制的优势具有极高的效率
- 算法主要是为了解决**内存外碎片**的问题
- 页内碎片
    - 内部碎片是已经被分配出去(能够明确指出属于哪个进程)的内存空间大于请求所需的内存空间。不能被利用的内存空间就是内部碎片
- 页外碎片
    - 外部碎片是指还没有分配出去（不属于任何进程），但是由于大小而无法分配给申请内存空间的新进程的内存空闲块
- 内存分配原则
    - 向上取整数为 2 的幂大小：如果申请 70k 的内存，那就分配 128k 的内存；如果申请 129k 的内存，就分配 256 的内存；...
- 伙伴系统
    - 伙伴指的是内存中的伙伴
    - 一片连续内存的伙伴是相邻的另一片大小一样的连续内存
- 算法的具体流程
    - 创建一系列的空闲块链表，每一种都是 2 的幂
    - xxx

#### 6.12.2 Linux 交换空间

- 交换空间(Swap)是磁盘的一个分区
- Linux 物理内存饱满时，会把一些内存交换至 Swap 空间
- Swap 空间是初始化系统时候配置的
- 冷启动内存依赖
- 系统睡眠依赖
- 大进程空间依赖
- Swap 空间 VS 虚拟内存
    - Swap 空间存在于磁盘，虚拟内存存在于磁盘
    - Swap 空间与主存发生置换，虚拟内存与主存发生置换
    - Swap 空间是操作系统概念，虚拟内存是进程概念
    - Swap 空间解决系统物理内不足的问题，虚拟内存解决进程物理内存不足的问题

### 6.13 操作系统的文件管理

#### 6.13.1 文件的逻辑结构

1. 逻辑结构的文件类型

    - 有结构文件：文本文件 、文档、媒体文件

        - 文件内容由定长记录和可变长记录租场
        - 定长记录存储文件格式、文件描述等结构化数据项
        - 可变长记录存储文件具体内容

    - 无结构文件：二进制文件、链接库
        - 也成为流式文件
        - 文件内容以字节为单位

2. 顺序文件

    - 顺序文件是指按照顺序存放在存储介质中的文件
    - 磁带的存储特性使得磁带文件只能存储顺序文件
    - 顺序文件时所有逻辑文件当中存储效率最高的
    - 问题：顺序文件的增删改？这时候是很没有效率的

3. 索引文件

    - 可变长文件不适合顺序文件格式存储
    - 索引文件时为了解决可变长文件存储而发明的一种文件格式
    - 索引文件需要配合**索引表**完成存储的操作

#### 6.13.2 辅存的存储空间分配

1. 辅存的分配方式

    - 连续分配

        - 顺序读取文件内容非常容易，速度很快
        - 对存储要求高，要求满足容量的连续存储空间

    - 链接分配

      > 链接分配可以将文件存储在离散的盘块中
      >
      > 需要额外的存储空间存储文件的盘块链接顺序

        - 隐式链接分配
            - 隐式分配的下一个链接指向存储在当前盘块内
            - 隐式分配适合顺序访问，随机访问效率很低
            - 可靠性差，任何一个连接出问题都影响整个文件
        - 显式链接分配
            - FILE Allcation Table
            - 不支持高效的直接存储(FAT 记录项多)
            - 检索时 FAT 表占用较大的存储空间（需要将整个 FAT 加载到内存）
            - 把文件的所有盘块集中存储(索引)
            - 读取某个文件时，将文件索引读取进内存即可

    - 索引分配

        - 每个文件拥有一个索引块，记录所有盘块信息
        - 索引分配方式支持直接访问盘块
        - 文件较大时，索引分配方式觉有明显优势

2. 存储空间管理

    - 空闲表
        - 空闲盘区的分配与内存分配类似
        - 首次适应算法、循环适应算法等
        - 回收过程也与内存回收类似
    - 空闲链表
        - 空闲链表法把所有空闲盘区组成一个空闲链表
        - 每隔链表节点存储空闲盘块和空闲的数目
    - 位示图
        - 位示图维护成本很低
        - 位示图可以非常容易找到空闲盘块
        - 位示图使用 0/1 比特位，占用空间很小

#### 6.13.3 目录管理

1. 目录树
    - 任何文件或者目录都只有唯一路径

### 6.14 Linux 文件的基本操作

#### 6.14.1 Linux 目录

1. 根目录：/bin, /etc/ /home /usr /opt /proc /dev /mnt /lib /var ...

   | 目录  | 描述                                                                                                                                                                                                                                                                                                                                                                  |
      | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | /bin  | bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。                                                                                                                                                                                                                                                                                                 |
   | /etc  | etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。                                                                                                                                                                                                                                                                                 |
   | /home | 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。                                                                                                                                                                                                                                               |
   | /usr  | usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。                                                                                                                                                                                                             |
   | /opt  | opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。                                                                                                                                                                                                                                    |
   | /proc | proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br/>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器： |
   | /root | 该目录为系统管理员，也称作超级权限者的用户主目录。                                                                                                                                                                                                                                                                                                                    |
   | /sbin | s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。                                                                                                                                                                                                                                             |
   | /dev  | dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。                                                                                                                                                                                                                                                    |
   | /mnt  | 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。                                                                                                                                                                                                                                             |

2. 相对路径

3. 绝对路径

#### 6.14.2 Linux 文件常用操作

- （目录/文件）创建、删除、读取、写入

#### 6.14.3 Linux 文件类型

- 套接字
- 普通文件
- 目录文件
- 符号链接
- 设备文件
- FIFO

### 6.15 Linux 的文件系统

#### 6.15.1 文件系统

> FAT、NTFS、EXT2/3/4

1. FAT：File Allocation Table
    - FAT16、FAT32 等，微软 DOS/Windows 使用的文件系统
    - 使用一张表保存盘块的信息
2. NTFS: New Technology File System
    - WindowNT 环境的文件系统
    - NTFS 对 FAT 进行了改进，取代了旧的文件系统
3. EXT Extended File system 扩展文件系统
    - Linux 的文件系统
    - EXT2/3/4：数字表示第几代

#### 6.15.2 Ext 文件系统

- Boot Sector: 启动扇区，安装开机管理程序
- Block Group: 块组，存储数据的实际位置
- Inode Table
    - 存放文件 Inode 的地方
    - 每一个文件(目录)都有一个 lnode
    - 是每一个文件(目录)的 索引节点
- Inode 存放以下信息
    - 索引节点编号
    - 文件类型
    - 文件权限
    - 文件物理地址
    - 文件长度
    - 文件链接计数
    - 文件存放时间
    - 文件状态
    - 访问计数
    - 链接指针
    - ...
    - 文件名不是存放在 Inode 节点上的，而是存放在目录的 Inode 节点
    - 列出目录文件的时候无需加载文件的 Inode
- Inode bitmap
    - Inode 的位示图
    - 记录已经分配的 Inode 和 未分配的 Inode
- Data Block
    - Data Block 是存放文件内容的地方
    - 每一个 block 都有唯一的编号
    - 文件的 block 记录在文件的 Inode 上
- Block bitmap
    - 功能与 Inode bitmap 类似
    - 记录 Data block 的使用情况
- Superblock
    - 记录整个文件系统相关信息的地方
    - Block 和 Inode 的使用情况
    - 时间信息、控制信息等

### 6.16 操作系统的设备管理

#### 6.16.1 广义的 IO 设备

> 对 CPU 而言，凡是对 CPU 进行数据输入的都是输入设备
>
> 对 CPU 而言，凡是 CPU 进行数据输出的都是输出设备

1. 按使用特性分类
    - 存储设备：U 盘、内存、磁盘等
    - 交互 IO 设备：键盘、鼠标、显示器等
2. 按信息交换的单位分类
    - 块设备：磁盘、SD 卡
    - 字符设备：打印机、Shell 终端
3. 按设备的共享属性分类
    - 独占设备
    - 共享设备
    - 虚拟设备
4. 按传输速率分类
    - 低速设备
    - 中速设备
    - 高速设备

#### 6.16.2 IO 设备的缓冲区

> CPU 与 IO 设备的速率不匹配问题

- 减少 CPU 处理 IO 请求的频率
- 提高 CPU 与 IO 设备之间的并行性

#### 6.16.3 SPOOLing 技术

- 是关于慢速字符设备如何与计算机主机交换信息的一种技术
- 利用高速共享设备将低速的独享设备模拟为高速的共享设备
- 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备

### 6.17 操作系统基础篇专项练习题 39 道

### 6.18 专项练习题答案揭晓与解析

### 6.19 请回答操作系统是如何启动的？

## 7 操作系统之提升篇

### 7.1 本章节知识点概要与学习计划

1. 线程同步
2. 进程同步
3. 既是重要的理论知识，也是重要的实践知识
4. 笔试面试、开发高性能服务等都非常有用

### 7.2 线程同步之互斥量

- 两个线程的指令交叉执行
- 互斥量可以保证先后执行
- 原子性
    - 原子性是指一系列操作不可被中断的特性
    - 这一系列操作要么全部执行完成，要么全部没有执行
    - 不存在部分执行部分未执行的情况
- 互斥量是最简单的线程同步的方法
- 互斥量（互斥锁），处于两态之一的变量 ：解锁和加锁
- 两个状态可以保证资源访问的串行
- 操作系统直接提供了互斥量的 API
- 开发者可以直接使用 API 完成资源的加载、解锁操作
- pthread_mutex_t

### 7.3 线程同步之自旋锁

> 死循环等待锁被释放

- 自旋锁也是一种多线程同步的变量
- 使用自旋锁的线程会反复检查锁变量是否可用
- 自旋锁不会让出 CPU，是一种**忙等待**状态
- 自旋锁避免了进程或线程上下文切换的开销
- 操作系统内部很多地方使用的是自旋锁
- 自旋锁不适合在单核 CPU 使用
- pthread_spinlock_t

### 7.4 线程同步之读写锁

- 读写锁是一种特殊的自旋锁
- 允许多个读者同时访问资源以提高性能
- 对于读写操作则是互斥的
- pthread_rwlock_t

### 7.5 线程同步之条件变量

- 缓冲区小于等于 0 时，不允许消费者消费，消费者必须等待
- 缓冲区满时，不允许生产者往缓冲区生产，生产者必须等待
- 当生产者生产一个产品时，唤醒可能等待的消费者
- 当消费者消费一个产品时，唤醒可能等待的生产者
- 条件变量是一种相对复杂的线程同步方法
- 条件变量允许线程睡眠，直到满足某种条件
- 当满足条件时，可以向该线程发送信号，通知唤醒

### 7.6 线程同步方法总结

- 互斥量、自旋锁、读写锁
- 条件变量：加锁保护条件变量、等待条件满足被唤醒、解锁

| 同步方法 | 描述                                                 |
| -------- | ---------------------------------------------------- |
| 互斥锁   | 最简单的一种线程同步方法，会阻塞线程                 |
| 自旋锁   | 避免切换的一种线程同步方法，属于忙等到               |
| 读写锁   | 为读多写少的资源设计的线程同步方法，可以显著提高性能 |
| 条件变量 | 相对复杂的一种线程同步方法，有更灵活的使用场景       |

### 7.7 使用 fork 系统调用创建进程

- Fork 系统调用是用于创建进程的
- fork 创建的进程初始化状态与父进程一样
- 系统会为 fork 进程分配新的资源
- Fork 系统调用无参数
- Fork 会返回两次，分别返回 子进程 id 和 0
- 返回子进程 id 的是父进程，返回 0 的是子进程

### 7.8 进程同步之共享内存

- 在某种程度上，多进程是共同使用物理内存的
- 由于操作系统的进程管理，进程间的内存空间是独立的
- 进程默认是不能访问进程空间之外的内存空间的
- 共享存储允许不相关的进程访问同一片物理内存
- 共享内存是两个进程之间共享和传递数据最快的方式
- 共享内存未提供同步机制，需要借助其他机制管理访问
- 步骤：申请共享内存=》连接到进程空间=》使用共享内存=》脱离进程空间&删除
- 共享存储是两个进程之间共享和传递数据最快的一种方式
- 共享内存未提供同步机制，需要借助其他机制管理访问
- 共享内存是高性能后台开发中最常用的进程同步方式

### 7.9 进程同步之 Unix 域套接字

- 域套接字是一种高级的进程间通信的方法
- Unix 域套接字可以用于同一机器进程间通信
- 套接字(socket) 原是网络通信中使用的术语
- Unix 系统提供的域套接字提供了网络套接字类似的功能
- 服务端使用步骤
    - 创建套接字=》绑定套接字=》监听套接字=》接收&处理信息
- 客户端使用步骤
    - 创建套接字=》链接套接字=》发送信息
- 提供了单击简单可靠的进程通信同步服务
- 只能在单击使用，不能跨机器使用

### 7.10 请拓展调研进程间通信还有那些方法

## 8 操作系统实践

### 8.1 本章节知识概要与学习计划

了解 Python 的同步原语 =》 实现线程安全的队列=》实现基本任务对象=》了解线程池=》实现任务处理线程=》实现任务处理线程池=》实现异步任务处理对象

### 8.2 Python 同步原语

#### 8.2.1 互斥量

#### 8.2.2 条件变量

### 8.3 实现线程安全的队列 Queue

- 队列用于存放多个元素，是存放各种元素的“池”
    - 实现线程安全的队列
        - 获取当前队列元素数量
        - 往队列放入元素
        - 从队列取出元素
- 队列可能有多个线程同时操作，因此需要保证线程安全
    - 多个线程同时访问队列元素时候，为了保证多个线程获取的串行，需要使用“锁”保护队列
    - 队列元素为空时获取队列元素，阻塞，等待队列不为空 =》 使用条件变量等待队列元素

### 8.4 实现基本任务对象 Task

### 8.5 线程池简介

### 8.6 实现任务处理线程 ProcessThread

### 8.7 实现任务处理线程池 Pool

### 8.8 编写测试用例

### 8.9 实现异步任务处理 AsyncTask

## 9 计算机网络之概述篇

### 9.1 本章节知识概要与学习计划

#### 9.1.1 什么是计算机网络

> 计算机网络主要由一些通用的、可编程的硬件互链而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增长的应用。

- 计算机网络不仅仅是软件概念，还包含了硬件设备
- 计算机网络不仅仅是信息通信，还可以支持广泛的应用

#### 9.1.2 计算机网络的分类

- 网络的作用范围分类

    - 广域网 WAN

    - 城域网 MAN

    - 局域网 LAN

    - | 分类   | 英文                    | 范围           | 区域       |
          | ------ | ----------------------- | -------------- | ---------- |
      | 广域网 | WAN：Wide Area Network  | 几十到几千公里 | 跨省、跨国 |
      | 城域网 | MAN：Metro Area Network | 5KM-50Km       | 城市间     |
      | 局域网 | LAN：Local Area Network | 1km 以内       | 地区内     |

- 网络的使用者分类

    - 公用网络
    - 专用网络

#### 9.1.3 本章内容概览

1. 计算机网络概述
    - 发展历史、层次结构
    - 网络拓扑、性能指标
2. 物理层
    - 物理层概述
3. 数据链路层
    - 数据链局层概述、差错监测
    - 最大传输单元 MTU、以太网协议

### 9.2 计算机网络的发展简史

#### 9.2.1 互联网的发展历史

1. 第一阶段：单个网络 ARPANET

    - 交换机

2. 第二阶段：三级结构互联网

    - 主干网 + 地区网 + 校园网

3. 第三阶段：多层次 ISP 互联网：

    - Internet Service Provider 网络服务提供商

    - 中国电信、中国移动、中国联通等
    - 网络结构：主干 ISP + 地区 ISP + 公司/ 校园 / 家庭 / 其他的

#### 9.2.2 中国互联网的发展简史

1. 1908 年开始互联网实验
2. 1989 年第一个公共网络建立运行
3. 1994 年接入国际互联网
4. 规模较大的公共网络
    - 中国电信互联网 CHINANET
    - 中国联通互联网 UNINET
    - 中国移动互联网 CMNET
    - 中国教育与科研计算机网 CERNET
    - 中国科学技术网 CSTNET
5. 民间的互联网
    - 1996 年 张朝阳创建搜狐
    - 1997 年，丁磊创建网易
    - 1998 年，王志东创建新浪
    - 1998 年，马化腾、张志东创建腾讯
    - 1999 年，马云创建阿里巴巴
    - 2000 年，李彦宏创建百度
    - ....

### 9.3 层次结构设计的基本原则

#### 9.3.1 层次结构设计的基本原则

> 为什么要使用层次结构设计？
>
> 计算机网络需要解决的问题：保证数据通路顺畅、识别目的计算机、目的计算机状态、数据是否错误等
>
> 分层实现不同的功能，所以采用层次结构设计

1. 网络应用数据：视频、文件、游戏
2. 数据可靠通信：数据错误、重复
3. 物理网络接入：光电等物理特性

设计的基本原则

- 各层之间是相互独立的
- 每一层要有足够的灵活性
- 各层之间完全解耦

#### 9.3.2 OSI 七层模型

1. 七层模型

    1. 应用层：为计算机用户提供接口和服务
    2. 表示层：数据处理（编码解码、加密解密等
    3. 会话层：管理（建立、维护、重连）通信会话
    4. 传输层：管理端到端的通信链接
    5. 网络层：数据路由（决定数据在网络的路径）
    6. 数据链路层：管理响铃节点之间的数据通信
    7. 物理层：数据通信的光电物理特性

2. 特性

    - OSI 欲成为全球计算机都遵循的特性

    - OSI 在市场化过程中困难重重，TCP/IP 在全球范围内成功运行

    - OSI 最终并没有成为广为使用的标准模型

3. 为什么没有被市场完全接受，原因如下：

    - OSI 的专家缺乏实际经验

    - OSI 标准制定周期过长，按照 OSI 标准生产的设备无法及时进入市场
    - OSI 模型设计的并不合理，一些功能在多层中重复出现

#### 9.3.3 TCP/IP 四层模型

1. 四层模型
    1. 应用层：映射 OSI 中的应用层、表示层、会话层，主要是 HTTP/FTP/...等协议
    2. 传输层：映射 OSI 的 传输层，主要是 TCP/UCP 协议等
    3. 网络层：映射 OSI 的网络层，主要是 IP/ICMP 协议等
    4. 网络接口层：映射 OSI 的数据链路层、物理层，主要是 Ethernet/ARP/RARP 协议等
2. 实际应用

### 9.4 现代互联网的网络拓扑

#### 9.4.1 边缘部分

1. 边缘部分：家庭
    - 终端机器：电脑、智能家电、手机 =》 路由器 =》 网关 =》 地区 ISP
2. 边缘部分：企业：
    - 终端 =》 就近的路由器 =》就近的内网网关 =》 统一网管 =》 地区 ISP

#### 9.4.2 核心部分

主干 ISP

树状结构

客户-服务器（C/S）模式

对等链接（P2P）模式

### 9.5 计算机网络的性能指标

1. 速率

    - Bps = bit/s

2. 时延

    - 发送时延：

      发送时延 = 数据长度(bit) / 发送速率（受限于计算机网卡）（bit/s）

    - 传播时延

      传播时延 = 传输路径距离 / 传播速率（受限于传输介质）（bit/s）

    - 排队时延

        - 数据包在网络设备中等待被处理的时间

    - 处理时延

        - 数据包到达设备或者目的机器被处理所需要的时间

    - 总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延

3. 往返时间 RTT

    - RTT: Route-Trip Time 是评估网络质量的一项重要指标
    - RTT 表示的是数据报文在端到端通信中的来回一次的时间
    - 通常使用 ping 命令来查看 RTT

### 9.6 物理层概述

#### 9.6.1 物理层的作用

1. 物理层的作用
    - 链接不同的物理设备
    - 传输比特流
2. 介质
    1. 双绞线
        1. 无屏蔽双绞线
        2. 屏蔽双绞线
    2. 同轴电缆
    3. 光纤
    4. 红外线、无线、激光
3. 比特流
4. 物理特性
    1. 机械特性
    2. 电气特性
    3. 功能特性
    4. 过程特性

#### 9.6.2 信道的基本概念

- 信道是往一个方向传送信息的媒体
- 一条通信电路包含一个接收信道和一个发送信道
- 问题：发送和接收会不会冲突？冲突了怎么办？
    - 单工通信信道
        - 只能一个方向通信，没有反方向反馈的信道
        - 有线电视、无线电视收音机等等
    - 半双工通信通道
        - 双方都可以发送和接收信息
        - 不能双方同时发送，也不能同时接收
    - 全双工通信通道
        - 双方都可以发送和接收信息

#### 9.6.3 分用-复用技术

- 频分复用
- 时分复用
- 波分复用
- 码分复用

### 9.7 数据链路层概述

1. 要解决的问题
    - 封装成帧
        - 帧 是数据链路层数据的基本单位
        - 发送端在网络层的一段数据前后添加特定标记形成 帧
        - 接收端根据前后特定标记识别出 帧
        - 物理层不管你 帧 不帧
        - 帧首部和尾部是特定的控制字符（特定比特流）
    - 透明传输
        - 透明 在计算机领域是非常重要的一个术语
        - 一种实际存在的事物却又看起来不存在一样
        - 即是控制字符在帧数据中，但是要当做不存在的去处理
        - 编程语言中 \ 一般为转义字符
        - \n \t 等控制字符
    - 差错检测
        - 物理层只管传输比特流，无法控制是否出错
        - 数据链路层负责起“差错监测”的工作

### 9.8【 讨论题】在数据链路层和物理层中工作的设备都有哪些？

### 9.9 数据链路层的差错监测

#### 9.9.1 奇偶校验码

#### 9.9.2 循环冗余校验码 CRC

- 一种根据传输或保存的数据而**产生固定位数校验码**的方法
- **检测** 数据传输或者保存后可能出现的错误
- 生成的数字计算出来并且附加到数据后面
- 模 2 除法
    - 模 2 除法是二进制下的除法
    - 与算术除法类似，但除法不错位，实际是“异或”操作
- 步骤
    - 选定一个用于校验的多项式 G(x),并在数据尾部添加 r 个 0
    - 将添加 r 个 0 后的数据，使用模 2 除法 除以 多项式的位串
    - 得到的余数填充在原数据 r 个 0 的位置得到可校验的位串
- CRC 的错误检测能力与位串的阶数 r 有关
- 数据链路层只进行数据的检测，不进行纠正

### 9.10 最大传输单元 MTU

1. MTU

    - 最大传输单元 MTU：maximum transmission Unit

    - 数据链路层的数据帧也不是无限大的

    - 数据帧过大或者过小都会影响传播的效率

2. 路径 MTU

    - 路径 MTU 由链路中 MTU 的最小值决定

### 9.11 以太网协议详解

> 问题：路由器怎么知道 A 要发送给谁

#### 9.11.1 MAC 地址

- MAC 地址（物理地址、硬件地址）
- 每一个设备都拥有唯一的 MAC 地址
- MAC 地址共 48 位，使用十六进制表示

#### 9.11.2 以太网协议

- 以太网是一种使用广泛的局域网技术
- 以太网是一种应用于数据链路层的协议
- 使用以太网可以完成**相邻设备**的数据帧传输
- 步骤
    - A 通过网卡发出数据帧
    - 数据帧到达路由器，路由器取出前 6 字节
    - 路由器匹配 MAC 地址列表，找到对应的网络接口
    - 路由器往该网络接口发送数据帧

### 9.12 计算机网络概述篇专项练习题 19 道&面试常考题分享

### 9.13 专项练习题答案揭晓与解析

## 10 计算机网络之网络层篇

### 10.1 章节导学

### 10.2 ip 协议详解

#### 10.2.1 虚拟互连网络

- 实际的计算机网络是错综复杂的
- 物理设备通过使用 IP 协议，屏蔽了物理网络之间的差异
- 当网路中的主机使用 IP 协议连接时，则无需关注网络细节

#### 10.2.2 IP 协议

- IP 协议使得复杂的实际网络变为一个虚拟互链的网络

- IP 协议使得网络蹭层可以屏蔽底层细节而专注网络层的数据转发

- IP 协议解决了在虚拟网络中数据传输路径的问题

- IP 地址长度分为 32 位，常分为 4 个 8 位

- IP 地址常使用点分十进制来表示（0~255.0~255.0~255.0~255）

- 信息如下

| 4位版本 | 4位首部长度 | 8位服务类型(TOS) | colspan="2" 16位总长度（字节） |
| ---- | ---- | ---- | ---- |
| colspan="3" 16位标识 | 3位标志 | 13位偏移 |
| 8位生存时间（TTL） | 8位协议 | colspan="2" 16位首部校验和 |
| colspan="5" 32位源IP地址 |
| colspan="5" 32位目的IP地址 |
| colspan="5" 选项options(若有) |
| colspan="5" IP数据 |

- 版本：占 4 位，指的是 IP 协议的版本，通信双方的版本必须一致，当前主流版本是 4，即 IPV4, 也有 IPV6

- 首部位长度：占 4 位，最大数值为 15，表示的是 IP 首部长度，单位是 32 位字（4 个字节），也即是 IP 首部最大长度为 60 字节

- 总长度：占 16 位，最大数值为 65535，表示的是 IP 数据包总长度（IP 首部+IP 数据）

- TTL：占 8 位，表明 IP 数据报文在网络中的寿命，每经过一个设备，TTL 减 1，当 TTL=0 时，网络设备必须丢弃该报文

- 协议：占 8 位，表明 IP 数据所携带的具体数据是什么协议的（如 TCP、UDP 等）

- 源 IP 地址

- 目的 IP 地址

### 10.3 ip 协议的转发流程

- 逐跳 hop-by-hop

#### 10.3.1 路由表简介

- 计算机或者路由器都拥有路由表

#### 10.3.2 IP 协议的转发流程

1. 步骤

    - A 发布目的地为 C 的 IP 数据包，查询路由表发现下一跳为 E

    - A 将数据报发送给 E

    - E 查询路由表发现下一跳为 F，将数据包发送给 F

    - F 查询路由表发现目的地 C 直接链接，将数据包发送给 C
    - ...

2. 特点

    - 数据帧的每一跳的 MAC 地址都在变化
    - IP 数据报每一跳的 IP 地址始终不变

### 10.4 arp 协议与 rarp 协议

- (R)ARP 协议是 TCP/IP 协议栈里面最基础的协议
- ARP 和 RARP 的操作对程序员是透明的
- 理解（R）ARP 协议有助于理解网络分层的细节

- ARP: address resolution protocol 地址解析协议
- ARP 缓存表
    - ARP 缓存表缓存有 IP 地址和 MAC 地址的映射关系
    - ARP 缓存表没有缓存 IP 地址和 MAC 地址的映射关系
    - ARP 缓存表是 ARP 协议和 RARP 协议运行的关键
    - ARP 缓存表缓存了 IP 地址到硬件地址之间的映射关系
    - ARP 缓存表中的记录并不是永久有效的，有一定的期限
- RARP: Reverse Address Resolution Protocol 逆地址解析协议

### 10.5 IP 地址的子网划分

#### 10.5.1 分类的 IP 地址

1. 特殊的主机号

    - 主机号全 0 表示当前网络段，不可分配为特定主机
    - 主机号为全 1 表示广播地址，向当前网络段所有主机发消息

2. 特殊的网络号

    - A 类地址网络段全 0（00000000）表示特殊网络
    - A 类地址网络段后 7 位全 1（01111111:127）表示回环地址
    - B 类地址网络段（10000000.00000000:128.0）是不可使用的
    - C 类地址网络段（192.0.0）是不可使用的

3. 127.0.0.1

   127.0.0.1 通常被称为本地回环地址（loopback address），不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在 Windows 操作系统中也有相似的定义，所以通常在安装网卡前就可以 ping 通这个本地回环地址，一般都会用来检查本地网络协议、基本数据接口等是否是正常的

#### 10.5.2 划分子网

1. 子网掩码
    - 子网掩码和 IP 地址一样，都是 32 位
    - 子网掩码由连续的 1 和连续的 0 组成
    - 某一个子网的子网掩码具备网络号位数个连续的 1

#### 10.5.3 无分类编址 CIDR

- CIDR 中没有 A B C 类网络号和子网划分的概念
- CIDR 将网络前缀相同的 IP 地址称为一个 CIDR 地址块
- 斜线记法

### 10.6 网络地址转换 nat 技术

1. 原因：
    - IPV4 最多只有 40+亿个 IP 地址
    - 早起 IP 地址的不合理规划导致 IP 号浪费
2. 类型
    - 内网地址
        - 内部机构使用
        - 避免与外网地址重复
    - 外网地址
        - 全球范围使用
        - 全球公网唯一
3. 网络地址转换 NAT：Network Address Translation
    - NAT 技术用于多个主机通过一个共有 IP 访问互联网的私有网络中
    - NAT 减缓了 IP 地址的消耗，但是增加了网络通信的复杂度

### 10.7 ICMP 协议详解

1. 网络控制报文协议（Internet Control Message Protocol）
    - ICMP 协议可以报告错误信息或者异常情况

### 10.8 icmp 协议的应用

#### 10.8.1 Ping 应用

- ping 回环地址 127.0.0.1
- Ping 网关地址
- Ping 远端地址

#### 10.8.2 Traceroute 应用

- Traceroute 可以探测 IP 数据报在网络中走过的路径
- TTL：占 8 位，表明 IP 数据报文在网络中的寿命，每经过一个设备，TTL 减 1，当 TTl=0 时，网络设备必读丢弃该报文

### 10.9 网络层的路由概述

1. 路由算法的本质

    - 下一跳地址是怎么来的
    - 下一跳地址是唯一的吗？
    - 下一跳地址是最佳的吗？
    - 路由器那么多，他们是怎么协同工作的？

   > 需要一个好的算法去解决这些事情

2. 路由算法实际上是图论的算法，实际上，路由算法比图论的算法更复杂

3. 特点

    - 算法是**正确**的、**完整**的
    - 算法在计算上应该尽可能的**简单**
    - 算法可以**适应网络中的变化**
    - 算法是**稳定**的和**公平**的
    - 互联网的规模是非常大的
    - 互联网环境是非常复杂的

4. 对互联网进行划分

    - 自治系统：Automomous system
        - 一个自治系统 AS 是处于一个管理机构下的网络设备群
        - AS 内部网络自行管理，AS 对外提供一个或者多个出(入)口
        - 自治系统内部的路由的协议称为：内部网关协议（RIP、OSPF）
        - 自治系统外部路由的协议称为：外部网关协议（BGP）

### 10.10 内部网关路由协议之 rip 协议

#### 10.10.1 距离矢量（DV）算法

- 每一个节点都使用两个向量 Di 和 Si
- Di 描述的是当前节点到别的节点的距离
- Si 描述的是当前节点到别的节点的下一节点
- 每一个节点与相邻的节点交换向量 Di 和 Si 的信息
- **每一个节点根据交换的信息更新自己的节点信息**

#### 10.10.2 RIP 协议的过程

- RIP：Routing information protocol 协议
- RIP 协议是使用 DV 算法的一种路由协议
- RIP 协议把网络中的跳数 hop 作为 DV 算法的距离
- RIP 协议每隔 30s 交换一次路由信息
- RIP 协议认为跳数 > 15 的路由则为不可达路由

1. 特点
    - Rip 协议：实现简单，开销很小
    - RIP 协议：限制了网络的规模
    - RIP 协议：“坏消息传的慢”，更新收敛时间过长

### 10.11 dijkstra（迪杰斯特拉）算法

- Dijkstra 算法是著名的图算法
- Dijkstra 算法解决有权图从一个节点到其他节点的最短路径问题
- 以起始点为中心，向外层层扩散

### 10.12 内部网关路由协议之 OSPF 协议

#### 10.12.1 链路状态（LS）协议

特点

- 向所有的路由器发送消息：一传十、十传百，并且只和相邻的路由器交互消息
- 消息描述该路由器与相邻路由器的链路状态：距离、时延、贷款。。。
- 只有链路状态发生变化时，才发送更新消息：每隔 30s 交互路由信息

#### 10.12.2 OSPF 协议的过程

- OSPF：Open Shortest Path First 开放最短路径优先

- OSPF 协议的核心是 Dijkstra 算法

- 特征如下

    - 向所有的路由器发送消息：获得网络中的所有消息=》网络中的完整拓扑
        - 也成为链路状态数据库
        - 链路状态数据库是全网一致的
    - 消息描述该路由器与相邻路由器的**链路状态**
    - 只有链路状态发生变化时，才发送更新消息
        - 减少了数据的交换，更快收敛

- 五种消息类型

    - 问候消息（hello）
    - 链路状态数据库描述信息
    - 链路状态请求消息
    - 链路状态更新消息
    - 链路状态确认消息

- 过程

    - 路由器接入网络 =》 路由器向邻居发出问候消息 =》与邻居交流链路状态数据库 =》 广播和更新未知路由

- 比较

  | RIP 协议                 | OSPF 协议                        |
    | ------------------------ | -------------------------------- |
  | 丛邻居看网络             | 整个网络的拓扑                   |
  | 在路由器之间累加距离     | Dijkstra 算法计算最短路径        |
  | 频繁、周期更新，收敛很慢 | 状态变化更新，收敛很快           |
  | 路由间拷贝路由信息       | 路由间传递链路状态，自行计算路径 |

### 10.13 外部网关路由协议之 BGP 协议

1. BGP
    - BGP：border gateway protocol 边际网关协议
    - BGP 协议是运行在 AS 之间的一种协议
2. 原因：
    - 互联网的规模很大
    - AS 内部使用不同的路由协议
    - AS 之间需要考虑除网络特性以外的一些因素（政治、安全。。。）
    - BGP 协议能够找到一条到达目的比较好的路由
3. BGP 发言人（speaker）
    - BGP 并不关心内部网络拓扑
    - AS 之间通过 BGP 发言人交流信息
    - BGP Speaker 可以人为配置策略

## 11 计算机网络之传输层

### 11.1 章节导学

### 11.2 UDP 协议详解

1. UDP 协议
    - UDP：User Datagram Protocol 用户数据报协议
    - IDP 是一个非常简单的协议
2. UDP 特点
    - UDP 是无连接协议
    - UDP 不能保证可靠的交付数据：想发就发，无法保证数据在网络中是否丢失
    - UDP 是面向报文传输的
    - UDP 没有拥塞控制
    - UDP 的首部开销很小

### 11.3 TCP 协议详解

1. TCP 协议
    - TCP：transmission control protocol 传输控制协议
    - TCP 协议是计算机网络中非常复杂的一个协议
2. TCP 特点
    - TCP 是面向链接的协议
    - TCP 的一个连接有两端（点到点通信）
    - TCP 提供可靠的传输服务
    - TCP 协议提供全双工的通信
    - TCP 是面向字节流的协议
3. TCP 首部

### 11.4 可靠传输的基本原理

#### 11.4.1 停止等待协议

1. 两方
    - 接收方
    - 发送方
2. 可靠传输解决的问题
    - 发送的消息在路上丢失了
    - 确认的消息在路上丢失了
    - 确认的消息很久才到
3. 定时器
    - 超时定时器
        - 每发送一个消息，都需要设置一个定时器
4. 总结
    - 停止等待协议是最简单的可靠传输协议
    - 停止等待协议对信道的利用效率不高

#### 11.4.2 连续 ARQ 协议

1. ARQ
    - ARQ: automatic repeat request 自动重传请求

### 11.5 tcp 协议的可靠传输

- TCP 协议的可靠传输基于连续 ARQ 协议
- TCP 的滑动窗口以字节为单位
- 选择重传

### 11.6 tcp 协议的流量控制

- 流量控制指让发送方发送速率不要太快
- 流量控制是使用滑动窗口来实现的
- 坚持定时器
    - 当接收到窗口为 0 的消息，则启动**坚持定时器**
    - 坚持定时器每隔一段时间发送一个**窗口探测报文 **
- TCP 协议使用滑动窗口实现流量控制
- 坚持定时器的作用

### 11.7 TCP 协议的拥塞控制

- 一条线路链路经过非常多的设备
- 数据链路中各个部分都有可能成为网络传输的瓶颈

1. 流量控制和拥塞控制的区别

- 流量控制考虑点对点的通信量的控制
- 拥塞控制考虑整个网络，是全局性的考虑
- 判断方法：报文超时则认为是拥塞

2. 拥塞控制的方法
    - 慢启动算法
        - 由小到大逐渐增加发送数据量
        - 每收到一个报文确认，就加一：数量指数增长
    - 拥塞避免算法
        - 维护一个拥塞窗口的变量
        - 只要网络不拥塞，就试探着拥塞窗口调大

### 11.8 tcp 连接的三次握手

1. TCP 标记三次握手的过程
    - 占 6 位，每位各有不同意义，URG、ACK、PSH、RST、SYN、FIN
2. 为什么发送方要发送第三个确认报文呢
    - 已经失效的连接请求报文传送到对方，引起错误

### 11.9 tcp 连接的四次挥手

- 四次挥手的作用
- 等待计时器的作用

1. 2MLS
    - MLS：MAX Segment Lifetime: 最长报文段寿命
    - MLS：建议设置为 2 分钟
2. 为什么需要等待 2MSL
    - 最后一个报文没有确认
    - 确保发送方的 ACK 可以到达接收方
    - 2MSL 时间内没有收到，则接受方会重发

### 11.10 套接字与套接字编程

- 使用端口（port）来标记不同的网络进程
- 端口（port）使用 16 比特位表示（0-65535）
- 套接字（socket）是抽象概念，表示 TCP 链接的一端
- 通过套接字可以进行数据发送或者接收
- TCP 链接由两个套接字组成

## 12 计算机网络之应用层篇

### 12.1 章节导学

1. 应用层概述
    - 传输层以及以下的层提供完整的通信服务
    - 应用层是面向用户的一层

### 12.2 dns 详解

1. DNS
    - DNS：Domain Name System: 域名系统
    - IP 地址：端口 =》主机的进程（web 服务，网络存储服务，远程调用服务，邮件服务，。。。）
    - 使用域名帮助记忆：域名=》DNS 服务=》IP
    - 域是由点、字母、数字组成
    - 点分割不同的域
    - 域名可以分为
        - 顶级域
            - 国家：cn、us、uk、ca 等
            - 通用：com、net、gov、org
        - 二级域：aliyun、taobao、qq 等
        - 三级域

### 12.3 DHCP 协议详解

1. DHCP 是什么
    - DHCP: Dynamic Host Configuration Protocol 动态主机设置协议
    - DHCP 是一个局域网协议
    - DHCP 是应用 UDP 协议的应用层协议
2. DHCP 的工作

### 12.4 http 协议详解

1. HTTP 是什么
    - HTTP：hyperText Transfer Protocol 超文本传输协议
    - http(s)://<主机>:<端口>/<路径>
    - HTTP 协议是可靠的数据传输协议
    - web 服务器：
        - 硬件部分
        - 软件部分：nginx、apache
2. HTTP 工作过程
    - 接受客户端链接 =》接收请求报文=》处理请求=》访问 web 资源=》构造应答=》发送应答
3. HTTP 请求方法
    - GET：获取指定的服务端资源
    - POST：提交数据到服务端
    - DELETE：删除指定的服务端资源
    - UPDATE：更新指定的服务端资源
    - PUT
    - OPTIONS
    - PATCH
    - HEAD
    - TRACE
4. 怎么指定资源呢
    - 在地址中指定
        - Https://coding.imooc.com/class/355.html
        - Https://coding.imooc.com/?sort=0&unlearn=0&page=2
    - 在请求数据中指定
5. 状态码
    - 200-299 成功状态码
    - 300-399 重定向状态码
    - 400-499 客户端错误状态码
    - 500-599 服务端错误状态码

### 12.5 HTTP 工作的结构

#### 12.5.1 WEB 缓存

1. 2/8 原则
2. 存储器层次结构：
    - 主存
    - 辅存

#### 12.5.2 WEB 代理

1. 正向代理
2. 反向代理
3. nginx、haproxy

#### 12.5.3 CDN

1. CDN：content delivery network 内容分发网络：多媒体内容

#### 12.5.4 爬虫

- 增加网络拥塞
- 损耗服务器资源

### 12.6 https 协议详解

- http 是明文传输的：账号信息、个人信息、账户余额、交易信息、敏感信息
- Https（Secure）是安全的 HTTP 协议
- Http(s)://<主机>:<端口>/<路径>

1. 加密模型
    - 对称加密：使用秘钥加密，使用秘钥解密，两个秘钥一致
    - 非对称加密：使用 A 秘钥加密，使用 B 秘钥解密，两个秘钥不一致
        - A 和 B 是拥有一定数字关系的一组秘钥：私钥自己使用，不对外公开；公钥给大家使用，对外公开
2. 数字证书是可新人组织颁发给特定对象认证

## 13 计算机网络实践

## 14 课程精髓终结
